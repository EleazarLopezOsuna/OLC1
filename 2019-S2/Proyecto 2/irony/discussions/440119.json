[
  {
    "Id": "1029745",
    "ThreadId": "440119",
    "Html": "I'm trying to separate my parsing into two general sections separated by &quot;on cancel:&quot;. However, &quot;on cancel:&quot; never shows up as a valid terminal. When I include it I get errors saying that such text is invalid. Here is my main grammar creation method.<br />\n<pre><code>        public ProcedureGrammar(IEnumerable&lt;TelemetryDefinitionModel&gt; telemetryDefinitions)\n        {\n            // in BNF:\n            // program := row*\n            // connector = at, +=, = \n            // row := &quot;set&quot; [actionName] connector actionValue actionUnit? &quot;until&quot; [telmetryName] operator telemetryValue telmetryUnit?\n\n            var program = new NonTerminal(&quot;Program&quot;);\n\n            var telemetryTriples = new NonTerminal(&quot;TelemetryTriples&quot;);\n            var actionSetTriples = new NonTerminal(&quot;ActionSetTriples&quot;);\n            var actionDecTriples = new NonTerminal(&quot;ActionDecTriples&quot;);\n            var actionIncTriples = new NonTerminal(&quot;ActionIncTriples&quot;);\n            var actionMulTriples = new NonTerminal(&quot;ActionMulTriples&quot;);\n\n            var actions = telemetryDefinitions.Where(td =&gt; !td.IsReadonly).ToList();\n            if (actions.Count &lt;= 0)\n                throw new ArgumentException(&quot;Expected at least one non-readonly telemetry item definition.&quot;, &quot;telemetryDefinitions&quot;);\n\n            telemetryTriples.Rule = CreateTerminal(telemetryDefinitions, &quot;until&quot;);\n            actionSetTriples.Rule = CreateTerminal(actions, &quot;set&quot;, &quot;at&quot;);\n            actionDecTriples.Rule = CreateTerminal(actions, &quot;dec&quot;, &quot;by&quot;);\n            actionIncTriples.Rule = CreateTerminal(actions, &quot;inc&quot;, &quot;by&quot;);\n            actionMulTriples.Rule = CreateTerminal(actions, &quot;mul&quot;, &quot;by&quot;);\n\n            var comment = new CommentTerminal(&quot;Comment&quot;, &quot;#&quot;, &quot;\\r&quot;, &quot;\\n&quot;, &quot;\\u2085&quot;, &quot;\\u2028&quot;, &quot;\\u2029&quot;);\n            NonGrammarTerminals.Add(comment);\n\n            var startSection = new NonTerminal(&quot;StartSection&quot;);\n            var cancelSection = new NonTerminal(&quot;CancelSection&quot;);\n\n            var actionTriple = new NonTerminal(&quot;ActionTriplet&quot;);\n            actionTriple.Rule = actionSetTriples | actionIncTriples | actionDecTriples | actionMulTriples;\n\n            var startSectionRow = new NonTerminal(&quot;StartSectionRow&quot;);\n            startSectionRow.Rule = actionTriple;\n            startSectionRow.Rule |= actionTriple + telemetryTriples; // combo of the above two\n            startSectionRow.Rule |= telemetryTriples;\n            startSectionRow.Rule |= ToTerm(&quot;run cancel&quot;);\n            startSection.Rule = MakeStarRule(startSection, NewLinePlus, startSectionRow); // apparently Irony automatically includes EOF as a valid terminal\n\n            var cancelSectionRow = new NonTerminal(&quot;CancelSectionRow&quot;);\n            cancelSectionRow.Rule = actionTriple;\n            var cancel = ToTerm(&quot;on cancel:&quot;);\n            cancelSection.Rule = cancel + NewLinePlus + MakeStarRule(cancelSection, NewLinePlus, cancelSectionRow);\n            \n            program.Rule = startSection + cancelSection.Q();\n\n            MarkPunctuation(&quot;[&quot;, &quot;]&quot;, &quot;until&quot;, &quot;at&quot;, &quot;by&quot;);\n            MarkTransient(actionTriple, telemetryTriples, actionSetTriples, actionDecTriples, actionMulTriples, actionIncTriples);\n            RegisterBracePair(&quot;[&quot;, &quot;]&quot;);\n            Root = program;\n        }\n</code></pre>\n\n",
    "PostedDate": "2013-04-12T10:46:42.753-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1029833",
    "ThreadId": "440119",
    "Html": "After looking at the GwBasic grammar, I decided to try the approach of adding a NewLine to my two sections and leaving that out of the star rule creation. That has given me much better results. I have this grammar (below) that successfully parses my data now. I would still like the ability to make the &quot;on cancel:&quot; be transient. It seems, though, that if I replace it with a non-terminal, I can't make that non-terminal transient; it always stays. I would like it to work like this: program.Rule = startSection + cancelSection;<br />\n<pre><code>        public ProcedureGrammar(IEnumerable&lt;TelemetryDefinitionModel&gt; telemetryDefinitions)\n        {\n            // in BNF:\n            // program := row*\n            // connector = at, +=, = \n            // row := &quot;set&quot; [actionName] connector actionValue actionUnit? &quot;until&quot; [telmetryName] operator telemetryValue telmetryUnit?\n\n            var program = new NonTerminal(&quot;Program&quot;);\n\n            var telemetryTriples = new NonTerminal(&quot;TelemetryTriples&quot;);\n            var actionSetTriples = new NonTerminal(&quot;ActionSetTriples&quot;);\n            var actionDecTriples = new NonTerminal(&quot;ActionDecTriples&quot;);\n            var actionIncTriples = new NonTerminal(&quot;ActionIncTriples&quot;);\n            var actionMulTriples = new NonTerminal(&quot;ActionMulTriples&quot;);\n\n            var actions = telemetryDefinitions.Where(td =&gt; !td.IsReadonly).ToList();\n            if (actions.Count &lt;= 0)\n                throw new ArgumentException(&quot;Expected at least one non-readonly telemetry item definition.&quot;, &quot;telemetryDefinitions&quot;);\n\n            telemetryTriples.Rule = CreateTerminal(telemetryDefinitions, &quot;until&quot;);\n            actionSetTriples.Rule = CreateTerminal(actions, &quot;set&quot;, &quot;at&quot;);\n            actionDecTriples.Rule = CreateTerminal(actions, &quot;dec&quot;, &quot;by&quot;);\n            actionIncTriples.Rule = CreateTerminal(actions, &quot;inc&quot;, &quot;by&quot;);\n            actionMulTriples.Rule = CreateTerminal(actions, &quot;mul&quot;, &quot;by&quot;);\n\n            var comment = new CommentTerminal(&quot;Comment&quot;, &quot;#&quot;, &quot;\\r&quot;, &quot;\\n&quot;, &quot;\\u2085&quot;, &quot;\\u2028&quot;, &quot;\\u2029&quot;);\n            NonGrammarTerminals.Add(comment);\n\n            var startSection = new NonTerminal(&quot;StartSection&quot;);\n            var cancelSection = new NonTerminal(&quot;CancelSection&quot;);\n\n            var actionTriple = new NonTerminal(&quot;ActionTriplet&quot;);\n            actionTriple.Rule = actionSetTriples | actionIncTriples | actionDecTriples | actionMulTriples;\n\n            var startSectionRow = new NonTerminal(&quot;StartSectionRow&quot;);\n            startSectionRow.Rule = NewLine;\n            startSectionRow.Rule |= actionTriple + NewLine;\n            startSectionRow.Rule |= actionTriple + telemetryTriples + NewLine;\n            startSectionRow.Rule |= telemetryTriples + NewLine;\n            startSectionRow.Rule |= ToTerm(&quot;run cancel&quot;) + NewLine;\n            startSection.Rule = MakeStarRule(startSection, startSectionRow); // apparently Irony automatically includes EOF as a valid terminal\n\n            var cancelSectionRow = new NonTerminal(&quot;CancelSectionRow&quot;);\n            cancelSectionRow.Rule = NewLine;\n            cancelSectionRow.Rule = actionTriple + NewLine;\n            cancelSection.Rule = MakeStarRule(cancelSection, cancelSectionRow);\n\n            var cancel = ToTerm(&quot;on cancel:&quot;) + NewLinePlus;\n            cancel.Precedence = 1;\n            MarkPunctuation(cancel);\n\n            program.Rule = startSection + ((cancel + cancelSection) | Empty);\n\n            MarkPunctuation(&quot;[&quot;, &quot;]&quot;, &quot;until&quot;, &quot;at&quot;, &quot;by&quot;);\n            MarkTransient(actionTriple, telemetryTriples, actionSetTriples, actionDecTriples, actionMulTriples, actionIncTriples);\n            RegisterBracePair(&quot;[&quot;, &quot;]&quot;);\n            LanguageFlags |= LanguageFlags.NewLineBeforeEOF;\n            Root = program;\n        }\n</code></pre>\n\n",
    "PostedDate": "2013-04-12T14:59:38.447-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1030014",
    "ThreadId": "440119",
    "Html": "Transient means not 'remove this from output' but 'Replace it with the single child node it has'. Like BinaryOp terminal might be transient, so binary expression contains the operation token (like &quot;+&quot;) directly in middle position, instead of having BinaryOp node with &quot;+&quot; token inside it.<br />\n",
    "PostedDate": "2013-04-13T09:14:10.873-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
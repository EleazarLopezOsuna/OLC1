[
  {
    "Id": "89282",
    "ThreadId": "26684",
    "Html": "\r\nIf you are a fan of Gold Parser Builder, and are possibly expanding your horizons into alternative methods of creating parsers, I have here a classic example to give you some perspective on what you're looking at here.  This is a complete parser implementation for  the Simple2.grm file translated into irony code.  Talk about simple!  (Note that below I have a sample visitor and console doodad for you to run it if you feel the need to test'er out.)   I apologize for the formatting I can't seem to make it stick right.<br /><br />using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Text;<br />using Irony.Compiler;<br /><br />// example grammar translation by dave dolan, the original is available from http://devincook.com<br /><br />// below in comments is the original Gold-Based Simple2 Grammar<br />/*\"Name\"    = 'Simple'<br />\"Author\"  = 'Devin Cook'<br />\"Version\" = '2.0' <br />\"About\"   = 'This is a very simple grammar designed for use in examples'<br /><br />\"Case Sensitive\" = False <br />\"Start Symbol\"   = &lt;Statements&gt;<br /><br />{String Ch 1} = {Printable} - <a href=\"http://www.codeplex.com/irony/Wiki/View.aspx?title=%27%27\">''</a><br />{String Ch 2} = {Printable} - <a href=\"http://www.codeplex.com/irony/Wiki/View.aspx?title=%22\">\"</a><br /><br />Id            = {Letter}{AlphaNumeric}*<br /><br /><br />StringLiteral = ''   {String Ch 1}* ''<br />              | '\"'  {String Ch 2}* '\"'<br /><br /><br />NumberLiteral = {Digit}<u>('.'{Digit}</u>)?<br /><br />&lt;Statements&gt; ::= &lt;Statement&gt; &lt;Statements&gt;<br />               | &lt;Statement&gt;<br /><br />&lt;Statement&gt;  ::= display &lt;Expression&gt;<br />               | display &lt;Expression&gt; read ID<br />               | assign ID '=' &lt;Expression&gt;<br />               | while &lt;Expression&gt; do &lt;Statements&gt; end<br />               | if &lt;Expression&gt; then &lt;Statements&gt; end<br />               | if &lt;Expression&gt; then &lt;Statements&gt; else &lt;Statements&gt; end<br /><br />&lt;Expression&gt;   ::= &lt;Expression&gt; '&gt;'  &lt;Add Exp&gt; <br />                 | &lt;Expression&gt; '&lt;'  &lt;Add Exp&gt; <br />                 | &lt;Expression&gt; '&lt;=' &lt;Add Exp&gt; <br />                 | &lt;Expression&gt; '&gt;=' &lt;Add Exp&gt;<br />                 | &lt;Expression&gt; '==' &lt;Add Exp&gt;<br />                 | &lt;Expression&gt; '&lt;&gt;' &lt;Add Exp&gt;<br />                 | &lt;Add Exp&gt; <br /><br />&lt;Add Exp&gt;      ::= &lt;Add Exp&gt; '+' &lt;Mult Exp&gt;<br />                 | &lt;Add Exp&gt; '-' &lt;Mult Exp&gt;<br />                 | &lt;Add Exp&gt; '&amp;' &lt;Mult Exp&gt;<br />                 | &lt;Mult Exp&gt; <br /><br />&lt;Mult Exp&gt;    ::= &lt;Mult Exp&gt; '*' &lt;Negate Exp&gt; <br />                | &lt;Mult Exp&gt; '/' &lt;Negate Exp&gt; <br />                | &lt;Negate Exp&gt; <br /><br />&lt;Negate Exp&gt;  ::= '-' &lt;Value&gt; <br />                | &lt;Value&gt; <br /><br />&lt;Value&gt;       ::= ID           <br />                | StringLiteral<br />                | NumberLiteral<br />                | '(' &lt;Expression&gt; ')'<br />*/<br /><br />namespace DolanIronyTest {<br />    class Simple2Grammar : Irony.Compiler.Grammar {<br /><br />        public Simple2Grammar() {<br /><br />            // Terminals<br />            Terminal NumberLit = new NumberLiteral(\"NUMBER-LITERAL\");<br /><br />            Terminal SingleQuotedString = new StringLiteral(\"SINGLE-QUOTED-STRING\",\"'\", ScanFlags.DisableEscapes);<br />            Terminal DoubleQuotedString = new StringLiteral(\"DOUBLE-QUOTES-STRING\", \"\\\"\", ScanFlags.DisableEscapes);<br /><br />            Terminal Variable = new IdentifierTerminal(\"VARIABLE\");<br /><br />            // Non-Terminals<br />            NonTerminal StringLit = new NonTerminal(\"STRING-LITERAL\");<br />            NonTerminal StatementList = new NonTerminal(\"STATEMENT-LIST\");<br />            NonTerminal Statement = new NonTerminal(\"STATEMENT\");<br />            NonTerminal DisplayStatement = new NonTerminal(\"DISPLAY-STMT\");<br />            NonTerminal InputDisplayStatement = new NonTerminal(\"INPUT-DISPLAY-STMT\");<br />            NonTerminal AssignmentStatement = new NonTerminal(\"ASSIGNMENT-STMT\");<br />            NonTerminal IfThenStatement = new NonTerminal(\"IF-THEN-STMT\");<br />            NonTerminal IfThenElseStatement = new NonTerminal(\"IF-THEN-ELSE-STMT\");<br />            NonTerminal WhileStatement = new NonTerminal(\"WHILE-STMT\");<br />            NonTerminal Expression = new NonTerminal(\"EXPRESSION\");<br />            NonTerminal BinaryOperator = new NonTerminal(\"BINARY-OPERATOR\");<br />            NonTerminal UnaryOperator = new NonTerminal(\"UNARY-OPERATOR\");<br /><br />            // start rule, and case sensitivity<br />            this.Root = StatementList;<br />            this.CaseSensitive = false;<br /><br /><br />            // I think there is a better way to do this, but this works for now<br />            StringLit.Rule = SingleQuotedString | DoubleQuotedString;<br /><br />            Expression.Rule = NumberLit<br />                              | StringLit<br />                              | Variable<br />                              | Expression + BinaryOperator + Expression<br />                              | UnaryOperator + Expression<br />                              | \"(\" + Expression + \")\";<br /><br />            BinaryOperator.Rule = Symbol(\"+\")<br />                                  | \"-\"<br />                                  | \"&amp;\"<br />                                  | \"*\"<br />                                  | \"/\"<br />                                  | \"&gt;\"<br />                                  | \"&lt;\"<br />                                  | \"&gt;=\"<br />                                  | \"&lt;=\"<br />                                  | \"==\"<br />                                  | \"&lt;&gt;\";<br /><br />            UnaryOperator.Rule = \"-\";<br />            // this sure as heck beats gold for implementing right recursion.<br />            StatementList.Rule = MakePlusRule(StatementList, null, Statement);<br /><br />            // statements can be any of the possible statements, easy enough<br />            Statement.Rule = DisplayStatement<br />                             | InputDisplayStatement<br />                             | AssignmentStatement<br />                             | WhileStatement<br />                             | IfThenStatement<br />                             | IfThenElseStatement;<br /><br />            // just testing to see that it works as Symbol(\"display\") and/or the lonely string<br />            DisplayStatement.Rule = Symbol(\"display\") + Expression;<br /><br />            InputDisplayStatement.Rule = \"display\" + Expression + \"read\" + Variable;<br /><br />            AssignmentStatement.Rule = \"assign\" + Variable + \"=\" + Expression;<br /><br />            WhileStatement.Rule = \"while\" + Expression + \"do\" + StatementList + \"end\";<br /><br />            IfThenStatement.Rule = \"if\" + Expression + \"then\" + StatementList + \"end\";<br /><br />            IfThenElseStatement.Rule = \"if\" + Expression + \"then\" + StatementList + \"else\" + StatementList + \"end\";<br /><br />            // operator precedence<br />            RegisterOperators(1, \"&gt;\", \"&lt;\", \"&lt;=\", \"&gt;=\", \"==\", \"&lt;&gt;\");<br />            RegisterOperators(2, \"+\", \"-\", \"&amp;\");<br />            RegisterOperators(3, \"*\", \"/\");<br /><br />            // trim the tree when it comes to parentheses<br />            RegisterPunctuation(\"(\", \")\");<br /><br /><br />        }<br /><br />    }<br />}<br /><br /><br />Here's a sample 'printing visitor' for traversing the tree to prove that I've done it correctly.<br /><br />using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Text;<br />using Irony.Compiler;<br /><br />namespace DolanIronyTest {<br />    class PrintVisitor : Irony.Compiler.IAstVisitor{<br />        #region IAstVisitor Members<br /><br />        int IndentLevel = 0;<br /><br />        void Indent() {<br />            IndentLevel++;<br /><br />        }<br /><br />        void UnDent() {<br />            IndentLevel--;<br /><br />        }<br /><br />        int _NodeCount = 0;<br />        public int NodeCount {<br />            get {<br />                return _NodeCount;<br />            }<br />        }<br /><br />        public void BeginVisit(Irony.Compiler.AstNode node) {<br /><br />            for (int x = 0; x &lt; IndentLevel; x++) {<br />                Console.Out.Write(\"--\");<br />            }<br /><br />            Console.Out.WriteLine(node.ToString());<br /><br />            Indent();<br /><br />            if (node.ChildNodes != null) {<br />                foreach (AstNode kid in node.ChildNodes) {<br />                    BeginVisit(kid);<br />                }<br />            }<br /><br />            EndVisit(node);<br />        }<br /><br />        public void EndVisit(Irony.Compiler.AstNode node) {<br />            _NodeCount++;<br />            UnDent();<br />        }<br /><br />        #endregion<br />    }<br />}<br /><br />And of course the harness to run it by to gain that all important instant gratification.<br /><br />using System;<br />using System.Collections.Generic;<br />using System.Text;<br />using Irony.Compiler;<br /><br />namespace DolanIronyTest {<br />    class Program {<br />        static void Main(string[] args) {<br /><br />            Simple2Grammar grammar = new Simple2Grammar();<br />            LanguageCompiler compiler = new LanguageCompiler(grammar);<br /><br />            string prog = \"display 'give me a number for a&gt;' read a\\n\" +<br />                          \"display 'give me a number for b&gt;' read b\\n\" +<br />                          \"display 'a + b = '\" +<br />                          \"display (a + b)\";<br /><br />            AstNode rootNode = compiler.Parse(prog);<br /><br />            PrintVisitor visitor = new PrintVisitor();<br /><br />            visitor.BeginVisit(rootNode);<br /><br />            Console.Out.WriteLine(\"\\nTotal Nodes Touched: {0}\", visitor.NodeCount);<br /><br />            Console.ReadKey();<br /><br />        }<br />    }<br />}<br /><br />Just in case you don't want to build and run it, here's the output of the test harness:<br /><br />STATEMENT-LIST<br />--INPUT-DISPLAY-STMT<br />----display [VARIABLE]<br />----give me a number for a&gt; [SINGLE-QUOTED-STRING]<br />----read [VARIABLE]<br />----a [VARIABLE]<br />--INPUT-DISPLAY-STMT<br />----display [VARIABLE]<br />----give me a number for b&gt; [SINGLE-QUOTED-STRING]<br />----read [VARIABLE]<br />----b [VARIABLE]<br />--DISPLAY_STMT<br />----display [VARIABLE]<br />----a + b =  [SINGLE-QUOTED-STRING]<br />--DISPLAY_STMT<br />----display [VARIABLE]<br />----EXPRESSION<br />------a [VARIABLE]<br />------+ [Symbol]<br />------b [VARIABLE]<br /><br />Total Nodes Touched: 20<br /><br /><br />Notice how the parentheses in the \"display (a + b)\" statement don't show up in the tree. I'll assume that's because I've registered them as punctuation. Neat!<br />",
    "PostedDate": "2008-04-27T20:31:34.117-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "89467",
    "ThreadId": "26684",
    "Html": "\r\nThanks for an interesting post!<br />To complete the comparison, here is an article describing implementation of the same grammar in Gold parser:<br /><a href=\"http://www.codeproject.com/KB/recipes/IntrotoGoldParser.aspx\" class=\"externalLink\">http://www.codeproject.com/KB/recipes/IntrotoGoldParser.aspx<span class=\"externalLinkIcon\" style=\"font-family:Consolas, Courier New, Courier, Monospace;\"></span></a><br />I should note that article's code provides an implementation of a simple interpreter on top of Gold-generated parser. <br />The support for interpreter in Irony is coming - very soon!<br />Roman<br />",
    "PostedDate": "2008-04-28T15:16:53.643-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "89500",
    "ThreadId": "26684",
    "Html": "\r\nI'm anxious to see it of course, but I will point out that you're no further behind than gold is in this respect. The interpreters/post processors are not included in gold either. That example you're citing just has another dedicated citizen behind it showing how it's all tied together.  <br /><br />Getting from trees of productions in full recursive decent style (raw parse trees) to abstract syntax trees in a gold generated parser, even with a code template like the ones I've written, still isn't easy.  In fact, I'd say the unwillingness of the population to make assumptions about similarities in certain language constructs between languages is the only reason that such a tool hasn't been built to date.  <br /><br />I had a go with a friend of mine, kelly parker, at a rough draft of an AST/interpreter tree generator, but we kludged a lot, and never got it to the point where it could be released.  We actually used tricks like terminal naming conventions and defining key non-terminals/terminals in a config file before generation that 'helped' the AST be generated.  It did work, but it was quite contrived when it did, and frankly it's all spaghetti.  Kelly and I worked on separate examples at first, and well I was done last, so I mixed some of my code over top of kelly's.  <br /><br />The one thing about gold that made such a tool sort of feasible was that it generates a nice abstracted DFA table set. All we had to do to enumerate the terminals and whatnot was load it up with a binary reader, and dive through it, creating class templates (with code dom) from each of the non-terminals.  Then the children were generated as member fields.  The one concept that's hard to embody in such a tool though, and we just sort of winged it, was the inheritance.  Clearly you have inheritance when you're talking about variations on the similar kind of non-terminals when each can have multiple rules, each derives from the abstract Left-hand-side of the rule.  It might actually be easier to do something like this with Irony because of the way that expressions can be flattened instead of creating precedence based polymorphic hierarchies.  The rest though would be pretty much the same in concept I believe.  <br /><br />I'm rambling, now... so I'll stop.<br />",
    "PostedDate": "2008-04-28T19:22:42.2-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
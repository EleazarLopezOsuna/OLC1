[
  {
    "Id": "279462",
    "ThreadId": "81432",
    "Html": "<p>Hello!</p>\r\n<p>My task is to create Grammar for F# (functional programming language)&nbsp;using Irony.</p>\r\n<p>Is there any sample open source&nbsp;projects been already developed?So I could expand it.</p>\r\n<p>Thanks&nbsp;&nbsp;&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-20T06:18:17.45-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "279582",
    "ThreadId": "81432",
    "Html": "<p>No, there's no F# sample, and I never heard about anybody doing it. F# is indentation sensitive, as far as I remember, so your best approach would be to start with miniPython sample - it employs indentation stuff. Let me know if you need any help</p>",
    "PostedDate": "2010-01-20T09:46:01.207-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "287685",
    "ThreadId": "81432",
    "Html": "<p>Thanks for your advice,it was helpfull. I've developed F# grammar that supports all the constructions I need.</p>\r\n<p>The trouble is in error recovering : I need to be able to continue parsing input even if there is language expression&nbsp;that is unsupported by my grammar. Maybe&nbsp;this trouble can be resolved using &nbsp;ErrorRule,but I do not understand how to use it correctly.</p>\r\n<p>If I use Stmt.ErrorRule = SyntaxError + Eos;ExtStmt.ErrorRule = SyntaxError +Eos;//it does not work</p>\r\n<p>Here is my grammar.I appreciate&nbsp;any your advice.</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>BNF rules\r\n            <span style=\"color:Green\">//Basis</span>\r\n            Open.Rule = Empty | <span style=\"color:#A31515\">&quot;open&quot;</span> + identifier + qual_name_segments_opt + Eos;\r\n            <span style=\"color:Green\">//qualified_identifier.Rule = MakePlusRule(qualified_identifier, dot, identifier);</span>\r\n            qual_name_segments_opt.Rule = MakeStarRule(qual_name_segments_opt, <span style=\"color:Blue\">null</span>, qual_name_segment);\r\n            qual_name_segment.Rule = dot + identifier;\r\n            Expr.Rule = Term | UnExpr | BinExpr;\r\n            expr_opt.Rule = Empty | Expr;\r\n            Term.Rule = Literal | ParExpr | identifier | FunctionCall | identifier + qual_name_segments_opt;\r\n            Literal.Rule = number | StringLiteral | <span style=\"color:#A31515\">&quot;true&quot;</span> | <span style=\"color:#A31515\">&quot;false&quot;</span> | <span style=\"color:#A31515\">&quot;null&quot;</span>;\r\n            ParExpr.Rule = <span style=\"color:#A31515\">&quot;(&quot;</span> + expr_opt + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n            UnExpr.Rule = UnOp + Term;\r\n            UnOp.Rule = ToTerm(<span style=\"color:#A31515\">&quot;+&quot;</span>) | <span style=\"color:#A31515\">&quot;-&quot;</span>;\r\n            BinExpr.Rule = Expr + BinOp + Expr\r\n                           | Expr + CmpOp + Expr;\r\n            BinOp.Rule = ToTerm(<span style=\"color:#A31515\">&quot;+&quot;</span>) | <span style=\"color:#A31515\">&quot;-&quot;</span> | <span style=\"color:#A31515\">&quot;*&quot;</span> | <span style=\"color:#A31515\">&quot;/&quot;</span> | <span style=\"color:#A31515\">&quot;**&quot;</span>;\r\n            CmpOp.Rule = ToTerm(<span style=\"color:#A31515\">&quot;&gt;&quot;</span>) | <span style=\"color:#A31515\">&quot;&lt;&quot;</span> | <span style=\"color:#A31515\">&quot;&gt;=&quot;</span> | <span style=\"color:#A31515\">&quot;&lt;=&quot;</span> | <span style=\"color:#A31515\">&quot;&lt;&gt;&quot;</span> | <span style=\"color:#A31515\">&quot;=&quot;</span> | <span style=\"color:#A31515\">&quot;compare&quot;</span>;\r\n            CondExpr.Rule = <span style=\"color:#A31515\">&quot;if&quot;</span> + Expr + <span style=\"color:#A31515\">&quot;then&quot;</span> + Eos + Block\r\n                            |<span style=\"color:#A31515\">&quot;if&quot;</span> + Expr + <span style=\"color:#A31515\">&quot;then&quot;</span> + Eos + Block + <span style=\"color:#A31515\">&quot;else&quot;</span> + Eos + Block;\r\n            AssignmentStmt.Rule = <span style=\"color:#A31515\">&quot;let&quot;</span> + identifier + <span style=\"color:#A31515\">&quot;=&quot;</span> + Expr;\r\n            AssignmentStmt.ErrorRule = SyntaxError + Eos;\r\n            Stmt.Rule =  AssignmentStmt | Expr;\r\n            ExtStmt.Rule = Stmt + Eos | FunctionDef | module_declarations_opt | type_declarations_opt | CondExpr;\r\n            Block.Rule = Indent + StmtList + Dedent;\r\n            Block.ErrorRule = SyntaxError + Eos;\r\n\r\n            block_opt.Rule = Empty | Eos | Block;\r\n            StmtList.Rule = MakePlusRule(StmtList, ExtStmt);\r\n            ParamWithType.Rule = identifier + <span style=\"color:#A31515\">&quot;:&quot;</span> + identifier;\r\n            ParamList.Rule = MakeStarRule(ParamList, comma, identifier) | <span style=\"color:#A31515\">&quot;(&quot;</span> + MakeStarRule(ParamList,comma,ParamWithType) + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n            ArgList.Rule = MakeStarRule(ArgList, comma, Expr);\r\n            FunctionDef.Rule = attributes_opt + <span style=\"color:#A31515\">&quot;let&quot;</span> + identifier + ParamList + <span style=\"color:#A31515\">&quot;=&quot;</span> + expr_opt + Eos + block_opt;\r\n            FunctionCall.Rule = identifier + ArgList;\r\n            \r\n            <span style=\"color:Green\">//Namespaces,modules,types</span>\r\n            \r\n            open_directives_opt.Rule = MakePlusRule(open_directives_opt, Open);\r\n            namespace_declaration.Rule = <span style=\"color:#A31515\">&quot;namespace&quot;</span> + identifier + qual_name_segments_opt + Eos + namespace_body;\r\n            namespace_body.Rule = Indent + open_directives_opt + module_declarations_opt + Dedent;\r\n            module_declarations_opt.Rule = Empty | <span style=\"color:#A31515\">&quot;module&quot;</span> + identifier + <span style=\"color:#A31515\">&quot;=&quot;</span> + Eos + module_body;\r\n            module_body.Rule = Block;<span style=\"color:Green\">//not implemented yet</span>\r\n            type_declarations_opt.Rule = Empty | <span style=\"color:#A31515\">&quot;type&quot;</span>  + identifier + <span style=\"color:#A31515\">&quot;=&quot;</span> + Eos + type_body;\r\n            type_body.Rule = Block;<span style=\"color:Green\">//not implemented yet </span>\r\n\r\n            <span style=\"color:Green\">//Attributes</span>\r\n\r\n            attributes_opt.Rule = MakeStarRule(attributes_opt, <span style=\"color:Blue\">null</span>, attribute_section);\r\n            attribute_section.Rule = <span style=\"color:#A31515\">&quot;[&quot;</span> +<span style=\"color:#A31515\">&quot;&lt;&quot;</span> + attribute_list  + <span style=\"color:#A31515\">&quot;&gt;&quot;</span> + <span style=\"color:#A31515\">&quot;]&quot;</span> + Eos;\r\n            attribute_list.Rule = MakePlusRule(attribute_list, semicolon, attribute);\r\n            attribute.Rule = identifier + attribute_arguments_par_opt;\r\n            attribute_arguments_par_opt.Rule = Empty | <span style=\"color:#A31515\">&quot;(&quot;</span> + attribute_arguments_opt + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n            attribute_arguments_opt.Rule = MakeStarRule(attribute_arguments_opt, comma, attr_arg);\r\n            attr_arg.Rule = Expr;\r\n            \r\n            <span style=\"color:Blue\">this</span>.Root = namespace_declaration;       <span style=\"color:Green\">// Set grammar root</span>\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-02-09T07:47:26.653-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "288343",
    "ThreadId": "81432",
    "Html": "<p>Hi</p>\r\n<p>First of all, before you try to add error recovery, you should make sure your grammar is OK and parses&nbsp;correctly some sample programs. So let's focus on correctness of the grammar. You listed only a grammar constructor code, but there are some other important pieces that should be there. Your grammar is indent-sensitive, like Python, you use Eos symbol in grammar just like Python grammar. It means that you need to add &quot;CodeOutlineFilter&quot; to scanner processing chain - are you doing this? Anyway, please post the entire source code for the grammar class. Or email me directly the zip with your project (contact me directly through codeplex, I will reply and you'll send me the zip).</p>\r\n<p>Now to your current grammar -&nbsp; I see some problems.</p>\r\n<p>1. ParamList definition</p>\r\n<p>&nbsp;&nbsp; ParamList.Rule = MakeStarRule(ParamList, comma, identifier) | <span style=\"color:#a31515\">&quot;(&quot;</span> + MakeStarRule(ParamList,comma,ParamWithType) + <span style=\"color:#a31515\">&quot;)&quot;</span>;</p>\r\n<p>- this is a wrong way to use MakeStarRule, don't &quot;OR&quot; it this way. It should always be a single MakeStarRule on the right.</p>\r\n<p>2. BlockRule:</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Block.Rule = Indent + StmtList + Dedent;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Block.ErrorRule = SyntaxError + Eos;<br>&nbsp; this is incorrect - ErrorRule should always end with the same symbol as the main &quot;Rule&quot;. What you tell parser is that &quot;in case of error, skip everything until this symbol&quot; - where this symbol is the last terminal in regular Rule. So it should be &quot;Block.ErrorRule = SyntaxError + Dedent;&quot;</p>\r\n<p>The same goes for AssignmentStmt. For now, remove all ErrorRule assignments, let's focus on building correct grammar, and then moving to error recovery</p>\r\n<p>3. qual_name_segments_opt.Rule definition.</p>\r\n<p>&nbsp; You define name segment as &quot;dot + identifier&quot;, and then build a star-list with null delimiter. It is better to simply build it as a star-list of identifiers with dot as list delimiter (second parameter to MakeStarRule function).</p>\r\n<p>4. Minor things - I think you can simplify things a bit. Why you separate &quot;BinOp&quot; and &quot;CmpOp&quot;, and define BinExpr as &quot;OR&quot; of two types? would be simpler to include CmpOp symbols into BinOp - they are all binary operators. CondExpr - should be simplified, define else_clause_opt expression and use it in a single &quot;+&quot; expression.</p>\r\n<p>Let's clear it up</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-02-10T09:55:23.83-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "414292",
    "ThreadId": "203844",
    "Html": "<p>Hello all,</p>\r\n<p>&nbsp;&nbsp;I'm investigating Irony for a simple templating language I'm developing. &nbsp;This template language can have script embedded within it. &nbsp;I don't want to parse the script, I only want to extract it from my template and hand it off to another parser (this is a 3rd party script and parser). &nbsp;My syntax is going to look something like this:</p>\r\n<p>&nbsp;</p>\r\n<p>-script {</p>\r\n<p>&nbsp;&nbsp;other script language goes in here.</p>\r\n<p>}</p>\r\n<p>&nbsp;</p>\r\n<p>I'd like to return everything within the curly braces as a string literal so that I can just pass it off to the other parser. &nbsp;The catch, though, is that the other script language uses curly braces itself, so my string literal has to be smart enough to match all embedded curly braces before allowing the final curly brace to close the string literal. &nbsp;Here is an example:</p>\r\n<p>&nbsp;</p>\r\n<p>-script { otherScriptMethodDeclaration(params) {</p>\r\n<p>&nbsp;&nbsp;if(something) {</p>\r\n<p>&nbsp;&nbsp; &nbsp;...</p>\r\n<p>&nbsp;&nbsp;}</p>\r\n<p>}}</p>\r\n<p>&nbsp;</p>\r\n<p>How would I do this in Irony? &nbsp;Write a custom StringLiteral? &nbsp;Any tips on doing that?</p>\r\n<p>Thanks!</p>",
    "PostedDate": "2010-03-04T11:57:10.403-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "414683",
    "ThreadId": "203844",
    "Html": "<p>Yeah, looks like you need a custom string literal, allowing nested start/end symbols. This is in fact common case, some languages (Lua as far as I remember) have nested comments and string literals with nested start/end symbols, so implementing this facility is on my to-do list. For now, you'll have to do it yourself</p>\r\n<p>Roman</p>",
    "PostedDate": "2010-03-05T09:52:09.17-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "414737",
    "ThreadId": "203844",
    "Html": "<p>OK, I hacked around and got something working, but I should warn you that I did not spend much time learning Irony's architecture, so this may be really botched up. :)</p>\r\n<p>Here is the &quot;EmbeddedScriptLiteral&quot; I created:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>  <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> EmbeddedScriptLiteral : Terminal\r\n  {\r\n    <span style=\"color:Blue\">public</span> Terminal[] QuoteAndCommentTerminals { <span style=\"color:Blue\">get</span>; <span style=\"color:Blue\">set</span>; }\r\n\r\n    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">string</span> StartSymbol { <span style=\"color:Blue\">get</span>; <span style=\"color:Blue\">set</span>; }\r\n    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">string</span> EndSymbol { <span style=\"color:Blue\">get</span>; <span style=\"color:Blue\">set</span>; }\r\n\r\n    <span style=\"color:Blue\">public</span> EmbeddedScriptLiteral(<span style=\"color:Blue\">string</span> name, <span style=\"color:Blue\">string</span> startSymbol, <span style=\"color:Blue\">string</span> endSymbol,\r\n<span style=\"color:Blue\">                                 </span><span style=\"color:Blue\">params</span> Terminal[] quoteAndCommentTerminals)\r\n      : <span style=\"color:Blue\">base</span>(name)\r\n    {\r\n      QuoteAndCommentTerminals = quoteAndCommentTerminals;\r\n      StartSymbol = startSymbol;\r\n      EndSymbol = endSymbol;\r\n    }\r\n\r\n    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> IList&lt;<span style=\"color:Blue\">string</span>&gt; GetFirsts()\r\n    {\r\n      <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">new</span> StringList(StartSymbol);\r\n    }\r\n\r\n    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">override</span> Token TryMatch(ParsingContext context, ISourceStream source)\r\n    {\r\n      <span style=\"color:Blue\">if</span>(context.VsLineScanState.Value != 0)\r\n      {\r\n        context.VsLineScanState.Value = 0;\r\n      }\r\n      <span style=\"color:Blue\">else</span>\r\n      {\r\n        <span style=\"color:Blue\">if</span>(!BeginMatch(context, source)) <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">null</span>;\r\n      }\r\n\r\n      Token result = CompleteMatch(context, source);\r\n      <span style=\"color:Blue\">if</span>(result != <span style=\"color:Blue\">null</span>)\r\n      {\r\n        <span style=\"color:Blue\">return</span> result;\r\n      }\r\n      <span style=\"color:Blue\">return</span> source.CreateErrorToken(<span style=\"color:#A31515\">&quot;Unclosed Script Block&quot;</span>);\r\n    }\r\n\r\n    <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">virtual</span> <span style=\"color:Blue\">bool</span> BeginMatch(ParsingContext context, ISourceStream source)\r\n    {\r\n      <span style=\"color:Blue\">if</span>(!source.MatchSymbol(StartSymbol, !Grammar.CaseSensitive))\r\n      {\r\n        <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">false</span>;\r\n      }\r\n      source.PreviewPosition += StartSymbol.Length;\r\n      <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">true</span>;\r\n    }\r\n\r\n    <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">virtual</span> <span style=\"color:Blue\">bool</span> EndMatch(ParsingContext context, ISourceStream source)\r\n    {\r\n      <span style=\"color:Blue\">if</span>(!source.MatchSymbol(EndSymbol, !Grammar.CaseSensitive))\r\n      {\r\n        <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">false</span>;\r\n      }\r\n      source.PreviewPosition += EndSymbol.Length;\r\n      <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">true</span>;\r\n    }\r\n\r\n    <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">virtual</span> Token CompleteMatch(ParsingContext context, ISourceStream source)\r\n    {\r\n      <span style=\"color:Blue\">int</span> startingPosition = source.PreviewPosition;\r\n      SourceLocation initialLocation = source.Location;\r\n      <span style=\"color:Green\">// The whole point here is to match Start and End Symbols... so, for each</span>\r\n      <span style=\"color:Green\">// StartSymbol, there has to be a corresponding EndSymbol.  We start at 1</span>\r\n      <span style=\"color:Green\">// because we've already matched the first StartSymbol.</span>\r\n      <span style=\"color:Blue\">int</span> braceLevel = 1;\r\n\r\n      <span style=\"color:Blue\">while</span>(!source.EOF() &amp;&amp; braceLevel &gt; 0)\r\n      {\r\n        <span style=\"color:Blue\">if</span>(SkipQuoteOrComment(context, source))\r\n        {\r\n          <span style=\"color:Blue\">continue</span>;\r\n        }\r\n\r\n        <span style=\"color:Blue\">if</span>(BeginMatch(context, source))\r\n        {\r\n          braceLevel++;\r\n        }\r\n        <span style=\"color:Blue\">else</span> <span style=\"color:Blue\">if</span>(EndMatch(context, source))\r\n        {\r\n          braceLevel--;\r\n        }\r\n        <span style=\"color:Blue\">else</span>\r\n        {\r\n          source.PreviewPosition++;\r\n        }\r\n      }\r\n\r\n      <span style=\"color:Blue\">var</span> previewPosition = source.PreviewPosition;\r\n\r\n      <span style=\"color:Green\">// Grab all text between opening and closing symbols.</span>\r\n      <span style=\"color:Blue\">var</span> endPos = source.PreviewPosition - EndSymbol.Length;\r\n      <span style=\"color:Blue\">if</span>(endPos &gt; source.Text.Length) endPos = source.Text.Length;\r\n\r\n      source.Location = initialLocation;\r\n      source.PreviewPosition = previewPosition;\r\n\r\n      <span style=\"color:Blue\">var</span> ret = source.CreateToken(OutputTerminal, source.Text.Substring(startingPosition, endPos - startingPosition));\r\n      source.PreviewPosition = previewPosition;\r\n      <span style=\"color:Blue\">return</span> ret;\r\n    }\r\n\r\n\r\n    <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">virtual</span> <span style=\"color:Blue\">bool</span> SkipQuoteOrComment(ParsingContext context, ISourceStream source)\r\n    {\r\n      source.Location = <span style=\"color:Blue\">new</span> SourceLocation(source.PreviewPosition, source.Location.Line, source.Location.Column);\r\n      <span style=\"color:Blue\">foreach</span> (<span style=\"color:Blue\">var</span> quoteOrCommentTerminal <span style=\"color:Blue\">in</span> QuoteAndCommentTerminals)\r\n      {\r\n        <span style=\"color:Blue\">var</span> token = quoteOrCommentTerminal.TryMatch(context, source);\r\n        <span style=\"color:Blue\">if</span>(token != <span style=\"color:Blue\">null</span>)\r\n          <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">true</span>;\r\n      }\r\n\r\n      <span style=\"color:Blue\">return</span> <span style=\"color:Blue\">false</span>;\r\n    }\r\n  }\r\n\r\n</pre>\r\n</div>\r\n<p>I set it up like this (note, I'm pretending C# is the embeddable &quot;script&quot; language):</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>...\r\n      <span style=\"color:Green\">// C# Script Blocks</span>\r\n      <span style=\"color:Blue\">var</span> CSharpScriptLiteral = <span style=\"color:Blue\">new</span> EmbeddedScriptLiteral(<span style=\"color:#A31515\">&quot;CSharpScriptLiteral&quot;</span>, <span style=\"color:#A31515\">&quot;{&quot;</span>, <span style=\"color:#A31515\">&quot;}&quot;</span>,\r\n                                                        CSStringLiteral, CSCharLiteral, CSSingleLineComment,\r\n                                                        CSDelimitedComment);\r\n\r\n...</pre>\r\n</div>\r\n<p>In my custom language you surround a script block with &quot;{&quot; and &quot;}&quot;, and this EmbeddedScriptLiteral will pull all text until the final closing brace. &nbsp;While it doesn't parse the script in the block, per se, it does do brace matching while also ignoring braces found in strings and comments so that it knows where the block ends. &nbsp;Beyond that, it returns all enclosed text without any processing at all (escape sequences are kept intact so that the target scripting engine can handle them).</p>\r\n<p>It seems to be working in my limited test cases. &nbsp;Let me know if this looks totally wrong to you. :)</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-03-05T12:43:12.89-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "416509",
    "ThreadId": "203844",
    "Html": "<p>Looks ok to me, as long as it works properly. The only problem I see is efficiency - when scan the content of the terminal, you try EVERY quoteOrComment terminal for EVERY position inside. It is better to apply some optimization - get all prefixes of quote/comment terminals, and search for first letters of prefixes, using Text.IndexOfAny(char[])</p>",
    "PostedDate": "2010-03-10T11:36:05.127-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "416658",
    "ThreadId": "203844",
    "Html": "<p>I had the same thought... my goal with the above code is simply a proof of concept, which seems to be working. &nbsp;If it becomes a performance issue for us, that will be the first optimization we try. :) &nbsp;Thanks for your comments!</p>",
    "PostedDate": "2010-03-10T16:02:06.68-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
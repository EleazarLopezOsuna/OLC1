[
  {
    "Id": "644702",
    "ThreadId": "265806",
    "Html": "\r\n<p>Roman,</p>\r\n<p>I have had a look at your item P21.&nbsp; I have got some code working and I have tested it against the ExpressionEvaluator Grammar.</p>\r\n<p>While we all know that Reflection is expensive, it doesnt appear to be a hugely expensive part of the parse time.&nbsp; On initial (unscientific) tests of roughly 100,000 tokens, I get a parse time of 78ms on&nbsp;both Reflection and 78ms my method. &nbsp;My\r\n method usually runs at least 10x faster than reflection, including the dictionary&nbsp;lookup.&nbsp; That is real results that I see elsewhere on other projects.&nbsp;</p>\r\n<p>It is not quite as fast as a pure compiled method, &nbsp;but then this requires minimal code change and&nbsp;sticks with the simple requirement of just an&nbsp;AST node&nbsp;type with a parameterless constructor so should be compatible with all existing\r\n grammars.&nbsp;</p>\r\n<p>The basis of my code change:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>      <span style=\"color:green\">//nodeInfo.AstNode =  Activator.CreateInstance(nodeType);</span>\r\n\r\n      <span style=\"color:blue\">if</span> (ASTNodeConstructorList.ContainsKey(nodeType))\r\n      {\r\n          ASTNodeConstructor = ASTNodeConstructorList[nodeType];\r\n      }\r\n      <span style=\"color:blue\">else</span>\r\n      {\r\n          ConstructorInfo target = nodeType.GetConstructor(Type.EmptyTypes);\r\n          DynamicMethod ASTNodeMethod = <span style=\"color:blue\">new</span> DynamicMethod(<span style=\"color:#a31515\">&quot;New&quot;</span>, nodeType, <span style=\"color:blue\">null</span>);\r\n          ILGenerator il = ASTNodeMethod.GetILGenerator();\r\n          il.Emit(OpCodes.Newobj, target);\r\n          il.Emit(OpCodes.Ret);\r\n          ASTNodeConstructor = (NewASTNode)ASTNodeMethod.CreateDelegate(<span style=\"color:blue\">typeof</span>(NewASTNode));\r\n          ASTNodeConstructorList.Add(nodeType, ASTNodeConstructor);\r\n      }\r\n      nodeInfo.AstNode = ASTNodeConstructor.Invoke();\r\n\r\n</pre>\r\n</div>\r\n<p>So either I have missed something or there is a lot of overhead somewhere else?</p>\r\n<p>What would you like to do? Any suggestions?&nbsp; Would you really want to include this and have the additional complexity or stick with the simpler Activator command for the moment?</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2011-07-19T16:44:28.993-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "644711",
    "ThreadId": "265806",
    "Html": "<p>There's one suspicious place: the call to Invoke method in the last line. Invoke is inherited from MethodBase and is in fact using reflection to make a call.&nbsp;</p>\r\n<p>I think you should call directly:</p>\r\n<p>AstNodeConstructor();&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>see code example here:</p>\r\n<p><a href=\"http://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod.aspx\">http://msdn.microsoft.com/en-us/library/system.reflection.emit.dynamicmethod.aspx</a></p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-07-19T17:06:26.593-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "644876",
    "ThreadId": "265806",
    "Html": "<p>Interesting spot.&nbsp; Thank you.&nbsp; I have used the Invoke command consistently on my other projects. So if I am using reflection, it can be nowhere near the same performance hit as Activator.&nbsp; What I find interesting is that the code example on your link also uses Invoke, and I cannot see any examples of a direct call.&nbsp; But then again, it is a very difficult example to follow because of all the writes to console.&nbsp; In previous tests I witnessed a very slight deterioration in performance&nbsp;(10%)&nbsp;over calling \"new\" directly, which I had always put down to using a delegate.</p>\r\n<p>I have made the change you suggest and it has made no detectable difference.&nbsp; I still run at 78ms.&nbsp; I will produce a slightly more scientific test later to directly test the difference between Activator, dynamic method with Invoke and dynamic method called directly.</p>",
    "PostedDate": "2011-07-20T03:09:06.35-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "645006",
    "ThreadId": "265806",
    "Html": "<p>Hi</p>\r\n<p>About the MSDN sample - search for the following lines:</p>\r\n<pre>HelloDelegate hi = \r\n            (HelloDelegate) hello.CreateDelegate(<span>typeof</span>(HelloDelegate));\r\n\r\n        <span>// Use the delegate to execute the dynamic method.</span>\r\n        Console.WriteLine(<span>\"\\r\\nUse the delegate to execute the dynamic method:\"</span>);\r\n        <span>int</span> retval = hi(<span>\"\\r\\nHello, World!\"</span>, 42);</pre>\r\n<pre><br /></pre>\r\n<p>And right after that, there's use of invoke and a comment:&nbsp;</p>\r\n<pre><span>// Invoke the dynamic method using the arguments. This is much</span>\r\n        <span>// slower than using the delegate, because you must create an</span>\r\n        <span>// array to contain the arguments, and value-type arguments</span>\r\n        <span>// must be boxed.</span>\r\n        <span>object</span> objRet = hello.Invoke(<span>null</span>, BindingFlags.ExactBinding, <span>null</span>, invokeArgs, <span>new</span> CultureInfo(<span>\"en-us\"</span>));</pre>\r\n<p>&nbsp;</p>\r\n<p>So it should be faster to invoke directly, even if marginally. Also, I think even with Invoke it should be faster than using Activator.</p>\r\n<p>About not seeing perf improvements. Note that in your version you lookup the delegate in the dictionary - this is substantial effort. Additionally the dictionary lookup is not efficient. First, use of \"if dict.Contains(key) then v=dict[key]\" pattern requires 2 dictionary lookups - better use TryGetValue which requires a single lookup. Secondly, using AstNode as a key in a dictionary - this requires looking at AstNode.GetHashCode() implementation. If you use the one inherited from Object, then it is really slow and not very good hash. So the perf results show that the cost of using Activator is about the same as two dictionary lookups</p>\r\n<p>So let's get rid of the dictionary. Please declare a delegate, add a field (of delegate type) to BnfTerm, assign it at parser startup for all terms, and then use it for creating nodes. Let's see if it brings any visible perf improvement.</p>\r\n<p>Overall, I wouldn't worry even if we don't see perf differences. First, the perf of this piece is obscured by the load of all other parser activities. But mainly I would prefer to do this change anyway, because this old code using Activator is an \"itching point\", some obviously \"can be done better\" spot for any person reading the code, and making bad impression of the project as a whole. So let's go for it. Let me know the results please</p>\r\n<p>Thank you</p>\r\n<p>Roman</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-07-20T07:55:45.787-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "645046",
    "ThreadId": "265806",
    "Html": "<p>Thanks for the reply!</p>\r\n<p>The pattern I have used is one I use elsewhere.&nbsp; Even with Invoke I can assure you that it is a lot faster.&nbsp;&nbsp;I can say with some confidence that I know the Dictionary + Invoke + dynamic method pattern that I have used runs at a&nbsp;minimum 5 to 10 times faster than Activator.&nbsp; But I will do some direct performance tests and post them.&nbsp; But having said that, there is still about a factor of 3 improvement to be found to match a direct \"new\" statement.&nbsp; So if we can get that as well then this has been worthwhile.....&nbsp; An \"itching point\" is as good an excuse as I need.&nbsp; I just wanted to make sure that was what you wanted.&nbsp; Others I know wouldnt.</p>\r\n<p>Bad impression on the project as a whole?&nbsp; Not in my book.&nbsp;</p>\r\n<p>What I expect is that performance improvement = cost of initally producing the IL delegates, rather than the two dictionary lookups.&nbsp; Which means that on smaller parse trees it is a performance hit and on larger parse trees it is a performance gain.</p>\r\n<p>MSDN sample: oh yes, I see it now.&nbsp; Yes that will be marginally faster. Useful to know and I have already modified both this code and my other projects!</p>\r\n<p>Dictionary lookups: TryGet Value is just a pattern I have never got into using.&nbsp;&nbsp;A very good point on the double lookup and I will have&nbsp;a look at that.&nbsp; In the past I have measured the \"ContainsKey\" method to take about 1/3 of the time of the v=dict[key] lookup which is why I never really went looking for an alternative such as TryGetValue.&nbsp; But that is still time that can be recovered.</p>\r\n<p>Object hashes: I am using Type as the dictionary key, not the AST Node.&nbsp; So I was expecting (is that sensible?)&nbsp;that to be a good hash, a direct method and to not require boxing.&nbsp; But I take your point, it is still a hash operation and&nbsp;then an equality operation. Twice.</p>\r\n<p>Getting rid of the Dictionary: I didnt want to put it in&nbsp;until I noticed what&nbsp;the GetAstNodeType function was doing.&nbsp;&nbsp; Apparently for StringLiterals and template strings?&nbsp; Without&nbsp;understanding more and knowing that even with a dictionary I&nbsp;will still get a massive performance improvement, I put it in to just get it working,&nbsp; I was working on the assumption that I would only&nbsp;know&nbsp;for sure the type I need to construct after GetAstNodeType.&nbsp;</p>\r\n<p>Am I guaranteed that the AST node type&nbsp;will be totally predictable&nbsp;at parser startup even on the StringLiterals?&nbsp;(I worked on the assumption \"GetAstNodeType\" method has a purpose?)&nbsp; If I have to&nbsp;do an equality operation on the&nbsp;type before constructing then it is probably worthwhile just leaving the dictionary in there?</p>\r\n<p>Thanks for the clarification and the results are on the way...</p>",
    "PostedDate": "2011-07-20T09:09:51.203-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
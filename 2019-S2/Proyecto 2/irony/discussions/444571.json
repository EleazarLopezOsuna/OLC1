[
  {
    "Id": "1047013",
    "ThreadId": "444571",
    "Html": "Hello,<br />\n<br />\nI have been struggling to find a step by step tutorial for the latest version of Irony. I can only find the two posts created by Daniel Flower on Code project. Yes they are good, but unfortunately, it is only applicable to the old version of Irony. <br />\n<br />\nI am trying to generate/build a string (sql statements) based on the user input. Using the previous Irony, I needed my ast nodes classes to implement a generator interface, and then within each node class there is a function for generating/appending a string. How can I accomplish this in the new Irony? <br />\n<br />\nPlease help. Thank you.<br />\n",
    "PostedDate": "2013-05-22T03:56:03.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1047330",
    "ThreadId": "444571",
    "Html": "Currently, the best tutorials are the sample projects in the source code. Unfortunately, there are no step-by-step tutorials as Roman has been swamped, but I'm sure he would accept user submissions with regards to this.\r<br />\n<br />\nSounds like you are already off to a good start with code previously designed around the old Irony architecture.  I am not sure how to your request for help on the current Irony without some context to your issues.  If you could, please post some of your old code, and the community may be able to help.<br />\n",
    "PostedDate": "2013-05-22T12:13:14.64-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1047577",
    "ThreadId": "444571",
    "Html": "Hello,\r<br />\n<br />\nThank you for your reply. I am trying to generate an sql script based on the user input. The old tutorials were really helpful, but the new source code seems a bit complicated without any documentation. Basically, I had the following:\r<br />\n<br />\nA compiler class with the following function: <br />\n<pre><code>   public static string Compile(string sourceCode)\n    {\n        // create a compiler from the grammar\n        FLGrammar grammar = new FLGrammar();\n        LanguageCompiler compiler = new LanguageCompiler(grammar);\n\n        // Attempt to compile into an Abstract Syntax Tree. Because FLGrammar\n        // defines the root node as ProgramNode, that is what will be returned.\n        // This happens to implement ILangGenerator, which is what we need.\n        ILangGenerator program = (ILangGenerator)compiler.Parse(sourceCode);\n        if (program == null || compiler.Context.Errors.Count &gt; 0)\n        {\n            // Didn't compile.  Generate an error message.\n            SyntaxError error = compiler.Context.Errors[0];\n            string location = string.Empty;\n            if (error.Location.Line &gt; 0 &amp;&amp; error.Location.Column &gt; 0)\n            {\n                location = &quot;Line &quot; + (error.Location.Line + 1) + &quot;, column &quot; + (error.Location.Column + 1);\n            }\n            string message = location + &quot;: &quot; + error.Message + &quot;:&quot; + Environment.NewLine;\n            message += sourceCode.Split('\\n')[error.Location.Line];\n\n            throw new CompilationException(message);\n        }\n\n        // now just instruct the compilation of to javascript\n        StringBuilder js = new StringBuilder();\n        program.GenerateScript(js);\n        return js.ToString();\n\n    }\n</code></pre>\n\nA grammar class:<br />\n<pre><code>    public FLGrammar()\n    {\n\n        #region Initial setup of the grammar\n\n        this.CaseSensitive = false;\n\n        // define all the non-terminals\n        var program = new NonTerminal(&quot;program&quot;, typeof(ProgramNode));\n        var statementList = new NonTerminal(&quot;statementList&quot;, typeof(StatementListNode));\n        var condition = new NonTerminal(&quot;statement&quot;, typeof(ConditionNode));\n\n        var oper = new NonTerminal(&quot;operator&quot;, typeof(OperatorNode));\n\n        // define all the terminals\n        var variable = new IdentifierTerminal(&quot;variable&quot;);\n        variable.AddKeywords(&quot;where&quot;,&quot;set&quot;, &quot;to&quot;, &quot;if&quot;, &quot;freight&quot;, &quot;cost&quot;, &quot;is&quot;, &quot;loop&quot;, &quot;through&quot;, &quot;order&quot;);\n        var number = new NumberLiteral(&quot;number&quot;);\n        var stringLiteral = new StringLiteral(&quot;string&quot;, &quot;\\&quot;&quot;, ScanFlags.None);\n\n        // remove uninteresting nodes from the AST (note: in current version of Irony,\n        // keywords added to the variable cannot be registered as punctuation).\n        this.RegisterPunctuation(&quot;;&quot;, &quot;[&quot;, &quot;]&quot;, &quot;(&quot;, &quot;)&quot;);\n\n        // specify the non-terminal which is the root of the AST\n        this.Root = program;\n\n        #endregion\n\n        #region Define the grammar\n\n        //&lt;Program&gt; ::= &lt;StatementList&gt; &lt;FreightDeclaration&gt;\n        program.Rule = statementList;\n\n        //&lt;StatementList&gt; ::= &lt;Statement&gt;*\n        statementList.Rule = Symbol(&quot;where&quot;) + condition;\n\n        //&lt;condition&gt;::= &lt;string&gt; &lt;operator&gt; &lt;string&gt; | &lt;condition&gt; &lt;operator&gt; &lt;condition&gt; | “(“  &lt;condition&gt; “)”\n\n        //&lt;Statement&gt; ::= &lt;SetVariable&gt; &quot;;&quot; | &lt;IfStatement&gt; | &lt;OrderLoop&gt; | &lt;Expression&gt; &quot;;&quot;\n        condition.Rule = condition + oper + condition | &quot;(&quot; + condition + &quot;)&quot; | variable | \n            number | stringLiteral;\n\n\n\n\n        //&lt;BinaryOperator&gt; ::= &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; | &quot;is&quot;\n        oper.Rule = Symbol(&quot;+&quot;) | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; | &quot;is&quot; | \n            &quot;=&quot; | &quot;like&quot; | &quot;and&quot; | &quot;or&quot;;\n\n\n        #endregion\n\n    }\n</code></pre>\n\nA class for each node, to generate the related SQL statements. Each class inherits AstNode, and implements a Generator interface which has a virtual function for generating scripts. \r<br />\n<br />\nWith the new Irony source code, I have looked at the ExpressionEvaluatorGrammar example. I can see three classes for the grammar:\r<br />\nExpressionEvaluator, ExpressionEvaluatorGrammar &amp; ExpressionEvaluatorRuntime. In addition to that, there are are classes for AstNode. This time, these classes only inherit from AstNode. I dont know where should I implement the logic for generating the SQL script. Should it be in the overriden Init function?\r<br />\n<br />\nAlso it seems the ExpressionEvaluator example makes use of several LanguageRuntime classes: LanguageRuntime, LanguageRuntime_Binding, LanguageRuntime_OpDispatch, LanguageRuntime_OpDispatch_Init. Do I need to implement all these three classes to achieve what I am looking for?\r<br />\n<br />\nPlease help. Thank you.<br />\n",
    "PostedDate": "2013-05-23T01:38:30.077-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1048071",
    "ThreadId": "444571",
    "Html": "I don't think you need AST nodes at all, and all that interpreter/runtime stuff. You can take the same approach as FTS search grammar - it generates SQL FTS clause by directly traversing the parse tree, without generating AST. Have a look, it is in samples. When you hit Run in GE, it generates the FTS clause and writes it to the output. <br />\n",
    "PostedDate": "2013-05-23T22:41:22.647-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "203998",
    "ThreadId": "60253",
    "Html": "<p>Hello all,</p>\r\n<p>Thanks to salec's example (vslua) and a few modifications, I managed to have Irony parse a complex Lua chunk.</p>\r\n<p>After a brief moment of joy, I realized that the resulting Parse Tree is a bit too complex to be traversed in order to emit instructions.</p>\r\n<p>Here's an example of the resulting parse tree for two simple expressions. Boldfaced output shows what I meant about complexity.</p>\r\n<p>The first statement is relatively easily parsed. I believe Grammar.MarkTransient is a way to create simpler trees, but I'm sure there's a better way to do it.</p>\r\n<p>I tried to mark many non-terminals as transient but the result didn't exactly get better. If anyone feels brave enough to help, I can provide the grammar file if needed - haven't posted it because it was a bit too long. Thanks for any advice or clarification.</p>\r\n<pre><span style=\"color:#000080\">x = { }\r\nx[&quot;Key&quot;] = &quot;Value&quot;\r\n\r\n*\r\nNT0\r\n                |var\r\n                        |x (identifier)\r\n                |*\r\n                |= [Symbol]\r\n                |expr\r\n                        |table constructor\r\n                                |{ [Symbol]\r\n                                |field list?\r\n                                |} [Symbol]\r\n                |*\r\n                |;?\r\n<strong>NT0\r\n                |var\r\n                        |prefix expr\r\n                                |var\r\n                                        |x (identifier)\r\n                        |[ [Symbol]\r\n                        |expr\r\n                                |Key (string)\r\n                        |] [Symbol]\r\n                |*\r\n                |= [Symbol]\r\n                |expr\r\n                        |Value (string)\r\n                |*\r\n                |;?</strong></span></pre>\r\n<pre><span style=\"color:#000080\"><strong></strong></span></pre>\r\n<pre></pre>",
    "PostedDate": "2009-06-22T03:27:36.32-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "204698",
    "ThreadId": "60253",
    "Html": "<p>Well, I guess you have some unreasonable expectations about&nbsp;what is involved in full&nbsp;compilation process.&nbsp;As far as I understand, you try to take a parse tree and traverse it while generating IL code - that's not gonna work.&nbsp;The parse tree (concrete syntax tree) is just a tree representation of the source text, it is far from representing the runtime code structure&nbsp;in any aspect. It has too much noise (you identify it as &quot;too-complex&quot; term), but essentially you must go through at least one step - generate AST (abstract syntax tree), in which nodes represent something &quot;executable&quot;. AST does not necessarily match parse tree, it removes the noise and reorganizes the whole structure. This is at least the first step.</p>\r\n<p>In your example I see non-terminals with auto-assigned names (NT0), these are created by Irony grammar processor automatically, and this should never happen. This might work for quick parsing to support VS integration, but for full compilation that wouldn't work. You need to declare all non-terminals explicitly and assign AstNodeType property to each of them.</p>\r\n<p>You need to&nbsp;define AST nodes (classes), and then instantiate them to get the AST tree. A good way to flexibly create nodes is NodeCreator methods that can be attached to non-terminals. Look at Scheme sample in old &quot;release&quot; version for some ideas. Remember this is just a sketch, only a few AST node types were defined by Irony, just to run simple programs. Full set of AST nodes, with ability to generate some intermediate codes will be provided in the future, I'm working on it. For now, you have to define the yourself.</p>\r\n<p>Once you get the AST tree, the next step is some tree analysis (like variables, scopes, etc), and then possibly code generation. Each AST node class should be able to generate appropriate code. Built-in Irony support for this is in some distant future</p>\r\n<p>As for simplifying the tree, Irony does some tricks like removing transient nodes.&nbsp;The candidates are usually some &quot;generalized&quot; nodes like&nbsp;&quot;expr&quot; in your case: expr node does not exist, instead you would have several types particular expr types like binExpr, unaryExpr, funcCall expr, etc.</p>\r\n<p>Hope this helps</p>\r\n<p>Roman</p>",
    "PostedDate": "2009-06-23T15:57:16.297-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "204856",
    "ThreadId": "60253",
    "Html": "<p>Hello Roman,</p>\r\n<p>Thanks for the detailed answer, I know I wasn't too clear so I apologise for any misunderstanding.</p>\r\n<p>Knowing that the AST part of Irony isn't ready yet, I was just looking for a workaround using the parse tree as a reference for further processing.</p>\r\n<p>Clearly I was missing an important part, that is being able to build an AST on my own, which is what I'll be doing now; quite clear coming to think of it.</p>\r\n<p>&nbsp;</p>\r\n<p>Let me thank you again for your great work with Irony and sorry if my question came across a bit odd.</p>\r\n<p>Roberto</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-06-24T01:24:38.16-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
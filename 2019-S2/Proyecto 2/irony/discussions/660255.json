[
  {
    "Id": "1490122",
    "ThreadId": "660255",
    "Html": "I'm new to Irony (and parsing/grammars in general) so please bear with me.\r<br />\n<br />\nI'm trying to parse strings of the form:<br />\n<pre><code>asdf asdf asdf key = fdsa</code></pre>\n\nI'm trying to break this up into &quot;asdf asdf asdf&quot; and &quot;key = fdsa&quot;. Basically this is supposed to be composed of 2 types of elements, freetext and then an identifier=freetext\r<br />\n<br />\nthe identifiers are keywords that would match a IdentifierTerminal(&quot;identifier&quot;, IdOptions.None).\r<br />\n<br />\nIs there a way to parse this? I got showstopped pretty quickly with a freeText string being greedy and grabbing everything. I guess in an ideal world I could specify a terminator rule of the form (identifier + &quot;=&quot;) but I suspect this is not possible. I suspect most likely what I'm trying to do is not possible for reasons/concepts I don't fully understand (ambiguous grammar? lookahead?)\r<br />\n<br />\nMy rather amateurish attempt:<br />\n<pre><code>            var identifier = new IdentifierTerminal(&quot;identifier&quot;, IdOptions.None);\n            var freeText = new FreeTextLiteral(&quot;freeText&quot;, FreeTextOptions.AllowEof);\n            freeText.Terminators.Add(&quot;=&quot;);\n\n            NonTerminal args = new NonTerminal(&quot;args&quot;);\n            NonTerminal arg = new NonTerminal(&quot;arg&quot;);\n\n            arg.Rule = (identifier + &quot;=&quot; + freeText) | freeText;\n            args.Rule = MakeStarRule(args, arg);\n            this.Root = args;</code></pre>\n\n",
    "PostedDate": "2016-12-20T23:37:14.347-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1490276",
    "ThreadId": "660255",
    "Html": "I don't think it's possible to break your sample expr into (freetext + (key = fdsa)) - this is just LALR parser limitations\r<br />\nyou will have to parse it as: \r<br />\n  (wordList + &quot;=&quot; + word)\r<br />\nwordList.Rule = MakeStartRule(workdList, word)\r<br />\n<br />\nall terms before = are parsed as one combined list<br />\n",
    "PostedDate": "2016-12-25T00:45:26.21-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1490356",
    "ThreadId": "660255",
    "Html": "Hi rivantsov,<br />\n<br />\nThanks for the advice. I have gotten a basic system that does what I want, although given the rewrite  feel like I am using Irony more as a lexer than an actual parser.<br />\n<br />\nI was wandering through the examples and code and wondering if it would be theoretically possible to use the CustomActionHere directives to control the shift/reduce behaviour to develop a more meaningful parse tree?<br />\n<br />\nAnd is there any code that explains the CustomParserAction in more detail? I've tried reading the CSharpGrammar ResolveLessThanConflict but I struggle a bit to map it to my (limited) knowledge of shift-reduce parser theory.<br />\n<br />\nFrom what I understand a shift simply pulls the next unread token into the parse stack. But why does the CustomParserAction have a list of possible ShiftActions (and why do some appear to be duplicated)? From videos I've seen the notion of a 'shift' is a shift has no options - it just depends on where you are in the tree. I guess the ShiftActions are related somehow to jumping between the internal parser states that Irony constructs (and on this note, is there a way to get a more meaningful dump of what the states represent? <br />\n<br />\nA reduce then replaces subtrees in the parse stack with production rules. That makes sense, although I have not been able to effectively use this anywhere - when I try to call a reduce it does not appear to do anything.<br />\n<br />\nMy rather amateurish code that might maybe help explain my level of misunderstanding is below. I was hoping to simply duplicate the parse behaviour of uncommenting C0 (and commenting the line below it) and then go from there, but I can't even achieve that.<br />\n<pre><code>\n    public partial class Attempt7 : Grammar\n    {\n        public Attempt7() : base(false)\n        {\n            var word = new IdentifierTerminal(&quot;word&quot;);\n\n//            var freeText = new NonTerminal(&quot;freeText&quot;);\n//            freeText.Rule = freeWord | ;\n\n            var element = new NonTerminal(&quot;element&quot;);\n//            element.Rule = word; // C0 works\n            element.Rule = CustomActionHere(ExecuteCustomAction) + word;\n//            element.Rule = ExecuteCustomAction(Resolve, Preview) + word; // C2 does not work\n\n            var elementList = new NonTerminal(&quot;elementList&quot;);\n            elementList.Rule = elementList + element | element | Empty;\n\n            this.Root = elementList;\n        }\n\n        private void Preview(CustomParserAction action)\n        {\n        }\n\n        private void ExecuteCustomAction(ParsingContext context, CustomParserAction customAction)\n        {\n            Console.WriteLine(&quot;Resolve fire at &quot; + context.CurrentToken + &quot; &quot; + context.CurrentToken.Location);\n\n            ParserAction action;\n\n            context.Parser.Scanner.BeginPreview();\n            context.Parser.Scanner.EndPreview(true);\n\n            if (customAction.ReduceActions.Count &gt; 0)\n            {\n                foreach (var ra in customAction.ReduceActions)\n                    Console.WriteLine(&quot;\\t REDUCTION ACTION : {0} {1} {2} {3}&quot;, ra, ra.Production, ra.Production.LValue, ra.Production.RValues);\n\n                foreach (var sa in customAction.ShiftActions)\n                    Console.WriteLine(&quot;\\t SHIFT ACTION : {0} {1} {2}&quot;, sa, sa.Term, sa.Term.Name);\n            }\n\n            if (customAction.ReduceActions.Count &gt; 0)\n            {\n                action = customAction.ReduceActions.First();\n                action.Execute(context);\n\n                Console.WriteLine(&quot;Execute action: &quot; + action);\n            }\n            else\n            {\n                \n//                action = customAction.ShiftActions.First(x =&gt; x.Term == context.CurrentToken.Terminal); // C3 implodes with KeyNotFoundException\n//                action.Execute(context);\n            }\n        }\n    }</code></pre>\n\n",
    "PostedDate": "2016-12-28T02:32:09.533-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
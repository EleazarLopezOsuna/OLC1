[
  {
    "Id": "453530",
    "ThreadId": "215462",
    "Html": "<p>Hi,</p>\r\n<p>I've got a working Irony grammar, but I'm having trouble building my AST. To build it, I need a symbol table to resolve names. I think I'm probably just trying the wrong approach, and hope someone can suggest the right way to do things.</p>\r\n<p>The grammar itself is trivial; it's a SQL-like template language like this;</p>\r\n<p>&nbsp;&nbsp;&nbsp; SELECT &lt;columns tbl.Id tbl.Key&gt;      from &lt;table tbl&gt;</p>\r\n<p>It was wonderfully easy to construct a parse tree that i'm very happy  with;</p>\r\n<p>&nbsp;&nbsp;&nbsp; (LITERAL (columnList (columnRef ID ID) (columnRef ID ID))</p>\r\n<p>&nbsp;&nbsp;&nbsp; LITERAL (tableref ID))</p>\r\n<p>So far, so good. Now I want to build my AST. When I reach a 'columnRef'  term like this;</p>\r\n<p>&nbsp;&nbsp;&nbsp; &lt;column tbl.col&gt;</p>\r\n<p>I want to add symbols for the 'tbl' table and the 'col' column to a  global symbol table.  I don't see the right way to attach the symbol table to the parser  before I begin parsing.</p>\r\n<p>I've tried this;</p>\r\n<p><br>&nbsp;&nbsp;&nbsp; var grammar = new MyGrammar();<br>&nbsp;&nbsp;&nbsp; var parser = new Parser(grammar);<br>&nbsp;&nbsp;&nbsp; // attach a new symbol table<br>&nbsp;&nbsp;&nbsp; var symbolTable = new MySymbolTable();<br>&nbsp;&nbsp;&nbsp; parser.Context.Values.Add(&quot;symbol-table&quot;, symbolTable);<br>&nbsp;&nbsp;&nbsp; // now parse<br>&nbsp;&nbsp;&nbsp; parser.Parse(input);<br><br>And then try to look in the context for the symbol table on AstNode.Init():<br><br>&nbsp;&nbsp;&nbsp; // overridden Init() on ColumnRefNode<br>&nbsp;&nbsp;&nbsp; public override void Init(ParsingContext context, ParseTreeNode treeNode)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.Init(context, treeNode);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get the table and column names <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // from the ID terminals<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var tableName = treeNode.ChildNodes[0].Token.Value.ToString();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var columnName = treeNode.ChildNodes[1].Token.Value.ToString();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // get the symbol table from the context<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var st = (SymbolTable)context.Values[&quot;symbol-table&quot;];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var table = st.ResolveTable(tableName);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var column = table.ResolveColumn(columnName);<br>&nbsp;&nbsp;&nbsp; }<br><br>But when the parser starts it clears the Values collection, and the symbol table is lost. <br><br>Can anyone tell me how they go about creating and attaching symbol tables, scope trees, and that sort of thing to the parser? And can you do it so that the grammar explorer continues to work?<br><br>Many thanks,<br><br>&nbsp;&nbsp; Steve Cooper</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-06-09T06:43:23.623-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "453558",
    "ThreadId": "215462",
    "Html": "<p>Steve,</p>\r\n<p>The best approach I've found is to create your own classes derived from AstNode, and then reference them selectively in your grammar constructor when you create non-terminals.&nbsp; Irony will automatically instantiate your class and will call the virtual &quot;Init&quot; method, which you can then override in your class.</p>\r\n<p>For example, I have a grammar that implements a simple scripting language.&nbsp; The non-terminals look something like the following:</p>\r\n<p>var Script = new NonTerminal(&quot;Script&quot;, typeof(Script));<br>var Statements = new NonTerminal(&quot;Statements&quot;);<br>var Statement = new NonTerminal(&quot;Statement&quot;);<br>var ActivitiesList = new NonTerminal(&quot;ActivitiesList&quot;, typeof(ActivitiesList));</p>\r\n<p>and so on.&nbsp; Note that you only need to specify a class for the non-terminals you want converted to AST nodes.&nbsp; Then, in your derived AstNode.Init method, you have to locate the appropriate child nodes and add them as child nodes to the node that Irony creates for you.</p>\r\n<p>The trick (there's always a trick) is that Irony &quot;unfolds&quot; the parse tree from the inside out.&nbsp; So by the time the Init method is called, the children of the ParseTreeNode instance should have their AstNode members already initialized.&nbsp; Thus, it's kind of an &quot;all or nothing&quot; proposition.&nbsp; In other words, you have to know in advance how you want your AST to look, so you can go through your non-terminals and specify the classes properly.&nbsp; Once you've done that, building the AST is a snap.</p>\r\n<p>I've been thinking to write this up and add it to Roman's new WikiBook, because lots of people seem to struggle with AST building.</p>\r\n<p>One more thing - I've found that the &quot;top-level&quot; node typically requires some kind of &quot;fixup&quot;.&nbsp; The best tool for this is the AcceptVisitor method that lets you easily traverse the AST to locate items that need to be relocated, etc. before additional processing.&nbsp; This also happens in the Init method.&nbsp; For example, typically the parent references are incorrect (again, because the AST nodes are created from the &quot;inside out&quot;).&nbsp; To deal with this, I use the following code in the top-level AST node.</p>\r\n<p>public class Script : AstNode<br>{<br>&nbsp;&nbsp; public override void Init(ParsingContext context, ParseTreeNode treeNode)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; base.Init(context, treeNode);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AcceptVisitor(new FixupParentReferences());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //...more cool stuff here...<br>&nbsp;&nbsp; }</p>\r\n<p>&nbsp;&nbsp; internal class FixupParentReferences : IAstVisitor<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void BeginVisit(AstNode node)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (AstNode child in node.ChildNodes)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; child.SetParent(node);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void EndVisit(AstNode node) {}<br>&nbsp;&nbsp; }<br>}</p>\r\n<p>Hope this helps,</p>\r\n<p>John</p>",
    "PostedDate": "2010-06-09T07:40:25.293-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "453694",
    "ThreadId": "215462",
    "Html": "About clearing context.Values collection - this is a valid point, there must be some way to pass some shared information down to each node, and I think this collection was created for this  - and also to allow exchanging data between nodes. I will look into this, probably this collection should not be cleared automatically. For now you can just make modifications yourself in Irony sources. ",
    "PostedDate": "2010-06-09T13:32:02.58-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "453868",
    "ThreadId": "215462",
    "Html": "<p>@John</p>\r\n<p>Thanks -- this helps clear things up. Here's how I understand it;</p>\r\n<p>The post-order traversal of the nodes makes sense when building a typed tree, but it's probably not the place to do much work.</p>\r\n<p>In many languages, for instance, variables need to be defined before they are used. Eg;</p>\r\n<p>&nbsp;</p>\r\n<pre>int i;\r\nif (cond)\r\n{\r\n  i = 0;\r\n}</pre>\r\n<p>&nbsp;</p>\r\n<p>We'd get an AST like this;</p>\r\n<p>&nbsp;</p>\r\n<pre>  ((define 'i' 'int')\r\n   (if ('cond')\r\n    (assign 'i' 0)))\r\n\r\n</pre>\r\n<p>So if I'm initializing my 'assign' node before my 'define' node, then I can't do symbol table lookups yet; the 'i' in the assign node hasn't been defined yet.</p>\r\n<p>It seems to me that I am probably trying to do too much work when building the AST. What I should do is simply build the tree with the right types, and store off important token strings or child nodes. Later, I'll walk the tree and try to do something sensible with the info stored there. In the example above, then, all I'd do during AST construction is save the string 'i' in an instance of AssignAstNode, and save the 'i' and 'int' string in a DefineAstNode. Later, I'll visit all the nodes in pre-order, which will expose the nodes in the right order for symbol lookup.</p>\r\n<p>Does that sound like the right approach?</p>\r\n<p>@Roman</p>\r\n<p>I think it is right to clear the context -- it stops things  from a previous parse affecting the next parse -- but there has to be a  step after it has been cleared when the grammar author can act. One option might be to provide some virtuals for lifecycle events, like OnParseStart(context), OnParseFinish(context, parseRoot), and OnAstCreated(context, astRoot). When the parse starts, the grammar can initialise the symbol table there. I haven't really thought it through, but I thought I'd suggest it.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-06-10T02:00:34.523-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
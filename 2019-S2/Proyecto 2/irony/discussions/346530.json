[
  {
    "Id": "802473",
    "ThreadId": "346530",
    "Html": "\r\n<p>I had implemented a language grammar (CQL, part of the <a href=\"http://portal.opengeospatial.org/files/?artifact_id=20555\">\r\nOGC CSW 2.0.2 standard</a>) for my project (<a href=\"http://geosik.codeplex.com/\">GeoSIK</a>) using the october 2011 version of Irony. Somehow noticing that a new version of Irony had been pushed to the download page, I tried to update my dependency, and here\r\n are some questions/suggestions about it.</p>\r\n<ul>\r\n<li>I think it would be better to archive old versions of Irony (naming them alpha1, alpha2, or CTP1, CTP2...):\r\n<ul>\r\n<li>my project is a library (as opposed to an application), so I don't think it is wise for me to make the Irony assemblies part of my releases.\r\n</li><li>the current release process for Irony means that my project must to be up to date, so that the users of my library can have access to the right version of Irony. Old versions of my library are unusable, though.\r\n</li><li>it is very difficult to get notified of new versions right now... </li><li>what about delivering <a href=\"http://nuget.codeplex.com/\">NuGet</a> packages (I can help about this)?\r\n</li></ul>\r\n</li><li>CQL is a query language. I use Irony to parse the input, create an AST and build a LINQ expression from this. As part of this use case:<br>\r\n<ul>\r\n<li>I love that I now can specify the AST node type in the Terminal constructor. </li><li>the default node types specifications (<span><em>DefaultIdentifierNodeType</em>,\r\n</span><em><span>DefaultLiteralNodeType</span></em><span>) having disappeared, I have had to add node types to all literals and identifiers...</span>\r\n</li><li><span>much worse (IMHO) is the new handling of operators. To be able to define an operator usable by a\r\n</span><em>BinaryOperationNode</em><span>, I used to simply type the following<br>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>OperatorMappings.Add(equals_operator.Text, ExpressionType.Equal, 10);\r\n</pre>\r\n</div>\r\nNow <em>OperatorMappings</em> have disappeared, I have to:</span>\r\n<ul>\r\n<li><span>create and store a new <em>OperatorHandler</em>:\r\n<div style=\"color:black; background-color:white\">\r\n<pre>_OperatorHandler=<span style=\"color:blue\">new</span> OperatorHandler(<span style=\"color:blue\">true</span>);\r\n<span style=\"color:blue\">var</span> oid=_OperatorHandler.BuildDefaultOperatorMappings();\r\noid.Clear();\r\noid.Add(equals_operator.Text, ExpressionType.Equal, 10);\r\n</pre>\r\n</div>\r\n</span></li><li><span>override the </span><span><em>BuildAst </em>method so that the <em>AstContext\r\n</em>is an instance of <em>InterpreterAstContext </em>(or else <em>BinaryOperationNode\r\n</em>is unusable, cf. line 42) with the operator handler defined above:\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> BuildAst(LanguageData language, ParseTree parseTree)\r\n{\r\n    <span style=\"color:blue\">if</span> (!LanguageFlags.IsSet(LanguageFlags.CreateAst))\r\n    <span style=\"color:blue\">return</span>;\r\n\r\n    <span style=\"color:blue\">var</span> astContext=<span style=\"color:blue\">new</span> InterpreterAstContext(language, _OperatorHandler);\r\n    <span style=\"color:blue\">var</span> astBuilder=<span style=\"color:blue\">new</span> AstBuilder(astContext);\r\n    astBuilder.BuildAst(parseTree);\r\n}\r\n</pre>\r\n</div>\r\n</span></li></ul>\r\n</li><li><span>I wish there was an easier way...</span> </li></ul>\r\n</li></ul>\r\n<p><span>Maybe there is another way, or maybe I am not using Irony properly (as you know, the documentation is scarce). Or maybe these are simply overlooks (bugs?). Please let me know of anything I might be doing wrong. If you have the courage, my set of changes\r\n<a href=\"http://geosik.codeplex.com/SourceControl/changeset/changes/01a7eecede38#src%2fLibrary%2fOgc%2fWebCatalog%2fCql%2fCqlGrammar.cs\">\r\nis accessible here</a>.<br>\r\n</span></p>\r\n<p><span>Do not get the wrong impression: I think your work is a truly great piece of software, and I am only complaining because I am using (and loving) it. Keep up the good work.</span></p>\r\n<p><span>And let me know if you want help on the <a href=\"http://nuget.codeplex.com/\">\r\nNuGet</a> packaging.<br>\r\n</span></p>\r\n",
    "PostedDate": "2012-02-28T01:27:34.27-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "804593",
    "ThreadId": "346530",
    "Html": "<p>Hi</p>\r\n<p>Sorry for your troubles. Let me explain a few things, or better say, present some excuses - why things the way they are.</p>\r\n<p>You have started something serious, and for a period of time - yes, I think you should include Irony assembly into your distribution. One reason is that you use AST functionality. The latest change you're talking about is when I finally completed long planned goal - to separate the general AST, and interpreter infrastructure from core Irony (pure parsing). I tried to keep parsing part stable and backward compatible, while did not care so much about AST and interpreter API - just did not expect anybody was using it for serious stuff - and at low-level API. At least, I thought, people were using Evaluator with some customizations, and all API changes underneath would not affect them. Apparently I was wrong, and you are the frustrated victim. Sorry again, but this move should have been done any was, it was long overdue. The current structure (I believe) is much better.</p>\r\n<p>For the future, I expect the AST/interpreter stuff still to be relatively unstable. So when you take a new version, see some major changes and see that convenient ways you used to do things disappeared, contact me - maybe the API just moved, or it maybe an overlook on my part. But keep shipping particular version of Irony with your code anyway, for now. I expect parsing part to be stable, will only add extra facilities, but cannot say the same about AST and interpreter.&nbsp;</p>\r\n<p>In my opinion, it is too early to move Irony distribution to NuGet, we're not at 1.0 point yet. The trouble is that I'm 100% busy with other stuff at daytime work, and other project I have (vita.codeplex.com), which is much more urgent for me now - sorry folks. Irony is on-hold&nbsp;- sorry folks, can only occasionally answer urgent questions, but did not touch the code in weeks if not months.</p>\r\n<p>Now, about things you do. &nbsp;First, it's in my to-do list to provide an output as expression tree of the parse tree, as standard facility. The latest changes were done with these plans in mind. Why don't you look at this - how to add a few things inside Irony to produce expression tree output?</p>\r\n<p>About default node types. They moved to AstContext - you could set it there;&nbsp;</p>\r\n<p>Modifying operator mappings - InterpretedLanguageGrammar has a method CreateRuntime. The idea was that this would be a customization point for things like operator mappings. You would call base method and then tweak the runtime object - change operator mappings for ex. It might be possible that some API methods are missing there - it is an overlook, the result of rush refactorings. Add the method(s) and let me know - I'll fix it.&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-03-02T11:28:50.54-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "805507",
    "ThreadId": "346530",
    "Html": "<p>Thanks for your answer.</p>\r\n<p>And don't be too sorry: I have a much clearer overview of the project now, which is what I (and surely others) lacked the most. I perfectly understand that the AST functionality is (and will be) unstable, and now I understand why.</p>\r\n<p>I still wished old versions of Irony could be downloaded from CodePlex though (albeit with disclaimers about the early stage the project is in, and about the likelihood of future breaking changes). Suppose a developer wanted to use Irony AND my library? Suppose I have not had the time to upgrade my code to the latest version of Irony: he will be able to pick compatible Irony assemblies from my project, but what about the Grammar Explorer for instance (which I found very useful)? Should I release it as well?</p>\r\n<p>As for the creation of an expression tree, I have now gained a bit of experience as part of my project, which I may be able to use to try and help you. This may not be the right place to discuss these technical things, so do not hesitate to fork this discussion somewhere else if you want to. The main problem I have had to deal with was with the handling of <em>Identifier</em>s. The language I have implemented (CQL) is a SQL-Like language (the query part, after the <em>WHERE </em>clause). Identifiers are mapped to fields or properties in an in-memory, object representation of the underlying data (think entities / Linq to Entities). Suppose I have an object like this:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> Person\r\n{\r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">string</span> Name { <span style=\"color: blue;\">get</span>; <span style=\"color: blue;\">set</span>; }\r\n    <span style=\"color: blue;\">public</span> IList&lt;<span style=\"color: blue;\">string</span>&gt; FirstName { <span style=\"color: blue;\">get</span>; }\r\n}\r\n</pre>\r\n</div>\r\n</p>\r\n<ul>\r\n<li>Using an AST, simple expressions can be built very easily. <em>WHERE NAME='foo'</em> translates into <em>p =&gt; p.Name==\"foo\"</em>. No problem:\r\n<ul>\r\n<li>I take the operator left argument: mapping from <em>NAME </em>to <em>p.Name</em>.</li>\r\n<li>I take the right argument: the string <em>\"foo\"</em>.</li>\r\n<li>I combine the two with the operator. Return this node. Done.</li>\r\n</ul>\r\n</li>\r\n<li>But when lists are involved, you see that <em>WHERE FIRSTNAME='foo'</em> now translates into <em>p =&gt; p.FirstName.Any&lt;string&gt;(s =&gt; s==\"foo\")</em>.\r\n<ul>\r\n<li>The whole algorithm has to be different now. Something has to detect that one of your arguments is a list and build the <em>Any </em>method:<br />\r\n<ul>\r\n<li>Maybe the mapper (first step above). Then it should have access to the right argument and to the operator, as they are part of the <em>Any </em>method. Then steps 2 and 3 should be skipped.</li>\r\n<li>Maybe the operator. But the expression node that is returned is not the operator in this case, it is the left argument (the list): the operator is hidden <em>inside </em>the <em>Any </em>method...</li>\r\n</ul>\r\n</li>\r\n<li>Now think of what happens if the left argument AND the right argument are list identifiers: 2 imbricated <em>Any </em>methods, the operator being implemented in the innermost one...</li>\r\n</ul>\r\n</li>\r\n<li>All this complexity would not occur in a language that would be more descriptive, and close to C# (ie a language that would handle lists explicitly, like C#).</li>\r\n</ul>\r\n<p>The point is that there is an obvious implementation for expression building, that would not be sufficient for every language. The problem lies in keeping the interface simple while giving absolute control to developers so that they could handle difficult scenarios like the one described above. The implementation I have come up with in my library seems to be sufficient to handle my specific requirements (I am not even sure of this at this point), but I do not think it is generic enough...</p>\r\n<p>Anyway, how would you consider contributions for this? Patches? A fork?</p>\r\n<p>Note that I may take my time: I too have other things on my plate ;-)</p>",
    "PostedDate": "2012-03-05T05:52:57.893-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "806328",
    "ThreadId": "346530",
    "Html": "<p>about your described problem with Identifiers. Man, i'm afraid you're not doing it the right way. You're bringing semantic analysis and transformations into a parsing process - at least what I understood. Parser should not care what things \"are\", only what they look like. It should not care if identifier refers to list or a single object - the parser tree is the same. Parser converts text into a tree. Understanding and rewriting it is a later job done over a tree.&nbsp;</p>\r\n<p>For example, that's how LINQ query is processed:</p>\r\n<p>1. Query parsing - as an internal c# parse tree: text-&gt;tree</p>\r\n<p>2. Rewriting it as a chain of method calls to Queryable methods - this chain replaces the LINQ expression; there are simple rules: tree-&gt;series chained calls</p>\r\n<p>3. At execution time (app is running), when query is constructed: execution of chained calls against initial data source (ITable or IEnumerable) - the result is an expression tree over the real data source.</p>\r\n<p>4. Result enumeration - the query expression tree is transformed into a real query (SQL or a chain of calls to list methods); the real query is executed, result is enumerated</p>\r\n<p>Note that 1 and 2 are done at compile time, with parsing happening at step 1. Steps 3 and 4 are done at runtime. That illustrates my point - producing the expression tree is separated from parsing in \"space\" and \"time\".&nbsp;The main point - parser is NOT concerned what object \"is\"; \"identifier\" is the only piece of information it cares about - it creates a parse tree with \"identifier\" and passes the tree down the pipeline to semantic analysis and rewriting stages.&nbsp;</p>\r\n<p>So when I was talking about output and expression tree, I meant only only real expressions; not all constructs in programming languages can be represented as expression trees. \"WHERE\" is one thing that is not there.&nbsp;</p>\r\n<p>The best way to contribute is to make a fork</p>\r\n<p>Roman</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2012-03-06T09:47:51.413-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "806511",
    "ThreadId": "346530",
    "Html": "<p>Sorry for the misunderstanding.</p>\r\n<p>Having been immersed in LINQ expressions for a while, I understood you wanted to output <em>LINQ </em><a href=\"http://msdn.microsoft.com/en-us/library/bb397951.aspx\">expression tree</a>s. Which is what I had attempted to do in my special case, and I tried to explain the problems I had encountered in the translation process. But rereading your previous answer, it seems that I have been the only one talking about LINQ the all time...</p>\r\n<p>I agree with everything you just explained (obviously, as you seem to have a much clearer idea of the whole thing than I do). I am indeed using Irony for the parsing and the AST output. In my case, the AST is an expression tree that<em> I</em> then proceed to rewrite as a <em>LINQ expression tree</em>, given a certain context.</p>\r\n<p>So if I understand well what you are trying to do, you want to be able to produce an AST by default that is an expression tree. Right? So we would need to be able to automatically detect (or infer) the meaningful nodes types (operators, identifiers...) and the transient ones.</p>\r\n<p>Am I getting closer?</p>",
    "PostedDate": "2012-03-06T14:50:18.567-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "811099",
    "ThreadId": "346530",
    "Html": "<p>Hi Roman,</p>\r\n<p>I'm also in the process of porting the old Irony version I was using (around September 2011) to the newest.</p>\r\n<p>The new AST system is much better decoupled now, that's great. Though I have discovered an annoying mismatched behavior, compared to the previous version:</p>\r\n<p>In the previous version, when a terminal had \"NoAstNode\", the Ast construction was skipped for this node, but not for its children. Current implementation doesn't reproduce this behavior, and this is annoying as I'm heavily relying on this behavior (For example, all my list are often declared inline into the grammar, and I'm constructing AST list from the parent node, not from the list node itself).</p>\r\n<p>Do you think that It would be acceptable to change AstBuilder.BuildAst method to match this behavior (in <strong>bold</strong>, a code replacement proposal)</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">virtual</span> <span style=\"color: blue;\">void</span> BuildAst(ParseTreeNode parseNode) {\r\n      <span style=\"color: blue;\">var</span> term = parseNode.Term;\r\n      <span style=\"color: green;\">// NEW BEHAVIOR: if (term.Flags.IsSet(TermFlags.NoAstNode) || parseNode.AstNode != null) return; </span><br />      <strong><span style=\"color: blue;\">if</span> (parseNode.AstNode != <span style=\"color: blue;\">null</span>) <span style=\"color: blue;\">return</span>; </strong>\r\n      <span style=\"color: green;\">//children first</span>\r\n      <span style=\"color: blue;\">var</span> processChildren = !parseNode.Term.Flags.IsSet(TermFlags.AstDelayChildren) &amp;&amp; parseNode.ChildNodes.Count &gt; 0;\r\n      <span style=\"color: blue;\">if</span> (processChildren) {\r\n        <span style=\"color: blue;\">var</span> mappedChildNodes = parseNode.GetMappedChildNodes();\r\n        <span style=\"color: blue;\">for</span> (<span style=\"color: blue;\">int</span> i = 0; i &lt; mappedChildNodes.Count; i++)\r\n          BuildAst(mappedChildNodes[i]);\r\n      }\r\n      <span style=\"color: green;\">//create the node</span>\r\n      <span style=\"color: green;\">//We know that either NodeCreator or DefaultNodeCreator is set; VerifyAstData create the DefaultNodeCreator</span>\r\n      <strong><span style=\"color: blue;\">if</span> (!term.Flags.IsSet(TermFlags.NoAstNode) { </strong>\r\n\t  <span style=\"color: blue;\">var</span> config = term.AstConfig;\r\n\t  <span style=\"color: blue;\">if</span> (config.NodeCreator != <span style=\"color: blue;\">null</span>) {\r\n\t\tconfig.NodeCreator(Context, parseNode);\r\n\t\t<span style=\"color: green;\">// We assume that Node creator method creates node and initializes it, so parser does not need to call </span>\r\n\t\t<span style=\"color: green;\">// IAstNodeInit.Init() method on node object. But we do call AstNodeCreated custom event on term.</span>\r\n\t  } <span style=\"color: blue;\">else</span> {\r\n\t\t<span style=\"color: green;\">//Invoke the default creator compiled when we verified the data</span>\r\n\t\tparseNode.AstNode = config.DefaultNodeCreator();\r\n\t\t<span style=\"color: green;\">//Initialize node</span>\r\n\t\t<span style=\"color: blue;\">var</span> iInit = parseNode.AstNode <span style=\"color: blue;\">as</span> IAstNodeInit;\r\n\t\t<span style=\"color: blue;\">if</span> (iInit != <span style=\"color: blue;\">null</span>)\r\n\t\t  iInit.Init(Context, parseNode);\r\n\t  }\r\n<strong>      }</strong>\r\n      <span style=\"color: green;\">//Invoke the event on term</span>\r\n      term.OnAstNodeCreated(parseNode);\r\n    }<span style=\"color: green;\">//method</span>\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Do you think that it is an acceptable fix for the new ast node builder?</p>\r\n<p>As I have forked Irony to merge minor changes I did to Irony (like Scanner pluggability), I will be able to send you a pull request.</p>",
    "PostedDate": "2012-03-15T14:13:12.933-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "811212",
    "ThreadId": "346530",
    "Html": "<p>Also, I'm getting the error \"<em>AstNodeType or AstNodeCreator is not set on non-terminals: {0}. Either set Term.AstConfig.NodeType, or provide default values in AstContext.</em>\"&nbsp; from AstBuilder.VerifyLanguageData for Transient nodes. Previous version  of Irony didn't complain about it.</p>\n<p>What is the correct way to handle this? Are we suppose to specify a custom AstContext and DefaultNodeType or should we add transient check to AstBuilder.VerifyLanguageData (like this:)?</p>\n<p>&nbsp;</p>\n<div style=\"color: black; background-color: white;\">\n<pre><span style=\"color: blue;\">if</span> (term.Flags.IsSet(TermFlags.NoAstNode) || term.Flags.IsSet(TermFlags.IsTransient)) <span style=\"color: blue;\">continue</span>;\n</pre>\n</div>\n<p>&nbsp;</p>\n<p>&nbsp;</p>",
    "PostedDate": "2012-03-15T19:41:29.84-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "811253",
    "ThreadId": "346530",
    "Html": "<p>will look at it. sorry, some things got messed up in AST during refactoring</p>",
    "PostedDate": "2012-03-15T23:58:07.667-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "1431355",
    "ThreadId": "640296",
    "Html": "I have the following grammar:<br />\n<pre><code>StringLiteral STRING = new StringLiteral(&quot;string&quot;, &quot;'&quot;, StringOptions.AllowsDoubledQuote);\nKeyTerm WITH = ToTerm(&quot;WITH&quot;);\nKeyTerm LIKE = ToTerm(&quot;like&quot;);\nKeyTerm AND = ToTerm(&quot;AND&quot;);\nKeyTerm OR = ToTerm(&quot;OR&quot;);\nKeyTerm BY = ToTerm(&quot;BY&quot;);\n\nNonTerminal expression = new NonTerminal(&quot;expression&quot;);\n\nIdentifierTerminal rootTable = new IdentifierTerminal(&quot;rootTable&quot;);\nIdentifierTerminal table = new IdentifierTerminal(&quot;table&quot;);\nIdentifierTerminal column = new IdentifierTerminal(&quot;column&quot;);\n\nNonTerminal filterList = new NonTerminal(&quot;filterList&quot;);\nNonTerminal filter = new NonTerminal(&quot;filter&quot;);\n\nNonTerminal connectionFilter = new NonTerminal(&quot;connectionFilter&quot;);\n\nNonTerminal stringFilter = new NonTerminal(&quot;stringFilter&quot;);\nNonTerminal stringQuery = new NonTerminal(&quot;stringQuery&quot;);\nNonTerminal stringOperator = new NonTerminal(&quot;stringOperator&quot;);\n\nconnectionFilter.Rule = column + BY + table | WITH + table;\n\nstringFilter.Rule = column + stringQuery | \n                    WITH + column + stringQuery;\nstringQuery.Rule = STRING |\n                stringOperator + STRING;\nstringOperator.Rule = LIKE;\n\nlinker.Rule = AND | OR | Empty;\n\nfilterList.Rule = MakePlusRule(filterList, linker, filter);\n\nfilter.Rule = connectionFilter |\n           stringFilter;\n              \nexpression.Rule = rootTable + filterList;             \n\nRoot = expression;</code></pre>\n\nFeeding it an input like &quot;Orders with employee with address like '<em>abc</em>'&quot;, I would like to get back:\r<br />\n&quot;Orders [with employee (1)] [with address like '<em>abc</em>' (2)]&quot;\r<br />\n(1). connectionFilter: with &quot;employee&quot;  as table name\r<br />\n(2). string filter: with &quot;address&quot; as &quot;column&quot; and '<em>abc</em>' = stringQuery operator\r<br />\n<br />\nInstead I get: &quot;Orders [with employee (1)] [with address (2)] [like '<em>abc</em>' (3)]&quot;<br />\n<ol>\n<li>connectionFilter: with &quot;employee&quot;  as table name</li>\n<li>connectionFilter:: with &quot;address&quot; as &quot;table name&quot; and '<em>abc</em>' = stringQuery operator</li>\n<li>\nstringFilter: with &quot;like&quot; as &quot;column name&quot; and '<em>abc</em>' as stringQuery<br />\n</li>\n</ol>\nI know for a fact that tableName or columnName cannot contain predefined key terms (like &quot;like&quot;). \r<br />\n<br />\nHow can I enforce this rule in my grammar?  \r<br />\n",
    "PostedDate": "2015-06-22T09:43:47.18-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1431367",
    "ThreadId": "640296",
    "Html": "You have three identifier terminals, but Irony's tokenizer cannot choose for you between them.<br />\n<br />\nIf you use the grammar explorer and use the trace you will see how it tokenizes the string:<br />\n<pre><code>Orders       with employee with address like 'abc'\nrootTable    with table    with table   like string</code></pre>\n\nWhile you want:<br />\n<pre><code>rootTable    with table    with column  like string</code></pre>\n\nBut Irony can't decide for you if an identifier terminal is a <code>table</code> or <code>column</code>, you'll have to use one terminal and make the right production rules.<br />\n<br />\nSomething like this:<br />\n<pre><code>           StringLiteral STRING = new StringLiteral(&quot;string&quot;, &quot;'&quot;, StringOptions.AllowsDoubledQuote);\n            KeyTerm WITH = ToTerm(&quot;WITH&quot;);\n            KeyTerm LIKE = ToTerm(&quot;LIKE&quot;);\n            KeyTerm AND = ToTerm(&quot;AND&quot;);\n            KeyTerm OR = ToTerm(&quot;OR&quot;);\n            KeyTerm BY = ToTerm(&quot;BY&quot;);\n\n            NonTerminal expression = new NonTerminal(&quot;expression&quot;);\n\n            IdentifierTerminal id = new IdentifierTerminal(&quot;id&quot;);\n\n            NonTerminal filterList = new NonTerminal(&quot;filterList&quot;);\n            NonTerminal filter = new NonTerminal(&quot;filter&quot;);\n\n            NonTerminal connectionFilter = new NonTerminal(&quot;connectionFilter&quot;);\n\n            NonTerminal stringFilter = new NonTerminal(&quot;stringFilter&quot;);\n            NonTerminal stringQuery = new NonTerminal(&quot;stringQuery&quot;);\n            NonTerminal stringOperator = new NonTerminal(&quot;stringOperator&quot;);\n\n            var Column = new NonTerminal(&quot;Column&quot;, id);\n            var Table = new NonTerminal(&quot;Table&quot;, id);\n\n            connectionFilter.Rule = Column + BY + Table | WITH + Table;\n\n            stringFilter.Rule = Column + stringQuery\n                              | WITH + Column + stringQuery;\n\n            stringQuery.Rule = STRING\n                             | LIKE + STRING;\n\n            var linker = new NonTerminal(&quot;linker&quot;, AND | OR | Empty);\n\n            filterList.Rule = MakePlusRule(filterList, linker, filter);\n\n            filter.Rule = connectionFilter | stringFilter;\n\n            var RootTable = new NonTerminal(&quot;RootTable&quot;, id);\n\n            expression.Rule = RootTable + filterList;\n\n            \n\n            Root = expression;</code></pre>\n\n",
    "PostedDate": "2015-06-22T11:02:29.74-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1431377",
    "ThreadId": "640296",
    "Html": "Works like a charm. \r<br />\nThanks a lot! <br />\n",
    "PostedDate": "2015-06-22T11:44:05.52-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
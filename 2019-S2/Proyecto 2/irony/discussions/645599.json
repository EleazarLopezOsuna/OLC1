[
  {
    "Id": "1446366",
    "ThreadId": "645599",
    "Html": "The language I'm building a grammar for is generating a reduce-reduce conflict and I'm not sure how to read the conflict.  I'm assuming in this case I should insert a ReduceHere() call somewhere in my grammar to clear up the conflict but I lack the understanding currently to know where this goes and exactly why (I assume it to be a conflict between potential expressions using ++, +, -- and -).  The conflict message is as follows:<br />\n<blockquote>\nState S53 (Inadequate)<br />\n Reduce-reduce conflicts on inputs: ++ -- &lt; || &amp;&amp; ^ == != &gt; &lt;= &gt;= &lt;&lt; &gt;&gt; + - * / % in<br />\n Reduce items:<br />\n   Unary Expression -&gt; Unary Operator Primary Expression · [++ -- &lt; || &amp;&amp; ^ == != &gt; &lt;= &gt;= &lt;&lt; &gt;&gt; + - * / % in Semicolon Comma }]<br />\n   Expression -&gt; Primary Expression · [++ -- &lt; || &amp;&amp; ^ == != &gt; &lt;= &gt;= &lt;&lt; &gt;&gt; + - * / % in]<br />\n Transitions:<br />\n</blockquote>\nMy grammar includes operators common to C# such as ++, --, ==, !=, etc. as you can see.  I used the example C# grammar in irony as a starting point.  I actually ran into a number of conflicts initially, so I stripped the grammar down to a simplified version with the intention of slowly adding grammar parts back until I hit a conflict and then solving the conflict.  I'm hoping by better understanding this conflict and the proper solution I can apply that knowledge to future conflicts and not nag folks with questions ;).  In the current stripped down state the entire grammar is as follows:<br />\n<pre><code>using System;\nusing Irony.Parsing;\n\nnamespace Org.Edgerunner.MooSharp.Parser\n{\n    [Language(&quot;Moo#&quot;, &quot;1.0&quot;, &quot;The Moo# programming language, an extended version of the original Moo language&quot;)]\n    public class MooSharpGrammar : Irony.Parsing.Grammar\n    {\n        /// &lt;summary&gt;\n        /// Initializes a new instance of the &lt;see cref=&quot;MooSharpGrammar&quot;/&gt; class.\n        /// &lt;/summary&gt;\n        public MooSharpGrammar()\n            : base(false)\n        {\n            #region declarations\n            StringLiteral stringLiteral = MooTerminalFactory.CreateMooString(&quot;StringLiteral&quot;);\n            Irony.Parsing.NumberLiteral number = MooTerminalFactory.CreateMooNumber(&quot;Number&quot;);\n            ObjectLiteral objectLiteral = new ObjectLiteral(&quot;Object&quot;);\n            ErrorTerminal error = new ErrorTerminal(&quot;ErrorCode&quot;, typeof(string));\n            IdentifierTerminal identifier = MooTerminalFactory.CreateMooIdentifier(&quot;Identifier&quot;);\n\n            KeyTerm lcbr = ToTerm(&quot;{&quot;);\n            KeyTerm rcbr = ToTerm(&quot;}&quot;);\n            KeyTerm comma = ToTerm(&quot;,&quot;, &quot;Comma&quot;);\n            KeyTerm semi = ToTerm(&quot;;&quot;, &quot;Semicolon&quot;);\n            KeyTerm at = ToTerm(&quot;@&quot;, &quot;at&quot;);\n\n            CommentTerminal singleLineComment = new CommentTerminal(&quot;SingleLineComment&quot;, &quot;//&quot;, &quot;\\r&quot;, &quot;\\n&quot;, &quot;\\u2085&quot;, &quot;\\u2028&quot;, &quot;\\u2029&quot;);\n            CommentTerminal delimitedComment = new CommentTerminal(&quot;DelimitedComment&quot;, &quot;/*&quot;, &quot;*/&quot;);\n            NonGrammarTerminals.Add(singleLineComment);\n            NonGrammarTerminals.Add(delimitedComment);\n                        \n            var literal = new NonTerminal(&quot;Literal&quot;);\n            var incrOrDecr = new NonTerminal(&quot;Incr Or Decr&quot;);\n            var incrOrDecrOpt = new NonTerminal(&quot;Incr Or Decr Opt&quot;);\n            var preIncrDecrExpression = new NonTerminal(&quot;Pre Incr Decr Expression&quot;);\n            var postIncrDecrExpression = new NonTerminal(&quot;Post Incr Decr Expression&quot;);\n            var expression = new NonTerminal(&quot;Expression&quot;);\n            var primaryExpression = new NonTerminal(&quot;Primary Expression&quot;);\n            var listLiteral = new NonTerminal(&quot;List Literal&quot;);\n            var unaryOperator = new NonTerminal(&quot;Unary Operator&quot;);\n            var unaryExpression = new NonTerminal(&quot;Unary Expression&quot;);\n            var spliceExpression = new NonTerminal(&quot;Splice Expression&quot;);\n            var listMemberExpression = new NonTerminal(&quot;List Member Expression&quot;);\n            var listMemberExpressionListOpt = new NonTerminal(&quot;List Member Expression List Optional&quot;);\n            var binOpExpression = new NonTerminal(&quot;Binary Operation Expression&quot;);\n            var binOp = new NonTerminal(&quot;Binary Operator&quot;, &quot;operator symbol&quot;);\n            var statement = new NonTerminal(&quot;Statement&quot;);\n            var simpleStatement = new NonTerminal(&quot;Simple Statement&quot;);\n            var simpleStatementOpt = new NonTerminal(&quot;Simple Statement Optional&quot;);\n            var statementList = new NonTerminal(&quot;Statement List&quot;);\n            var CodeBody = new NonTerminal(&quot;Code Body&quot;);\n            #endregion\n\n            RegisterOperators(1, &quot;||&quot;);\n            RegisterOperators(2, &quot;&amp;&amp;&quot;);\n            RegisterOperators(4, &quot;^&quot;);\n            RegisterOperators(6, &quot;==&quot;, &quot;!=&quot;);\n            RegisterOperators(7, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;);\n            RegisterOperators(8, &quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;);\n            RegisterOperators(9, &quot;+&quot;, &quot;-&quot;);\n            RegisterOperators(10, &quot;*&quot;, &quot;/&quot;, &quot;%&quot;);\n            RegisterOperators(11, &quot;.&quot;, &quot;:&quot;, &quot;in&quot;, &quot;@&quot;);\n            RegisterOperators(12, &quot;++&quot;, &quot;--&quot;);\n            RegisterOperators(-3, &quot;=&quot;, &quot;+=&quot;, &quot;-=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;, &quot;&amp;=&quot;, &quot;|=&quot;, &quot;^=&quot;, &quot;&lt;&lt;=&quot;, &quot;&gt;&gt;=&quot;);\n            RegisterOperators(-2, &quot;?&quot;);\n\n            this.MarkPunctuation(&quot;;&quot;, &quot;,&quot;, &quot;(&quot;, &quot;)&quot;, &quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;);\n\n            Root = CodeBody;\n\n            expression.Rule = primaryExpression | binOpExpression;\n            \n            spliceExpression.Rule = at + expression;\n            listMemberExpression.Rule = spliceExpression | expression;\n            listMemberExpressionListOpt.Rule = MakeStarRule(listMemberExpressionListOpt, comma, listMemberExpression);\n            listLiteral.Rule = lcbr + listMemberExpressionListOpt + rcbr;\n            literal.Rule = stringLiteral | error | objectLiteral | number | &quot;true&quot; | &quot;false&quot; | listLiteral;\n            incrOrDecrOpt.Rule = Empty | ToTerm(&quot;++&quot;) | &quot;--&quot;;\n            incrOrDecr.Rule = ToTerm(&quot;++&quot;) | &quot;--&quot;;\n            preIncrDecrExpression.Rule = incrOrDecr + expression;\n            postIncrDecrExpression.Rule = expression + incrOrDecr;\n            binOp.Rule = ToTerm(&quot;&lt;&quot;) | &quot;||&quot; | &quot;&amp;&amp;&quot; | &quot;^&quot; | &quot;==&quot; | &quot;!=&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;in&quot;;\n            binOpExpression.Rule = expression + binOp + expression;\n            primaryExpression.Rule =\n                identifier\n                | unaryExpression\n                | preIncrDecrExpression\n                | postIncrDecrExpression\n                | literal;\n\n            unaryOperator.Rule = ToTerm(&quot;+&quot;) | &quot;-&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot;;\n            unaryExpression.Rule = unaryOperator + primaryExpression;\n        \n            simpleStatementOpt.Rule = expression | Empty;\n            simpleStatement.Rule = simpleStatementOpt + semi;\n            statement.Rule = simpleStatement;\n            statementList.Rule = MakePlusRule(statementList, null, statement);\n            CodeBody.Rule = Empty | statementList;\n        }\n    }\n}</code></pre>\n\n",
    "PostedDate": "2015-09-29T09:21:24.24-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1446372",
    "ThreadId": "645599",
    "Html": "Reduce-reduce means there's more than one way some sentence (code) can be parsed (this is called ambiguity). In this case there a sentence where the parser can't decide if the preceding part should be a <code>Expression</code> or a <code>Unary Expression</code>.\r<br />\n<br />\nI don't immediately see the problem, but the problematic state is hit with <code>+1++;</code>. However this shouldn't be a problem because <code>++</code> has a higher precedence than <code>+</code>.<br />\n",
    "PostedDate": "2015-09-29T10:47:16.79-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1446384",
    "ThreadId": "645599",
    "Html": "Thank you, that makes sense.  I thought it had something to do with that, but every sample I tried parsing came out as I would expect (I'm guessing because of operator precedence as you mention).  Am I right to assume that a call to ReduceHere() in the right spot would solve the conflict?<br />\n",
    "PostedDate": "2015-09-29T11:46:09.963-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1446386",
    "ThreadId": "645599",
    "Html": "So this may not be the best approach, but I just tried inserting a ReduceHere() call throughout the expression and unary expression rules and found the following change made the grammar conflict go away:<br />\n<blockquote>\nexpression.Rule = primaryExpression + ReduceHere() | binOpExpression;<br />\n</blockquote>\nAlso I noticed that the expression +1++ was being parsed as (+1)++ and now it is being parsed as +(1++).  I'm not going to pretend to fully understand why the ReduceHere() call fixes it when placed in that particular spot, but that should still help me debug further reduce-reduce conflicts.  Thanks again for the help.<br />\n",
    "PostedDate": "2015-09-29T11:57:08.687-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": "2015-09-29T13:00:54.623-07:00"
  }
]
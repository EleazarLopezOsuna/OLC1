[
  {
    "Id": "665214",
    "ThreadId": "270865",
    "Html": "\r\n<p>hi,</p>\r\n<p>i'm trying to parse SQL.</p>\r\n<p>i'm having a problem with the &quot;NOT LIKE&quot; operator.</p>\r\n<p>i'm using &quot;SQL, version 89&quot;.</p>\r\n<p>this sentence is parsed as it should</p>\r\n<p>SELECT col FROM tbl WHERE var1 &lt;&gt; '2' or var2 LIKE 'VIR*' and var3 = '5'</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |--------------- LIKE ---------------|<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |------OR------|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |----AND----|<br>\r\n&nbsp;|--- &lt;&gt; ---|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VIR*&nbsp;&nbsp;&nbsp;&nbsp; |--- = ---|\r\n<br>\r\nvar1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '2' &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n &nbsp;var3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '5'</p>\r\n<p>but this not</p>\r\n<p>SELECT col FROM tbl WHERE var1 &lt;&gt; '2' or var2 NOT LIKE 'VIR*' and var3 = '5'</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |---------------OR---------------|<br>\r\n&nbsp;|--- &lt;&gt; ---|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |----NOT LIKE----|<br>\r\nvar1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; '2'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |----AND----|<br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;VIR*&nbsp;&nbsp;&nbsp;&nbsp;\r\n |--- = ---|&nbsp; <br>\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n &nbsp; var3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '5'</p>\r\n<p>&nbsp;</p>\r\n<p><span>If</span> <span>you have an idea...</span></p>\r\n<p>Thanks a lot!</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2011-08-30T01:33:56.31-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "665510",
    "ThreadId": "270865",
    "Html": "<p>yeah, it's a problem. BTW, I think even the first statement is parsed incorrectly.</p>\r\n<p>The problem is with correct precedence handling - assigning/inheriting proper prec value to BinOp instances - it is not transient because of composite operators: \"NOT LIKE\" and \"NOT IN\", and that's what makes this grammar special. Looks like Irony is missing a proper facility for handling this corner case.</p>\r\n<p>I\"m looking into this, can't offer quick fix for now.&nbsp;</p>",
    "PostedDate": "2011-08-30T14:41:40.32-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "665604",
    "ThreadId": "270865",
    "Html": "<p>Here's a temp fix. Change the last lines of SQL grammar to the following:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>      <span style=\"color: green;\">//Operators</span>\r\n      RegisterOperators(10, <span style=\"color: #a31515;\">\"*\"</span>, <span style=\"color: #a31515;\">\"/\"</span>, <span style=\"color: #a31515;\">\"%\"</span>); \r\n      RegisterOperators(9, <span style=\"color: #a31515;\">\"+\"</span>, <span style=\"color: #a31515;\">\"-\"</span>);\r\n      RegisterOperators(8, <span style=\"color: #a31515;\">\"=\"</span>, <span style=\"color: #a31515;\">\"&gt;\"</span>, <span style=\"color: #a31515;\">\"&lt;\"</span>, <span style=\"color: #a31515;\">\"&gt;=\"</span>, <span style=\"color: #a31515;\">\"&lt;=\"</span>, <span style=\"color: #a31515;\">\"&lt;&gt;\"</span>, <span style=\"color: #a31515;\">\"!=\"</span>, <span style=\"color: #a31515;\">\"!&lt;\"</span>, <span style=\"color: #a31515;\">\"!&gt;\"</span>, <span style=\"color: #a31515;\">\"LIKE\"</span>, <span style=\"color: #a31515;\">\"IN\"</span>);\r\n      RegisterOperators(7, <span style=\"color: #a31515;\">\"^\"</span>, <span style=\"color: #a31515;\">\"&amp;\"</span>, <span style=\"color: #a31515;\">\"|\"</span>);\r\n      RegisterOperators(6, NOT); \r\n      RegisterOperators(5, <span style=\"color: #a31515;\">\"AND\"</span>);\r\n      RegisterOperators(4, <span style=\"color: #a31515;\">\"OR\"</span>);\r\n\r\n      MarkPunctuation(<span style=\"color: #a31515;\">\",\"</span>, <span style=\"color: #a31515;\">\"(\"</span>, <span style=\"color: #a31515;\">\")\"</span>);\r\n      MarkPunctuation(asOpt, semiOpt);\r\n      <span style=\"color: green;\">//Note: we cannot declare binOp as transient because it includes operators \"NOT LIKE\", \"NOT IN\" consisting of two tokens. </span>\r\n      <span style=\"color: green;\">// Transient non-terminals cannot have more than one non-punctuation child nodes.</span>\r\n      <span style=\"color: green;\">// Instead, we mark binOp as Operator, so that it inherits precedence value from it's children, and this precedence is used</span>\r\n      <span style=\"color: green;\">// in conflict resolution when binOp node is sitting on the stack</span>\r\n      <span style=\"color: blue;\">base</span>.MarkTransient(stmt, term, asOpt, aliasOpt, stmtLine, expression, unOp, tuple);\r\n      binOp.SetFlag(TermFlags.IsOperator);&nbsp;</pre>\r\n<pre>} //end of constructor\r\n\r\n</pre>\r\n</div>\r\n</p>\r\n<p>Also, in CoreParser.cs, replace the following method:</p>\r\n<p>&nbsp;</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>    <span style=\"color: blue;\">private</span> ParseTreeNode ReduceRegularNode(ParserAction action) {\r\n      <span style=\"color: blue;\">var</span> childCount = action.ReduceProduction.RValues.Count; \r\n      <span style=\"color: blue;\">int</span> firstChildIndex = Context.ParserStack.Count - childCount;\r\n      <span style=\"color: blue;\">var</span> span = ComputeNewNodeSpan(childCount);\r\n      <span style=\"color: blue;\">var</span> newNode = <span style=\"color: blue;\">new</span> ParseTreeNode(action.ReduceProduction, span);\r\n      <span style=\"color: blue;\">var</span> newIsOp = newNode.Term.Flags.HasFlag(TermFlags.IsOperator); \r\n      <span style=\"color: blue;\">for</span>(<span style=\"color: blue;\">int</span> i = 0; i &lt; childCount; i++) {\r\n        <span style=\"color: blue;\">var</span> childNode = Context.ParserStack[firstChildIndex + i];\r\n        <span style=\"color: blue;\">if</span>(ShouldSkipChildNode(childNode))\r\n          <span style=\"color: blue;\">continue</span>; <span style=\"color: green;\">//skip punctuation or empty transient nodes</span>\r\n        CheckCreateAstNode(childNode); <span style=\"color: green;\">//AST nodes for lists and for terminals are created here </span>\r\n        <span style=\"color: green;\">//Inherit precedence and associativity, to cover a standard case: BinOp-&gt;+|-|*|/; </span>\r\n        <span style=\"color: green;\">// BinOp node should inherit precedence from underlying operator symbol. Keep in mind special case of SQL operator \"NOT LIKE\" which consists</span>\r\n        <span style=\"color: green;\">// of 2 tokens. We therefore inherit \"max\" precedence from any children</span>\r\n        <span style=\"color: blue;\">if</span>(newIsOp &amp;&amp; childNode.Precedence != BnfTerm.NoPrecedence &amp;&amp; childNode.Precedence &gt; newNode.Precedence) {\r\n          newNode.Precedence = childNode.Precedence;\r\n          newNode.Associativity = childNode.Associativity;\r\n        }\r\n        newNode.ChildNodes.Add(childNode);\r\n      }<span style=\"color: green;\">//for i</span>\r\n      <span style=\"color: blue;\">return</span> newNode;     \r\n    }\r\n\r\n</pre>\r\n</div>\r\n</p>\r\n<p>That should fix it. I will submit the fix in the next code drop. Also, I think of another solution for situation like this (allowing terminals that represent sequence of keywords with arbitrary whitespace in between: \"NOT LIKE\") - that would solve the problem</p>\r\n<p>Roman</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-08-30T21:21:46.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "665751",
    "ThreadId": "270865",
    "Html": "<p><span style=\"background-color: #ebeff9;\" title=\"merci beaucoup, ca marche parfaitement.\">thank you very much, it works perfectly.</span></p>",
    "PostedDate": "2011-08-31T06:18:30.65-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
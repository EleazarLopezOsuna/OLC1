[
  {
    "Id": "253185",
    "ThreadId": "74018",
    "Html": "<p>Hi Roman,</p>\r\n<p>I have just found Irony. Looks like a really promising project!</p>\r\n<p>Following the previous discussion &quot;Intext macro&quot;, but not strictly related to the same thing, I was looking to find how to implement a macro expansion like it's used in some x86 asm assemblers :</p>\r\n<p>&nbsp;</p>\r\n<pre>mymacro macro param1, param2 <br>&amp;param1:\r\n    mov eax, &amp;param2    <br>endm\r\n\r\n.code\r\nmymacro A , ebx\r\ninc [eax]\r\nret\r\n</pre>\r\n<p>When macro expansion is done :</p>\r\n<pre>.code<br>A:<br>mov eax, ebx<br>inc [eax]<br>ret<br></pre>\r\n<p>So mymacro is part of a kind of &quot;pre-procsesing stage&quot;, where all macros are expanded on a first pass. The macro can perform complex operations, like for/loop/if/else... etc, much more than what we use to find in C/C++ preprocessor. It's a kind of language inside a language.</p>\r\n<p>Once the macro expansion is done, on the second pass, we are able to parse asm instructions and translate them to opcodes.</p>\r\n<p>Is such a feature is available or might be possible (in the future?) with Irony?</p>\r\n<p>I'm not talking about something that do the macro expansion for me. The problem is more if Irony is able to handle this with addittionnal code (without modifying the &quot;lexer/parser&quot; core code?).</p>\r\n<p>Thanks!</p>",
    "PostedDate": "2009-11-04T03:02:39.05-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "253575",
    "ThreadId": "74018",
    "Html": "<p>Hard to say, without seeing more of the macro language, but I'm afraid there's no support in Irony for this so far.</p>\r\n<p>If it were for simple &quot;injection with param-replacement&quot; macro like in c, I would suggets the following path. First, you need to have a non-terminal for macro definition. When this NonTerminal is reduced (parse node created), a custom hooked code should grab the macro definition and store it in some convenient form, in some list - which should be available to macro expander - see below.</p>\r\n<p>Then to expand the defined macros, I think the easiest solution would be special Token filter. It should intercept the token stream, and if an identifier token matches the name of the macro, then expander jumps into action. It should read&nbsp;macro parameters from input stream. After&nbsp;replicating tokens from macro definition body and replacing parameters the filter/expander passes the&nbsp;resulting expansion tokens down the token stream.</p>\r\n<p>That would be my plan if I did this now. Hope to get to macros soon, they are on my to-do list</p>\r\n<p>Roman</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-11-04T19:32:55.083-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "253708",
    "ThreadId": "74018",
    "Html": "<p>Thanks for your prompt reply!</p>\r\n<p>FilterToken is indeed nice but probably not enough powerful to handle such macro expansion.</p>\r\n<p>I tried to play with Irony and did a simple macro expansion implementation like this :</p>\r\n<p>- When a MacroDeclaration is found in the parser (just after a reduce), call a callback to compile it (this call back is language dependent). The Callback should have access to a partial tree (i did a test with the ParseStack).</p>\r\n<p>- When a MacroCall reduce is found, call a callback that will expand from a previous compiled MacroDeclaration and modify position and text of Parser.Context.SourceStream. And notify the parser to not add the MacroCall TreeNode to the stack</p>\r\n<p>I have slightly modified the Irony source (add public members for SourceStream and ParserStack on Context, add ReduceEvent on Parser, call ReduceEvent from CoreParser in ExecuteReduce).</p>\r\n<p>The following code is performing a double macro expansion. First macro called is my_macro, that contains another macro definition that is in turn called by my_submacro.</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>        <span style=\"color:Blue\">static</span> <span style=\"color:Blue\">void</span> Main()<br>        {<br>            AsmGrammar g = <span style=\"color:Blue\">new</span> AsmGrammar();  <br>            Parser parser = <span style=\"color:Blue\">new</span> Parser(g);<br>            parser.ReduceEvent += parser_ReduceEvent;<br>            <span style=\"color:Blue\">var</span> textToParse =<br><span style=\"color:#A31515\">@&quot;my_macro MACRO<br>    my_submacro MACRO<br>        test_inline<br>    endm<br>endm<br>my_macro<br>my_submacro<br>end<br>&quot;</span>;<br>            ParseTree t = parser.Parse(textToParse);<br>            Console.WriteLine(t.ToXml());  <br>        }<br><br>        <span style=\"color:Blue\">static</span> Dictionary&lt;<span style=\"color:Blue\">string</span>, ParseTreeNode&gt; mapMacroNameToTreeNode = <span style=\"color:Blue\">new</span> Dictionary&lt;<span style=\"color:Blue\">string</span>, ParseTreeNode&gt;();<br><br><br>        <span style=\"color:Blue\">static</span> <span style=\"color:Blue\">void</span> parser_ReduceEvent(<span style=\"color:Blue\">object</span> sender, ParserEventArgs e)<br>        {<br>            Parser parser = (Parser)sender;<br><br>            <span style=\"color:Green\">// Handle Macro declaration while parsing</span><br>            <span style=\"color:Blue\">if</span> (e.Node.Term.Name == <span style=\"color:#A31515\">&quot;MacroDir&quot;</span>)<br>            {<br>                <span style=\"color:Blue\">bool</span> isTopLevelMacro = <span style=\"color:Blue\">true</span>;<br>                <span style=\"color:Green\">// First child of MacroDir is Macro name</span><br>                <span style=\"color:Blue\">for</span>(<span style=\"color:Blue\">int</span> i = parser.Context.ParserStack.Count-1; i &gt;= 0; i--) {<br>                    BnfTerm term = parser.Context.ParserStack[i].Term;<br>                    <span style=\"color:Blue\">if</span> (term != <span style=\"color:Blue\">null</span> &amp;&amp; term.Name == <span style=\"color:#A31515\">&quot;MacroStmtList&quot;</span>)<br>                    {<br>                        isTopLevelMacro = <span style=\"color:Blue\">false</span>;<br>                        <span style=\"color:Blue\">break</span>;<br>                    }                    <br>                }<br>                <span style=\"color:Blue\">if</span> (isTopLevelMacro)<br>                {<br>                    mapMacroNameToTreeNode.Add(e.Node.FirstChild.Token.ValueString, e.Node);<br>                }<br>            } <span style=\"color:Blue\">else</span> <span style=\"color:Green\">// Perform Macro expansion while parsing</span><br>            <span style=\"color:Blue\">if</span> (e.Node.Term.Name == <span style=\"color:#A31515\">&quot;MacroCall&quot;</span>)<br>            {<br>                SourceStream sourceStream = parser.Context.SourceStream;<br>                ParseTreeNode macroCallNode = e.Node;<br><br>                <span style=\"color:Blue\">string</span> macroName = e.Node.FirstChild.Token.ValueString;<br><br>                ParseTreeNode macroDeclaration;<br>                <span style=\"color:Blue\">if</span> (mapMacroNameToTreeNode.TryGetValue(macroName, <span style=\"color:Blue\">out</span> macroDeclaration))<br>                {<br>                    ParseTreeNode macroBodyNode = FindChildTreeNodeByTermName(macroDeclaration, <span style=\"color:#A31515\">&quot;MacroBody&quot;</span>);<br><br>                    <span style=\"color:Blue\">string</span> expandedText = sourceStream.Text.Substring(macroBodyNode.Span.Location.Position,<br>                                                                      macroBodyNode.Span.Length);<br><br>                    <span style=\"color:Green\">// Get MacroCall Span</span><br>                    <span style=\"color:Blue\">int</span> cutFrom = macroCallNode.Span.Location.Position;<br>                    <span style=\"color:Blue\">int</span> cutLenght = macroCallNode.Span.Length;<br>                    <span style=\"color:Blue\">int</span> cutTo = macroCallNode.Span.EndPosition;<br><br>                    <span style=\"color:Green\">// Substitute MacroCall with a new MacroDir</span><br>                    <span style=\"color:Green\">// The exapnded text is here hardcoded for the sample, but it should be generated from mytoto previous MacroDir</span><br>                    StringBuilder newTextBuilder = <span style=\"color:Blue\">new</span> StringBuilder(sourceStream.Text.Substring(0, cutFrom));<br><br>                    <span style=\"color:Green\">// Add expanded text</span><br>                    newTextBuilder.Append(expandedText);<br><br>                    <span style=\"color:Green\">// Add Tail</span><br>                    newTextBuilder.Append(sourceStream.Text.Substring(cutFrom + cutLenght,<br>                                                                      sourceStream.Text.Length - cutTo));<br><br>                    <span style=\"color:Green\">// Reset location to start of MacroCall</span><br>                    sourceStream.Location = <span style=\"color:Blue\">new</span> SourceLocation(cutFrom, macroCallNode.Span.Location.Line, macroCallNode.Span.Location.Column);<br>                    sourceStream.Text = newTextBuilder.ToString();<br><br>                    <span style=\"color:Green\">// Set NodeIgnore to true =&gt; macroCallNode will not be appended to the stack</span><br>                    e.NodeIgnore = <span style=\"color:Blue\">true</span>;<br>                }<br>            }<br>        }<br></pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>The only things i have modified in CoreParser.ExecuteReduce is handling the NodeIgnore in order to not push the TreeNode if the parser call back has done some expansion:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>      <span style=\"color:Green\">// Shift to new state (LALR) or push new node into input stack(NLALR, NLALRT)</span><br>      <span style=\"color:Blue\">if</span> (Data.ParseMethod == ParseMethod.Lalr) {<br><br>        <span style=\"color:Green\">// Call Parser.OnReduceEvent</span><br>        ParserEventArgs parserEvent = <span style=\"color:Blue\">new</span> ParserEventArgs(newNode);<br>        Parser.OnReduceEvent(parserEvent);<br><br>        <span style=\"color:Green\">// If Node should be ignored, than don't add it to the parser stack (macro expansion is probably in action)</span><br>        <span style=\"color:Blue\">if</span> (!parserEvent.NodeIgnore)<br>        {<br>            <span style=\"color:Green\">//execute shift over non-terminal</span><br>            <span style=\"color:Blue\">var</span> action = Context.CurrentParserState.Actions[reduceProduction.LValue];<br>            Context.ParserStack.Push(newNode, action.NewState);<br>            Context.CurrentParserState = action.NewState;<br>        }<br>      }<br></pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>The resulting text parsed effectively by the parser and generating a tree is in the end :</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">var</span> expandedText =<br><span style=\"color:#A31515\">@&quot;my_macro MACRO<br>    my_submacro MACRO<br>        test_inline<br>    endm<br>endm<br>my_submacro MACRO<br>        test_inline<br>    endm<br>test_inline<br>end<br>&quot;</span>;<br></pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>From this simple example, it seems to be quite easy to add expansion macro, although it's not probably a robust solution. Anyway, the most important thing is to have a macro expansion that have access to the current TreeNode stack in order to perform precompilation while parsing.</p>\r\n<p>Hope that this macro expansion could help someone.</p>\r\n<p>Irony is impressive! I guess that the more we will be able to plug some &quot;callback&quot; in the scanner-parser chain, the more Irony will be flexible to implement complex things!</p>\r\n<p>([Edit]Although, the &quot;callback&quot; feature doesn't need to be plugged in the Parser, but could be plugged in the grammar, with action attached (like ANTLR actions) to a NonTerminal element event (OnReduce...etc.).[/Edit])</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-11-05T03:54:41.56-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "254415",
    "ThreadId": "74018",
    "Html": "<p>Kudos! you did it - congratulations!</p>\r\n<p>A bit hacky, but as long as it works for you - great!</p>\r\n<p>Reduce event on NonTerminals - good point, will see how to do this. There is already parser even ParserAction or something that you can use (looks like you didn't, you added Reduce event), but probably providing Reduce action at non-terminal level would be useful as well.</p>\r\n<p>As for the details of your solution to macro challenge - I've closely looked at it trying to see if I can borrow something for general macro support. I see one big trouble - when expanding a macro, you modify the source text in the scanner - you prepend the expanded macro body to the remaining text. I think this might be a problem. The process might start generating a lot of new BIG strings, and thus garbage collector must collect much more frequently. Just as an example: let's say your program defines a simple macro symbol like &quot;YES = 1&quot; at the beginning of 20k source file, and then starts using the symbol heavily. On each occurrence of the symbol, macro expander would create a copy of substantial part of source string, prepend it with &quot;1&quot;, and place it into the source. Quite a garbage. Better solution would be I think to prepend source with tokens, copy of body expansion tokens. Expander can push it to input buffer of parser. So I still think that TokenFilter is a right place for generic implementation of macro processor - in this case it can be optionally added when needed. Token filter has access to all information necessary - even ParserStack that you use in your code to detect top-level definition. I really hope macroscan be done generically without such extremes - it is hard to generalize this parser stack lookup. No criticism, just thinking...</p>\r\n<p>Your expander does not do any parameter substitution - that should be part of any macro processor. I understand that's not that difficult to add to your code, but that would complicate things a bit more.</p>\r\n<p>One unusual thing I discovered in your example is nested macro definitions. I never thought about this. It is then a bit puzzling for me - how this works at all. Normally in macro systems like c, the body of the macro is just a sequence of tokens which does not have any programmatic structure until it is actually expanded in particular place in source. It means parser reads macro body in definition as plane stream of tokens until some predefined macro end token. In your macro system, we may find a nested macro definition inside macro body - it means macro body should be parsed as well, and we should have a grammatic definition of its structure... you don't provide your grammar, but it would be really interesting to see the arrangements. Does your macro system allows defining macro body as just unstructured set of tokens? really interesting...</p>\r\n<p>Keep good hacking and come back for more - I might get to implementing macro support some time soon. Although I'm not sure it would support nested definitions... :)<br>Thank you for adding your rating and review. I think your macro implementation is in fact a testimony that Irony is easy enough to undestand and even hack into!</p>\r\n<p>Roman</p>",
    "PostedDate": "2009-11-06T16:50:02.98-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "254624",
    "ThreadId": "74018",
    "Html": "<p>Back on the subject.</p>\r\n<p>For the performance issue, i guess it's possible to combine two technique. A fast one, relying on the TokenFilter, when the token to expand is just a single var. Another one, more or less complex that inject source code.</p>\r\n<p>The first version of my test grammar was mixing preprocessing and 2nd pass grammar (the real asm instruction &quot;mov eax, edx&quot;...etc.). But as you have noticed, i should be able to enter any text inside a macro, and this text is combined with macro statements.</p>\r\n<p>Well, right now, i'm trying to implement a grammar with Irony, supporting unstructured tokens... but i'm stuck with reduce conflicts with the macro declaration. If i don't resolve this, i will post the full source (although this is just a grammar test).</p>\r\n<p>To handle unstructured tokens, i have to keep all whitespaces analysed... (setting WhitespaceChars = &quot;&quot;;) and i don't know if Irony is able to handle this correctly... (and i'm not sure to handle it correctly too.... damn it).</p>\r\n<p>I'm trying to combine preprocess directives and unstructured tokens like this ( i tried to do something similar to ANTLR C <a href=\"http://www.antlr.org/grammar/1166665121622/Cpp.tar\">preprocessor grammar file</a> )</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre>            Preprocess.Rule = PreprocessList;<br><br>            PreprocessList.Rule = MakeStarRule(PreprocessList, <span style=\"color:blue\">null</span>, ProcLine);<br><br>            ProcLine.Rule = PreprocessDir | TokenLine;<br><br>            Token.Rule = WS<br>                            | identifier<br>                            | OtherKeywords<br>                            | number<br>                            | LBR | RBR | LBP | RBP<br>                            | COMMA<br>                            | POINT<br>                            | COLON<br>                            ;<br>            Tokens.Rule = MakeStarRule(Tokens, <span style=\"color:blue\">null</span>, Token);<br>            TokenLine.Rule = Tokens + PreferShiftHere() + NL;<br><br>            OtherKeywords.Rule = ToTerm(<span style=\"color:#a31515\">&quot;mov&quot;</span>) | <span style=\"color:#a31515\">&quot;inc&quot;</span> | <span style=\"color:#a31515\">&quot;eax&quot;</span> | <span style=\"color:#a31515\">&quot;ebx&quot;</span> | <span style=\"color:#a31515\">&quot;ecx&quot;</span> | <span style=\"color:#a31515\">&quot;end&quot;</span> | <span style=\"color:#a31515\">&quot;jmp&quot;</span> | <span style=\"color:#a31515\">&quot;.code&quot;</span> | <span style=\"color:#a31515\">&quot;.model&quot;</span> | <span style=\"color:#a31515\">&quot;.data&quot;</span>;<br><br>            PreprocessDir.Rule = MacroDir;<br><br>            <span style=\"color:green\">//macroDir</span><br>            <span style=\"color:green\">// id MACRO [[ macroParmList ]] ;;</span><br>            <span style=\"color:green\">//macroBody</span><br>            <span style=\"color:green\">//ENDM ;;</span><br>            MacroDir.Rule = identifier + WSP + <span style=\"color:#a31515\">&quot;MACRO&quot;</span>  +  MacroParmListOpt + WSS + NL<br>                + MacroBody<br>                + <span style=\"color:#a31515\">&quot;ENDM&quot;</span> + WSS + NL;<br></pre>\r\n</div>\r\n<p>WS is a whitespace. WSP is WS+, WSS is WS*.</p>\r\n<p>I have 4 or 5 shift conflicts in the grammar and i get stuck on any line that is starting with an identifier and is not a macro. Irony is waiting for a &quot;macro&quot; keyword... i tried to put PreferShiftHere() hint just before the &quot;macro&quot; keyword, but it didn't do anything...</p>\r\n<p>Have you ever tried to write a grammar that has to handle whitespaces explicitly?</p>\r\n<p>About the asm macro, yep, they are more complex than c preprocessor directives, and they even allow to perform a double expansion in one time&nbsp; : on the inline place and on the previous line. For example with the following macro declaration :</p>\r\n<pre>mymacro macro \r\n.data \r\nmylabel:    dd 0\r\n.code\r\n    mov eax, edx\r\n    exitm &lt;ecx&gt;\r\nendm\r\n\r\n.code\r\n   mov mymacro(), ebx\r\n</pre>\r\n<p>you get the following preprocessed output:</p>\r\n<pre>.code<br>.data <br>mylabel:    dd 0<br>.code<br>   mov eax, edx<br>   mov ecx, ebx<br></pre>\r\n<p>The &lt;exitm&gt; directive is telling that the macro is a macro function, and the text between the &lt;&gt; is the inline text replacement, while the text in the macro body is inserted just before the line where the macro function is called.. So in terms of macro expansion, is not so simple than i expected in Irony... The particularity of the asm grammar is that it is strongly working on a line basis... With the unstructure tokens, i'm not sure to know how to declare this in Irony.</p>\r\n<p>As for the macro expansion feature in Irony, i'm not sure you have to develop something in particular, or just some helper class (like you did for terminals) to help macro expansion work... although you could provide a standard C preprocessor as a separate grammar example in irony samples. But be careful to not consider c preprocessor as the only macro system around (although, i'm sure you don't!) . Think of the macro expansion like a templatizer system, and the templatizer could have a complex grammar to handle loop, repeat, conditionnals... on text expansion.</p>\r\n<p>Oh, but one thing that you'll have probably to provide for any macro expansion system is a way to generate syntax errors with correct line number...</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-11-07T16:15:32.617-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "254641",
    "ThreadId": "74018",
    "Html": "<p>One quick advice, &quot;identity&quot; rules might be a source of conflicts;&nbsp; you have rule:</p>\r\n<p>PreprocessDir.Rule = MacroDir;</p>\r\n<p>when you say PreprocessorDir is the same as MacroDir.</p>\r\n<p>Try removing PreprocessorDir and use MacroDir instead</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-11-07T18:47:34.133-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "255500",
    "ThreadId": "74018",
    "Html": "<p>The remove of &quot;identity&quot; definition doesn't help. Here is the simple asm grammar i'm using (that contains many shift-reduce conflicts, due to whitespaces and identifier/macro definition) and the test that failed.</p>\r\n<p>If you could have a look, it would be great!</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">using</span> System;\r\n<span style=\"color:Blue\">using</span> Irony.Parsing;\r\n\r\n<span style=\"color:Blue\">namespace</span> IronAsm\r\n{\r\n    [Language(<span style=\"color:#A31515\">&quot;IronAsm&quot;</span>, <span style=\"color:#A31515\">&quot;1.0&quot;</span>, <span style=\"color:#A31515\">&quot;x86 MASM assembler&quot;</span>)]\r\n    <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> AsmGrammar : Grammar\r\n    {\r\n        <span style=\"color:Blue\">public</span> AsmGrammar() : <span style=\"color:Blue\">base</span>(<span style=\"color:Blue\">false</span>)\r\n        {\r\n            GrammarComments = <span style=\"color:#A31515\">@&quot;Simple MASM parser test.&quot;</span>;\r\n\r\n            <span style=\"color:Green\">// ----------------------------------------------------------------------------------------------------------</span>\r\n            <span style=\"color:Green\">// Tokens</span>\r\n            <span style=\"color:Green\">// ----------------------------------------------------------------------------------------------------------</span>\r\n            <span style=\"color:Blue\">var</span> NUMBER = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;number&quot;</span>);\r\n            NUMBER.DefaultIntTypes = <span style=\"color:Blue\">new</span> TypeCode[] { TypeCode.Single, TypeCode.Int32, TypeCode.Int64 };\r\n\r\n            <span style=\"color:Blue\">var</span> TEXT_LITERAL = <span style=\"color:Blue\">new</span> StringLiteral(<span style=\"color:#A31515\">&quot;String&quot;</span>, <span style=\"color:#A31515\">&quot;&lt;&quot;</span>, <span style=\"color:#A31515\">&quot;&gt;&quot;</span>, StringFlags.AllowsAllEscapes);\r\n\r\n            <span style=\"color:Blue\">var</span> IDENTIFIER = <span style=\"color:Blue\">new</span> IdentifierTerminal(<span style=\"color:#A31515\">&quot;Identifier&quot;</span>, <span style=\"color:#A31515\">&quot;_$?@&quot;</span>, <span style=\"color:#A31515\">&quot;_$?@&quot;</span>);\r\n\r\n            <span style=\"color:Blue\">var</span> COMMA = ToTerm(<span style=\"color:#A31515\">&quot;,&quot;</span>,<span style=\"color:#A31515\">&quot;Comma&quot;</span>);\r\n\r\n            <span style=\"color:Blue\">var</span> POINT = ToTerm(<span style=\"color:#A31515\">&quot;.&quot;</span>, <span style=\"color:#A31515\">&quot;Point&quot;</span>);\r\n\r\n            <span style=\"color:Blue\">var</span> WS = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Whitespace&quot;</span>);\r\n            WS.Rule = ToTerm(<span style=\"color:#A31515\">&quot; &quot;</span>) | <span style=\"color:#A31515\">&quot;\\t&quot;</span>;\r\n            <span style=\"color:Blue\">var</span> WSP = WS.Plus();\r\n            <span style=\"color:Blue\">var</span> WSS = WS.Star();\r\n\r\n            <span style=\"color:Blue\">var</span> LBR = ToTerm(<span style=\"color:#A31515\">&quot;[&quot;</span>);\r\n            LBR.Options = TermOptions.IsOpenBrace;\r\n\r\n            <span style=\"color:Blue\">var</span> RBR = ToTerm(<span style=\"color:#A31515\">&quot;]&quot;</span>);\r\n            RBR.Options = TermOptions.IsCloseBrace;\r\n\r\n            <span style=\"color:Blue\">var</span> LBP = ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>);\r\n            LBP.Options = TermOptions.IsOpenBrace;\r\n\r\n            <span style=\"color:Blue\">var</span> RBP = ToTerm(<span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n            RBP.Options = TermOptions.IsCloseBrace;\r\n            \r\n            <span style=\"color:Blue\">var</span> COLON = ToTerm(<span style=\"color:#A31515\">&quot;:&quot;</span>, <span style=\"color:#A31515\">&quot;Colon&quot;</span>);\r\n\r\n            <span style=\"color:Green\">// NewLine is explicitly handle in the grammar</span>\r\n            <span style=\"color:Blue\">var</span> NL = NewLine;\r\n\r\n            <span style=\"color:Green\">// Comment</span>\r\n            <span style=\"color:Blue\">var</span> comment = <span style=\"color:Blue\">new</span> CommentTerminal(<span style=\"color:#A31515\">&quot;comment&quot;</span>, <span style=\"color:#A31515\">&quot;;&quot;</span>, <span style=\"color:#A31515\">&quot;\\n&quot;</span>, <span style=\"color:#A31515\">&quot;\\r&quot;</span>, <span style=\"color:#A31515\">&quot;\\u2085&quot;</span>, <span style=\"color:#A31515\">&quot;\\u2028&quot;</span>, <span style=\"color:#A31515\">&quot;\\u2029&quot;</span>);\r\n            NonGrammarTerminals.Add(comment);\r\n\r\n            <span style=\"color:Green\">// Set Whitespace no empty string. We handle whitspace in grammar to keep the unstructured tokens organized</span>\r\n            WhitespaceChars = <span style=\"color:#A31515\">&quot;&quot;</span>;\r\n\r\n            <span style=\"color:Green\">// No delimiters (same for unstructured tokens)</span>\r\n            Delimiters = <span style=\"color:#A31515\">&quot;&quot;</span>;\r\n\r\n            <span style=\"color:Green\">// ----------------------------------------------------------------------------------------------------------</span>\r\n            <span style=\"color:Green\">// Non Terminals</span>\r\n            <span style=\"color:Green\">// ----------------------------------------------------------------------------------------------------------</span>\r\n\r\n            <span style=\"color:Green\">//var PreprocessDir = new NonTerminal(&quot;PreprocessDir&quot;);</span>\r\n            <span style=\"color:Green\">// var TextLine = new NonTerminal(&quot;TextLine&quot;);</span>\r\n            <span style=\"color:Blue\">var</span> MacroDir = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;MacroDir&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> MacroParmList = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;MacroParmList&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> MacroParmListOpt = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;MacroParmListOpt&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> MacroBody = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;MacroBody&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> MacroParm = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;MacroParm&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> MacroStmtList = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;MacroStmtList&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> MacroStmt = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;MacroStmt&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> ParmTypeOptional = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;ParmTypeOptional&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> ParmType = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;ParmType&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> Exitm = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Exitm&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> ExitmOptional = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;ExitmOptional&quot;</span>);\r\n            <span style=\"color:Green\">//var MacroCall = new NonTerminal(&quot;MacroCall&quot;);</span>\r\n            <span style=\"color:Green\">//var MacroArgList = new NonTerminal(&quot;MacroArgList&quot;);</span>\r\n            <span style=\"color:Green\">//var MacroArgListOptional = new NonTerminal(&quot;MacroArgListOptional&quot;);</span>\r\n            <span style=\"color:Green\">//var MacroArg = new NonTerminal(&quot;MacroArg&quot;);</span>\r\n            <span style=\"color:Blue\">var</span> NonMacroKeywords = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;OtherKeywords&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> PreprocessLine = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;ProcLine&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> PreprocessList = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;PreprocessList&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> UnStructuredToken = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;UnStructuredToken&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> UnStructuredTokens = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;UnStructuredTokens&quot;</span>);\r\n            <span style=\"color:Blue\">var</span> UnStructuredTokenLine = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;UnStructuredTokenLine&quot;</span>);\r\n\r\n            <span style=\"color:Green\">// ----------------------------------------------------------------------------------------------------------</span>\r\n            <span style=\"color:Green\">// BNF Rules</span>\r\n            <span style=\"color:Green\">// ----------------------------------------------------------------------------------------------------------</span>\r\n            PreprocessList.Rule = MakeStarRule(PreprocessList, <span style=\"color:Blue\">null</span>, PreprocessLine);\r\n\r\n            PreprocessLine.Rule = MacroDir | UnStructuredTokenLine;\r\n\r\n            UnStructuredToken.Rule = IDENTIFIER\r\n                            | WS\r\n                            | NonMacroKeywords\r\n                            | NUMBER\r\n                            | LBR | RBR | LBP | RBP\r\n                            | COMMA\r\n                            | POINT\r\n                            | COLON\r\n                            ;\r\n            UnStructuredTokens.Rule = MakeStarRule(UnStructuredTokens, <span style=\"color:Blue\">null</span>, UnStructuredToken);\r\n\r\n            UnStructuredTokenLine.Rule = UnStructuredTokens + NL;\r\n\r\n            <span style=\"color:Green\">// Partial test list of keywords</span>\r\n            NonMacroKeywords.Rule = ToTerm(<span style=\"color:#A31515\">&quot;mov&quot;</span>) | <span style=\"color:#A31515\">&quot;inc&quot;</span> | <span style=\"color:#A31515\">&quot;eax&quot;</span> | <span style=\"color:#A31515\">&quot;ebx&quot;</span> | <span style=\"color:#A31515\">&quot;ecx&quot;</span> | <span style=\"color:#A31515\">&quot;end&quot;</span> | <span style=\"color:#A31515\">&quot;jmp&quot;</span> | <span style=\"color:#A31515\">&quot;.code&quot;</span> | <span style=\"color:#A31515\">&quot;.model&quot;</span> | <span style=\"color:#A31515\">&quot;.data&quot;</span>;\r\n\r\n            <span style=\"color:Green\">//macroDir</span>\r\n            <span style=\"color:Green\">// id MACRO [[ macroParmList ]] ;;</span>\r\n            <span style=\"color:Green\">//macroBody</span>\r\n            <span style=\"color:Green\">//ENDM ;;</span>\r\n            MacroDir.Rule = IDENTIFIER + WSP + PreferShiftHere() + <span style=\"color:#A31515\">&quot;MACRO&quot;</span> + MacroParmListOpt + WSS + NL\r\n                <span style=\"color:Green\">//+ MacroBody</span>\r\n                + MacroStmtList\r\n                + <span style=\"color:#A31515\">&quot;ENDM&quot;</span> + WSS + NL;\r\n\r\n            MacroParmListOpt.Rule = Empty | (WSP + MacroParmList);\r\n\r\n            <span style=\"color:Green\">//macroParmList</span>\r\n            <span style=\"color:Green\">//    macroParm</span>\r\n            <span style=\"color:Green\">//    | macroParmList , [[ NL ]] macroParm </span>\r\n            <span style=\"color:Blue\">var</span> comma_decl = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;comma_decl&quot;</span>);\r\n            comma_decl.Rule = COMMA + WSS + (Empty | NL) + WSS;  \r\n            MacroParmList.Rule = MakeStarRule(MacroParmList, comma_decl, MacroParm);\r\n\r\n            <span style=\"color:Green\">// macroParm := id [[ : parmType ]]</span>\r\n            MacroParm.Rule = IDENTIFIER + ParmTypeOptional;\r\n            ParmTypeOptional.Rule = Empty | (COLON + ParmType);\r\n\r\n            <span style=\"color:Green\">//parmType</span>\r\n            <span style=\"color:Green\">//    REQ</span>\r\n            <span style=\"color:Green\">//    | = textLiteral</span>\r\n            <span style=\"color:Green\">//    | VARARG</span>\r\n            ParmType.Rule = ToTerm(<span style=\"color:#A31515\">&quot;REQ&quot;</span>)\r\n                | <span style=\"color:#A31515\">&quot;=&quot;</span> + TEXT_LITERAL\r\n                | <span style=\"color:#A31515\">&quot;VARARG&quot;</span>;\r\n\r\n            <span style=\"color:Green\">//macroBody</span>\r\n            <span style=\"color:Green\">//    [[ localList ]]</span>\r\n            <span style=\"color:Green\">//    macroStmtList </span>\r\n            <span style=\"color:Green\">//MacroBody.Rule = MacroStmtList;</span>\r\n\r\n            <span style=\"color:Green\">//macroStmtList</span>\r\n            <span style=\"color:Green\">//    macroStmt ;;</span>\r\n            <span style=\"color:Green\">//    | macroStmtList macroStmt ;; </span>\r\n            MacroStmtList.Rule = MakeStarRule(MacroStmtList, <span style=\"color:Blue\">null</span>, MacroStmt);\r\n\r\n            <span style=\"color:Green\">// Uncomplete macroStmt (just using macroDir and exitM)</span>\r\n            <span style=\"color:Green\">//macroStmt</span>\r\n            <span style=\"color:Green\">//  directive</span>\r\n            <span style=\"color:Green\">//  | exitmDir</span>\r\n            <span style=\"color:Green\">//  | : macroLabel</span>\r\n            <span style=\"color:Green\">//  | GOTO macroLabel</span>\r\n            MacroStmt.Rule = MacroDir\r\n                | Exitm\r\n                | UnStructuredTokenLine;\r\n            \r\n            <span style=\"color:Green\">//exitmDir:</span>\r\n            <span style=\"color:Green\">//  EXITM</span>\r\n            <span style=\"color:Green\">//  | EXITM textItem</span>\r\n            <span style=\"color:Green\">//RegexBasedTerminal regBasedTerminal = new RegexBasedTerminal(&quot;exitm-content&quot;,&quot;&lt;.*&gt;&quot;, &quot;&lt;&quot;);</span>\r\n\r\n            Exitm.Rule = ToTerm(<span style=\"color:#A31515\">&quot;EXITM&quot;</span>) + PreferShiftHere() + ExitmOptional + NL;\r\n\r\n            ExitmOptional.Rule = Empty | WSS + TEXT_LITERAL;\r\n\r\n            <span style=\"color:Gray\">///</span><span style=\"color:Green\">/macroCall</span>\r\n            <span style=\"color:Gray\">///</span><span style=\"color:Green\">/    id macroArgList ;;</span>\r\n            <span style=\"color:Gray\">///</span><span style=\"color:Green\">/    | id ( macroArgList )</span>\r\n            <span style=\"color:Green\">//MacroCall.Rule = IDENTIFIER + PreferShiftHere() + MacroArgListOptional;</span>\r\n\r\n            <span style=\"color:Green\">//MacroArgListOptional.Rule = &quot;(&quot; + MacroArgList + &quot;)&quot; |  WSP + MacroArgList | Empty;</span>\r\n\r\n            <span style=\"color:Green\">//var comma_arg = new NonTerminal(&quot;comma_nl&quot;);</span>\r\n            <span style=\"color:Green\">//comma_arg.Rule = COMMA + WSS;</span>\r\n            <span style=\"color:Green\">//MacroArgList.Rule = MakeStarRule(MacroArgList, comma_arg, MacroArg);</span>\r\n\r\n            <span style=\"color:Green\">//MacroArg.Rule = (NUMBER | TEXT_LITERAL | IDENTIFIER) + WSS;</span>\r\n\r\n            Root = PreprocessList;       <span style=\"color:Green\">// Set grammar root</span>\r\n\r\n            <span style=\"color:Green\">//MarkTransient(ParmTypeOptional, MacroArgListOptional);</span>\r\n\r\n            <span style=\"color:Green\">//automatically add NL before EOF so that our BNF rules work correctly when there's no final line break in source</span>\r\n            LanguageFlags = LanguageFlags.NewLineBeforeEOF;\r\n        }\r\n    }\r\n\r\n}\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>I'm trying to parse the following text with Irony Grammar Explorer :</p>\r\n<p>&nbsp;</p>\r\n<pre>mymacro <span style=\"color:#0000ff\">macro<br></span>bla bla bla bla bla  <br><span style=\"color:#0000ff\">endm</span><br>mymacro<br>blo blo<br>end</pre>\r\n<p>and it fails on line 2. The grammar expect to have the first &quot;bla&quot; followed by &quot;macro&quot;.</p>\r\n<p>&nbsp;</p>\r\n<p>I'm probably using Irony in a wrong way...</p>\r\n<p>([Edit]I remmenber that i had to modify the StringLiteral class constructor to accept both start and end tokens[/Edit])</p>",
    "PostedDate": "2009-11-10T06:23:53.84-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "255607",
    "ThreadId": "74018",
    "Html": "<p>My first question: why you need to&nbsp;clear automatic&nbsp;whitespace chars in Grammar and handle whitespaces explicitly in grammar rules? I don't think it's really necessary,and it actually messes your grammar a lot.</p>\r\n<p>My guess you wanted to process macro body lines as unstructured stream of tokens/whitespaces. I think you'd be much better if you put auto whitspaces back, and handle macro body lines using FreeTextLiteral, with termination symbol LF.</p>\r\n<p>var macroLine = FreeTextLiteral(&quot;macroLine&quot;, &quot;\\n&quot;);</p>\r\n<p>next, you should declare &quot;macro&quot; and &quot;endm&quot; as reserved words using MarkReservedWords call, so when scanner finds &quot;endm&quot; at the end of the macro, it will inambiguously scan it as keyword, not as another macro body line.</p>\r\n<p>My guess this switch&nbsp;will eliminate several of your conflicts involving whitespace.</p>\r\n<p>Second, your main&nbsp;shift-reduce conflict, in state S0. Basically the nature of the conflict is the following. When parser sees the first identifier token &quot;a&quot;, it must make a decision immediately, what line it is:</p>\r\n<p>*a b x y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- unstructered token list</p>\r\n<p>*a macro x y&nbsp;&nbsp;&nbsp;&nbsp; -- macro header</p>\r\n<p>(&quot;*&quot; indicates current&nbsp;parser reading position). The way your grammar is structured forces parser either to create empty UnstructuredTokens nonterminal (for option 1)&nbsp;, or shift over macro name for macro header. Default action in conflict is shift, so it always chooses version #2, that's why it fails for you with &quot;expected 'macro' &quot; error message.</p>\r\n<p>I think you can fix it by restructuring your grammar a bit. As far as I remember ASM syntax, regular commands start with instruction code like &quot;mov&quot;, &quot;add&quot;, &quot;sub&quot;, etc</p>\r\n<p>So do something like:</p>\r\n<p>asmCommand.Rule = macroDef | command;</p>\r\n<p>command.Rule = Instr + paramList;</p>\r\n<p>Instr.Rule = &quot;mov&quot; | &quot;add&quot; | &quot;sub&quot;... etc;</p>\r\n<p>macroDef.Rule = identifier + &quot;macro&quot; + idList + NewLine +&nbsp;macroBody + &quot;endMacro&quot;;</p>\r\n<p>macroBody.Rule = MakeStarRule(macroBody, macroLine); //macro line declared above</p>\r\n<p>There is still a problem - nested macro defs, how to properly recognize endm&nbsp; as end of parent, not nested macro. But lets leave it for now, lets make it work without nested macro</p>\r\n<p>Roman</p>",
    "PostedDate": "2009-11-10T10:06:40.847-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "255683",
    "ThreadId": "74018",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>rivantsov wrote:</strong><br>\r\n<p>My first question: why you need to&nbsp;clear automatic&nbsp;whitespace chars in Grammar and handle whitespaces explicitly in grammar rules? I don't think it's really necessary,and it actually messes your grammar a lot.</p>\r\n<p>My guess you wanted to process macro body lines as unstructured stream of tokens/whitespaces. I think you'd be much better if you put auto whitspaces back, and handle macro body lines using FreeTextLiteral, with termination symbol LF.</p>\r\n</blockquote>\r\n<p>You are probably right. I wanted to use whitespace in order to reconstruct the exact output for unstructured tokens.</p>\r\n<p>I was thinking to implement the assembler in 2 step:</p>\r\n<ul>\r\n<li>A 1st step using macros preprocessing (putting only asm in keywords without analysing them), that doesn't know anything about asm language. This 1st step would interprets the macro, perform expansion and output the results, reconstructing the source with unstructured tokens (with correct whitespace) </li>\r\n<li>A 2nd step parsing the asm language without any macro language in it (they were stripped from 1st step).</li>\r\n</ul>\r\n<p>Good point for FreeTextLiteral, although i still need to parse statements inside a macro... and it seems not possible (yet) to mix unstructured and structured lines in Irony? (at the condition that an unstructured line doesn't match a valid structured line...)</p>\r\n<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>rivantsov wrote:</strong><br>\r\n<p>Second, your main&nbsp;shift-reduce conflict, in state S0. Basically the nature of the conflict is the following. When parser sees the first identifier token &quot;a&quot;, it must make a decision immediately, what line it is:</p>\r\n<p>*a b x y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- unstructered token list</p>\r\n<p>*a macro x y&nbsp;&nbsp;&nbsp;&nbsp; -- macro header</p>\r\n<p>(&quot;*&quot; indicates current&nbsp;parser reading position). The way your grammar is structured forces parser either to create empty UnstructuredTokens nonterminal (for option 1)&nbsp;, or shift over macro name for macro header. Default action in conflict is shift, so it always chooses version #2, that's why it fails for you with &quot;expected 'macro' &quot; error message.</p>\r\n</blockquote>\r\n<p>This is something i don't fully understand, as i thought Irony was able to handle it with some kind of lookahead?</p>\r\n<p>In ANTLR, there is a feature called syntactic predicates that follow a rule only if a group of tokens are found.</p>\r\n<p>the &quot;a b x y&quot; vs &quot;a macro x y&quot; is a common case that should be easy for a lookahead no?</p>\r\n<p>for example, how would you implement the distinction in Irony between a declaration of a C function and it's implementation ?</p>\r\n<ul>\r\n<li>declaration : void myfunction(int param1);</li>\r\n<li>implem: void myfunction(int param1) { .... }</li>\r\n</ul>\r\n<p>Anyway, don't worry too much. I'm just evaluating the feasibility of such an assembler written in Irony... I don't actually expect to develop such an assembler, but if Irony was helping a lot on that, that could change my mind (or another mind! ;) )</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-11-10T13:12:18.28-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "255826",
    "ThreadId": "74018",
    "Html": "<p style=\"padding-left:30px\">&quot;..Good point for FreeTextLiteral, although i still need to parse statements inside a macro... and it seems not possible (yet) to mix unstructured and structured lines in Irony? (at the condition that an unstructured line doesn't match a valid structured line...) &quot;</p>\r\n<p>Well, for me the first problem is actually define formally how the macro body should be parsed; so far I don't have a clear picture honestly. Only after that we'll try to express these rules in Irony.</p>\r\n<p style=\"padding-left:30px\">&quot;... This is something i don't fully understand, as i thought Irony was able to handle it with some kind of lookahead? In ANTLR, there is a feature called syntactic predicates that follow a rule only if a group of tokens are found. the &quot;a b x y&quot; vs &quot;a macro x y&quot; is a common case that should be easy for a lookahead no?... &quot;</p>\r\n<p>First of all Antlr is build on quite different algorithmic foundation, it uses top-down (LL) parser, while Irony follows bottom-up (LALR) algorithm. So out-of-the-box abilities of the algorithms are different. Generally, LALR algorithms are considered less restrictive, faster and overall preferable to LL. As one example,&nbsp; LALR has not problem with Left-recursive rules, while LL cannot handle them at all, you have to refactor the grammar to get rid of these. As for using lookaheads, both approaches handle a single lookahead token as a facility of algorithm itself. Bigger lookaheads if needed are usually handled as custom code hooked into Parser that kicks in at point of indecision, looks ahead in token stream and gives parser an advice. There is such facility in Irony, look at c# sample. there is a custom lookahead code there that helps parser decide what is &quot;&lt;&quot; in input - comparison operator or opening bracket for type parameter. In your case very similar code can do the same for looking up &quot;macro&quot; keyword in the stream.</p>\r\n<p>Anyway, good luck with your research, let me know if you need anything else</p>\r\n<p>Roman</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-11-10T20:33:44.653-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "255908",
    "ThreadId": "74018",
    "Html": "<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>rivantsov wrote:</strong><br>\r\n<p style=\"padding-left:30px\">&quot;..Good point for FreeTextLiteral, although i still need to parse statements inside a macro... and it seems not possible (yet) to mix unstructured and structured lines in Irony? (at the condition that an unstructured line doesn't match a valid structured line...) &quot;</p>\r\n<p>Well, for me the first problem is actually define formally how the macro body should be parsed; so far I don't have a clear picture honestly. Only after that we'll try to express these rules in Irony.</p>\r\n</blockquote>\r\n<p>My fault, you are right. Trying to quickly prototype without giving you a kind of &quot;whole picture&quot; and asking why is not working with Irony is not fair! Moreover, i'm discovering that the macro body is only parsed when expansion occurs. It means that you were right when you advise me to use FreeTextLiteral.</p>\r\n<p>ASM parsing is simple in many ways but assemblers have also a lots of weird syntax behaviour... instead of working on a MASM syntax, i should more probably develop an easier syntax to parse... i'll see that option too.</p>\r\n<blockquote style=\"border:solid .1em #ccc;font-style:italic;margin:.25em 1em 0 1em;padding:0 .25em 0 .25em\"><strong>rivantsov wrote:</strong><br>\r\n<p>First of all Antlr is build on quite different algorithmic foundation, it uses top-down (LL) parser, while Irony follows bottom-up (LALR) algorithm. So out-of-the-box abilities of the algorithms are different. Generally, LALR algorithms are considered less restrictive, faster and overall preferable to LL. As one example,&nbsp; LALR has not problem with Left-recursive rules, while LL cannot handle them at all, you have to refactor the grammar to get rid of these. As for using lookaheads, both approaches handle a single lookahead token as a facility of algorithm itself. Bigger lookaheads if needed are usually handled as custom code hooked into Parser that kicks in at point of indecision, looks ahead in token stream and gives parser an advice. There is such facility in Irony, look at c# sample. there is a custom lookahead code there that helps parser decide what is &quot;&lt;&quot; in input - comparison operator or opening bracket for type parameter. In your case very similar code can do the same for looking up &quot;macro&quot; keyword in the stream.</p>\r\n<p>Anyway, good luck with your research, let me know if you need anything else</p>\r\n</blockquote>\r\n<p>Thanks! I missed the ResolveCode() in C# grammar. I have tested in the asm grammar and it's working great, even with unstructured token lines. So this ResolveCode() + On OnResolvingConflict() resolves the thing!</p>\r\n<p>About LALR(1) and the &quot;one token ahead&quot;, you are saying that &quot;macro&quot; in &quot;Identifier + macro&quot; is not considered as a one token ahead of &quot;Identifier&quot;? Or the token ahead is counting the current token? (sorry for this dummy question, I'have not played with parser for a while!)</p>\r\n<p>The ResolveCode() + OnResolvingConflict() is really helpful and easy to use but i'm wondering if it would be relevant for Irony to provide a builtin simple disambiguation for one token ahead (or two, if the one token ahead is the current token)?&nbsp; But ok, that's not a priority. Hope that you will be able to push a stable 1.0 before the end of the year.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-11-11T03:00:31.867-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "257099",
    "ThreadId": "74018",
    "Html": "<p>Hi</p>\r\n<p>&quot;one token ahead&quot;, for &quot;macro&quot; in Identifier + macro - yes, you interpret it right, macro is not considered this one token lookahead when parser in the position before identifier, it is identifier itself. The trouble is that at this point Parser must make a decision between 2 or more alternatives, and all it sees is CurrentToken (identifier), which IS the single lookahead token.</p>\r\n<p>About built-in automatic lookup facility for cases like this - I actually thought about this, and it may be possible, but I didnt' figure out details yet. I may come back to this in the future</p>\r\n<p>Roman</p>",
    "PostedDate": "2009-11-14T08:38:55.537-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
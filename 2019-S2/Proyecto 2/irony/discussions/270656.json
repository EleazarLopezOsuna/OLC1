[
  {
    "Id": "664359",
    "ThreadId": "270656",
    "Html": "\r\n<p>I am looking into a project that would involve translating from one language to another. I am looking into Irony as I find the overall approach of this parser more elegant compared to the lex/yacc approach I have taken in the past (long time ago).</p>\r\n<p>Now, I am a little unsure of what approach to take, should I just create a grammar and generate the translation by walking through the parse tree? Or would it make more sense to treat the problem more as an interpreter issue and create specific AST nodes\r\n and just have the resulting tree evaluate itself into destination code? It seems some of the constructs within the interpreter would not be well suited for the task but at the same time the approach to parsing through an AST and constructing the code in a&nbsp;hierarchical&nbsp;way\r\n seems to make sense to me.</p>\r\n<p>Also, what is the best way to deal with &quot;c style&quot; preprocessor directives? Is it best to do a two pass approach or simply deal with preprocessor directives as if they were part of the grammar. In some way, it seems like the on-the-fly text manipulation would\r\n be problematic for the parser.</p>\r\n<p>Thanks,</p>\r\n<p>Sebastien</p>\r\n",
    "PostedDate": "2011-08-27T20:49:37.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "664940",
    "ThreadId": "270656",
    "Html": "<p>Hi!&nbsp;</p>\r\n<p>About the approach to translation. I would suggest to go without AST, just Parse tree should be enough.&nbsp;</p>\r\n<p>As for c-style pre-processor - that's bad news, the support for this is not implemented yet. But I think it's doable, so it's a good time to start implementing it - why don't you try it? What preprocessor commands do you need? Some would be relatively easy, others may be challenging.</p>\r\n<p>Roman</p>",
    "PostedDate": "2011-08-29T10:25:08.507-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "664946",
    "ThreadId": "270656",
    "Html": "Hi.<br>\r\n<br>\r\nI thought AST would be the simplest. Just seemed like there were<br>\r\nconstructs in the evaluator that didn't really make sense but I guess<br>\r\nnothing prevents from deriving also my nodes from my own interface<br>\r\nwhich provides a more appropriate &quot;context&quot; for translation.<br>\r\n<br>\r\nFor the pre-processor, just basic c style #define/#ifdef type<br>\r\nprocessing. I don't have a problem implementing this and sharing my<br>\r\nchanges if need be. May require some guidance since I am new to the<br>\r\nIvory codebase.<br>\r\n<br>\r\nI did manage to get my grammar in-place (essentially parsing HLSL<br>\r\nshader language with intent on converting to a variant of GLSL). I<br>\r\nhave run into a number of conflicts which I solved most of them, the<br>\r\nfew remaining ones are a little more tricky without context at least.<br>\r\nI don't have access to the code, but in pseudo code, for example:<br>\r\n<br>\r\nvariable_decl : type ID ( assignement )? SEMICOLON<br>\r\nfunction_decl : (type | VOID) ID ( LPAREN argumentList RPAREN)?<br>\r\ntype : builtInType | ID<br>\r\n<br>\r\nThe problem is that type must have an ID as an option since, for<br>\r\nexample, a structure would be defined ahead of time and would be<br>\r\nreferenced by its name. Is there a way to solve something like this<br>\r\nwithout any context? If not, is is possible to store some context as<br>\r\nthe tree is built (i.e symbol table)?<br>\r\n<br>\r\nAlso, I noticed changes went in to allow for the semi-automatic<br>\r\nconflict resolution. How stable is the main code branch as this could<br>\r\nhelp resolve a few of my other remaining conflicts? Also, is there any<br>\r\nplans for a more per-rule based &quot;ResolveInCode&quot; to avoid a complex<br>\r\nfunction when having to resolve for multiple rules.<br>\r\n<br>\r\nThanks,<br>\r\nSebastien<br>\r\n<br>\r\nOn Mon, Aug 29, 2011 at 10:25 AM, rivantsov &lt;notifications@codeplex.com&gt; wrote:<br>\r\n&gt; From: rivantsov<br>\r\n&gt;<br>\r\n&gt; Hi!<br>\r\n&gt;<br>\r\n&gt; About the approach to translation. I would suggest to go without AST, just<br>\r\n&gt; Parse tree should be enough.<br>\r\n&gt;<br>\r\n&gt; As for c-style pre-processor - that's bad news, the support for this is not<br>\r\n&gt; implemented yet. But I think it's doable, so it's a good time to start<br>\r\n&gt; implementing it - why don't you try it? What preprocessor commands do you<br>\r\n&gt; need? Some would be relatively easy, others may be challenging.<br>\r\n&gt;<br>\r\n&gt; Roman<br>\r\n&gt;<br>\r\n&gt; Read the full discussion online.<br>\r\n&gt;<br>\r\n&gt; To add a post to this discussion, reply to this email<br>\r\n&gt; ([email removed])<br>\r\n&gt;<br>\r\n&gt; To start a new discussion for this project, email<br>\r\n&gt; [email removed]<br>\r\n&gt;<br>\r\n&gt; You are receiving this email because you subscribed to this discussion on<br>\r\n&gt; CodePlex. You can unsubscribe on CodePlex.com.<br>\r\n&gt;<br>\r\n&gt; Please note: Images and attachments will be removed from emails. Any posts<br>\r\n&gt; to this discussion will also be available online at CodePlex.com<br>\r\n<br>\r\n<br>\r\n<br>\r\n-- <br>\r\n_________________________________________________<br>\r\nSebastien St-Laurent (http://blogs.msdn.com/sebby1234)<br>\r\nOwner of Paradoxal Press (http://www.ParadoxalPress.com)<br>\r\nAuthor of &quot;Shaders for Game Programmers and Artists&quot;<br>\r\nAuthor of &quot;The COMPLETE Effect and HLSL Guide&quot;<br>\r\n_________________________________________________",
    "PostedDate": "2011-08-29T10:36:01.837-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "665322",
    "ThreadId": "270656",
    "Html": "<p>Funny coincidence, as I have also written for the last days a full Hlsl parser using Irony, with usage for both translating to glsl and syntax analyzing. More funny is that I saw also the book \"The Complete Effect and HLSL Guide\" while working on dissecting  the whole Hlsl grammar... ;)</p>\n<p>We were working previously on a legacy ANTLR grammar that was working fine (but grammar was incomplete) but I wanted to give a chance to Irony (almost following it from the beginning) and It did it!</p>\n<p>So far, the grammar I'm working on it is complete and able to parse all DirectX SDK fx files as well as exotic fx files. Though It's for a private/commercial product, I can share a bit of my work:</p>\n<ul>\n<li>Sebastien, I would recommend you to build your own Ast (not using necessarily Irony's infrastructure, as your Ast should be parser independent) and using the same Ast to perform clean/up transformation to the desired language (with the assumption that the  destination language is very similar - syntax like c... etc.). </li>\n<li>All the analysis work (type resolution, type inference) should be done on the Ast, as the analysis is fairly complex when you have to deal with type inference (type inference is necessary if you intend to generate Glsl and you need to add for example casting  at proper place while Hlsl is performing lots of implicit casts) </li>\n<li>Also for the type resolution, It is possible to avoid it at parsing time by performing some post-process on the Ast (It means that \"type\" should also be an identifier... but then you will have more conflicts to resolve). </li>\n<li>For conflicts resolution, you should probably rely on CustomGrammarHint, as they provide a basic infrastructure to implement your own conflicts resolver (default from Irony are not enough in certain cases). </li>\n<li>You will have to write some custom terminal matcher if you intend to parse all the corners of the Hlsl grammar (like asm {} inline blocks) </li>\n<li>Integrating preprocessing grammar into the Hlsl is not a practical solution. You need to preprocess it, either by using an external preprocessor or by using some plumbing of Irony (TokenFilters, custom terminals...etc.). </li>\n</ul>\n<p>Concerning C++ preprocessing, I used to manage it with DirectX preprocessor included in D3dcompier_xx.dll but I would like to investigate if Irony is capable of it.</p>\n<p>There are some issues and I would like to know your advice :</p>\n<ol>\n<li>It seems that SourceLocation doesn't contain any filename reference and this is annoying: suppose I plug a TokenFilter that will explode Tokens based on an external file, It is important to track from which file a token is coming (and not only a line/column).  Do you think adding filename to SourceLocation is fine? </li>\n<li>A TokenFilter could change the current location (only line/filename) of a SourceStream, but I'm not sure It is working well with later method called SourceStream.MoveLocationToPreviewPosition that is modifying the Location just after a token is produced  (though this method just seems to add a delta to the SourceLocation.Line). Do you think there is an issue to modify the SourceLocation from a TokenFilter? </li>\n</ol>\n<p>What do you think?</p>\n<p>[Edit] Errata, for issue 2 with TokenFilter/preprocessing, It seems better to let the TokenFilter modify the token's SourceLocation without modifiying the SourceStream.Location [/Edit]</p>",
    "PostedDate": "2011-08-30T07:10:21.513-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "665332",
    "ThreadId": "270656",
    "Html": "Hi!<br>\r\n<br>\r\nIt's a small world after all. I just love how this book I wrote years<br>\r\nago is still being used, even though it's DX9 specific. :)<br>\r\n<br>\r\nWhat I am working on is also for commercial purposes, so I can't even<br>\r\nreally say &quot;why&quot; I need to translate HLSL to GLSL due to NDA. But at<br>\r\nthe moment we are bouncing two ideas. Either translate direct HLSL to<br>\r\nGLSL or translate HLSL Dissasembly into GLSL. One has more context<br>\r\ninformation but also require a more complex parser/AST and the other<br>\r\none has a simpler grammar and parsing structure but lacks some context<br>\r\ninformation which I will have to get from the reflection interface in<br>\r\nD3DCompile. Oh and I should mention, in my case I am looking at having<br>\r\na parser that supports both DX9 and DX10, so it is another case where<br>\r\nparsing the dissasembly may be easier.<br>\r\n<br>\r\nI was planning on making my own AST nodes, likely deriving from an<br>\r\nITranslate interface. That way I can take advantage of the AST<br>\r\nbuilding capabilities of Irony and also expose the functionality that<br>\r\nis more relevant to translating rather than evaluating.<br>\r\n<br>\r\nI started from some baseline grammar I found online but it seems like<br>\r\nit is full of errors so I will have to make a good number of changes.<br>\r\nBut so far have been able to get all the conflicts resolved, thanks in<br>\r\npart to the new ResolveIf/ShiftIf constructs.<br>\r\n<br>\r\nFor the pre-processor, I am also leaning towards the D3DPreprocess<br>\r\ncalls to start with. I am still interested in rolling out my own but<br>\r\nfor the project the priority is more towards getting GLSL translation<br>\r\nworking ASAP. But for dealing with things like #includes, I think to<br>\r\nmake the stream reader have the ability to stack streams on top of<br>\r\neach other may be the key (I have not looked into exactly how Irony<br>\r\ndoes the parsing yet, so I am speculatively talking here). The<br>\r\ntrickier part is the macro expansion since it almost needs to be done<br>\r\nbefore the actual token resolution is done, at least unless you simply<br>\r\nwant to assume that macro substitution is only done on identifiers,<br>\r\nwhich may not be 100% correct.<br>\r\n<br>\r\nOn Tue, Aug 30, 2011 at 7:10 AM, alexandre_mutel<br>\r\n&lt;notifications@codeplex.com&gt; wrote:<br>\r\n&gt; From: alexandre_mutel<br>\r\n&gt;<br>\r\n&gt; Funny coincidence, as I have also written for the last days a full Hlsl<br>\r\n&gt; parser using Irony, with usage for both translating to glsl and syntax<br>\r\n&gt; analyzing. More funny is that I saw also the book &quot;The Complete Effect and<br>\r\n&gt; HLSL Guide&quot; while working on dissecting the whole Hlsl grammar... ;)<br>\r\n&gt;<br>\r\n&gt; We were working previously on a legacy ANTLR grammar that was working fine<br>\r\n&gt; (but grammar was incomplete) but I wanted to give a chance to Irony (almost<br>\r\n&gt; following it from the beginning) and It did it!<br>\r\n&gt;<br>\r\n&gt; So far, the grammar I'm working on it is complete and able to parse all<br>\r\n&gt; DirectX SDK fx files as well as exotic fx files. Though It's for a<br>\r\n&gt; private/commercial product, I can share a bit of my work:<br>\r\n&gt;<br>\r\n&gt; Sebastien, I would recommend you to build your own Ast (not using<br>\r\n&gt; necessarily Irony's infrastructure, as your Ast should be parser<br>\r\n&gt; independent) and using the same Ast to perform clean/up transformation to<br>\r\n&gt; the desired language (with the assumption that the destination language is<br>\r\n&gt; very similar - syntax like c... etc.).<br>\r\n&gt; All the analysis work (type resolution, type inference) should be done on<br>\r\n&gt; the Ast, as the analysis is fairly complex when you have to deal with type<br>\r\n&gt; inference (type inference is necessary if you intend to generate Glsl and<br>\r\n&gt; you need to add for example casting at proper place while Hlsl is performing<br>\r\n&gt; lots of implicit casts)<br>\r\n&gt; Also for the type resolution, It is possible to avoid it at parsing time by<br>\r\n&gt; performing some post-process on the Ast (It means that &quot;type&quot; should also be<br>\r\n&gt; an identifier... but then you will have more conflicts to resolve).<br>\r\n&gt; For conflicts resolution, you should probably rely on CustomGrammarHint, has<br>\r\n&gt; they provide a basic infrastructure to implement your own conflicts resolver<br>\r\n&gt; (default from Irony are not enough in certain cases).<br>\r\n&gt; You will have to write some custom terminal matcher if you intend to parse<br>\r\n&gt; all the corners of the Hlsl grammar (like asm {} inline blocks)<br>\r\n&gt; Integrating preprocessing grammar into the Hlsl is not a practical solution.<br>\r\n&gt; You need to preprocess it, either by using an external preprocessor or by<br>\r\n&gt; using some plumbing of Irony (TokenFilters, custom terminals...etc.).<br>\r\n&gt;<br>\r\n&gt; Concerning C&#43;&#43; preprocessing, I used to manage it with DirectX preprocessor<br>\r\n&gt; included in D3dcompier_xx.dll but I would like to investigate if Irony is<br>\r\n&gt; capable of it.<br>\r\n&gt;<br>\r\n&gt; There are some issues and I would like to know your advice :<br>\r\n&gt;<br>\r\n&gt; It seems that SourceLocation doesn't contain any filename reference and this<br>\r\n&gt; is annoying: suppose I plug a TokenFilter that will explode Tokens based on<br>\r\n&gt; an external file, It is important to track from which file a token is coming<br>\r\n&gt; (and not only a line/column). Do you think adding filename to SourceLocation<br>\r\n&gt; is fine?<br>\r\n&gt; A TokenFilter could change the current location (only line/filename) of a<br>\r\n&gt; SourceStream, but I'm not sure It is working well with later method called<br>\r\n&gt; SourceStream.MoveLocationToPreviewPosition that is modifying the Location<br>\r\n&gt; just after a token is produced (though this method just seems to add a delta<br>\r\n&gt; to the SourceLocation.Line). Do you think there is an issue to modify the<br>\r\n&gt; SourceLocation from a TokenFilter?<br>\r\n&gt;<br>\r\n&gt; What do you think?<br>\r\n&gt;<br>\r\n&gt; Read the full discussion online.<br>\r\n&gt;<br>\r\n&gt; To add a post to this discussion, reply to this email<br>\r\n&gt; ([email removed])<br>\r\n&gt;<br>\r\n&gt; To start a new discussion for this project, email<br>\r\n&gt; [email removed]<br>\r\n&gt;<br>\r\n&gt; You are receiving this email because you subscribed to this discussion on<br>\r\n&gt; CodePlex. You can unsubscribe on CodePlex.com.<br>\r\n&gt;<br>\r\n&gt; Please note: Images and attachments will be removed from emails. Any posts<br>\r\n&gt; to this discussion will also be available online at CodePlex.com<br>\r\n<br>\r\n<br>\r\n<br>\r\n-- <br>\r\n_________________________________________________<br>\r\nSebastien St-Laurent (http://blogs.msdn.com/sebby1234)<br>\r\nOwner of Paradoxal Press (http://www.ParadoxalPress.com)<br>\r\nAuthor of &quot;Shaders for Game Programmers and Artists&quot;<br>\r\nAuthor of &quot;The COMPLETE Effect and HLSL Guide&quot;<br>\r\n_________________________________________________",
    "PostedDate": "2011-08-30T07:27:43.87-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "1330539",
    "ThreadId": "574500",
    "Html": "Hi Roman,\r<br />\n<br />\nI am newbie to Irony. I have created my personal sql parser by commenting what is not required. See code below. While parsing the text like (SeriesId in (1,2,3) and State = 'TX') OR (State = 'CO' and SeriesId in (2,3,4))\r<br />\n<br />\ni get the error &quot;Reduce-reduce conflict. State S67, lookaheads: id_simple. Selected reduce on first production in conflict set.&quot; . Please advise what change i need to make so while parsing i don't get error.\r<br />\n<br />\nusing System;\r<br />\nusing System.Collections.Generic;\r<br />\nusing System.Linq;\r<br />\nusing System.Text;\r<br />\nusing Irony.Parsing;\r<br />\n<br />\nnamespace Irony.Samples.SQL {\r<br />\n  // Loosely based on SQL89 grammar from Gold parser. Supports some extra TSQL constructs.\r<br />\n<br />\n  public class WhereGrammar : Grammar {<br />\n<pre><code>  public WhereGrammar()\n      : base(false)\n  { //SQL is case insensitive\n  //Terminals\n  var number = new NumberLiteral(&quot;number&quot;);\n  var string_literal = new StringLiteral(&quot;string&quot;, &quot;'&quot;, StringOptions.AllowsDoubledQuote);\n  var Id_simple = TerminalFactory.CreateSqlExtIdentifier(this, &quot;id_simple&quot;); //covers normal identifiers (abc) and quoted id's ([abc d], &quot;abc d&quot;)\n  var comma = ToTerm(&quot;,&quot;);\n  var dot = ToTerm(&quot;.&quot;);\n  var CREATE = ToTerm(&quot;CREATE&quot;); \n  var NULL = ToTerm(&quot;NULL&quot;);\n  var NOT = ToTerm(&quot;NOT&quot;);\n  var UNIQUE = ToTerm(&quot;UNIQUE&quot;); \n  var WITH = ToTerm(&quot;WITH&quot;);\n  var TABLE = ToTerm(&quot;TABLE&quot;); \n  var ALTER = ToTerm(&quot;ALTER&quot;); \n  var ADD = ToTerm(&quot;ADD&quot;); \n  var COLUMN = ToTerm(&quot;COLUMN&quot;); \n  var DROP = ToTerm(&quot;DROP&quot;); \n  var CONSTRAINT = ToTerm(&quot;CONSTRAINT&quot;);\n  var INDEX = ToTerm(&quot;INDEX&quot;); \n  var ON = ToTerm(&quot;ON&quot;);\n  var KEY = ToTerm(&quot;KEY&quot;);\n  var PRIMARY = ToTerm(&quot;PRIMARY&quot;); \n  var INSERT = ToTerm(&quot;INSERT&quot;);\n  var INTO = ToTerm(&quot;INTO&quot;);\n  var UPDATE = ToTerm(&quot;UPDATE&quot;);\n  var SET = ToTerm(&quot;SET&quot;); \n  var VALUES = ToTerm(&quot;VALUES&quot;);\n  var DELETE = ToTerm(&quot;DELETE&quot;);\n  var SELECT = ToTerm(&quot;SELECT&quot;); \n  var FROM = ToTerm(&quot;FROM&quot;);\n  var AS = ToTerm(&quot;AS&quot;);\n  var COUNT = ToTerm(&quot;COUNT&quot;);\n  var JOIN = ToTerm(&quot;JOIN&quot;);\n  var BY = ToTerm(&quot;BY&quot;);\n\n  //Non-terminals\n  var Id = new NonTerminal(&quot;Id&quot;);\n  var stmt = new NonTerminal(&quot;stmt&quot;);\n  var createTableStmt = new NonTerminal(&quot;createTableStmt&quot;);\n  var createIndexStmt = new NonTerminal(&quot;createIndexStmt&quot;);\n  var alterStmt = new NonTerminal(&quot;alterStmt&quot;);\n  var dropTableStmt = new NonTerminal(&quot;dropTableStmt&quot;);\n  var dropIndexStmt = new NonTerminal(&quot;dropIndexStmt&quot;);\n  var selectStmt = new NonTerminal(&quot;selectStmt&quot;);\n  var insertStmt = new NonTerminal(&quot;insertStmt&quot;);\n  var updateStmt = new NonTerminal(&quot;updateStmt&quot;);\n  var deleteStmt = new NonTerminal(&quot;deleteStmt&quot;);\n  var fieldDef = new NonTerminal(&quot;fieldDef&quot;);\n  var fieldDefList = new NonTerminal(&quot;fieldDefList&quot;);\n  var nullSpecOpt = new NonTerminal(&quot;nullSpecOpt&quot;);\n  var typeName = new NonTerminal(&quot;typeName&quot;); \n  var typeSpec = new NonTerminal(&quot;typeSpec&quot;);\n  var typeParamsOpt = new NonTerminal(&quot;typeParams&quot;);\n  var constraintDef = new NonTerminal(&quot;constraintDef&quot;);\n  var constraintListOpt = new NonTerminal(&quot;constraintListOpt&quot;);\n  var constraintTypeOpt = new NonTerminal(&quot;constraintTypeOpt&quot;);\n  var idlist = new NonTerminal(&quot;idlist&quot;); \n  var idlistPar = new NonTerminal(&quot;idlistPar&quot;); \n  var uniqueOpt = new NonTerminal(&quot;uniqueOpt&quot;);\n  var orderList = new NonTerminal(&quot;orderList&quot;);\n  var orderMember = new NonTerminal(&quot;orderMember&quot;); \n  var orderDirOpt = new NonTerminal(&quot;orderDirOpt&quot;);\n  var withClauseOpt = new NonTerminal(&quot;withClauseOpt&quot;);\n  var alterCmd = new NonTerminal(&quot;alterCmd&quot;);\n  var insertData = new NonTerminal(&quot;insertData&quot;); \n  var intoOpt = new NonTerminal(&quot;intoOpt&quot;);\n  var assignList = new NonTerminal(&quot;assignList&quot;);\n  var whereClauseOpt = new NonTerminal(&quot;whereClauseOpt&quot;);\n  var assignment = new NonTerminal(&quot;assignment&quot;);\n  var expression = new NonTerminal(&quot;expression&quot;);\n  var exprList = new NonTerminal(&quot;exprList&quot;);\n  var selRestrOpt = new NonTerminal(&quot;selRestrOpt&quot;);\n  var selList = new NonTerminal(&quot;selList&quot;);\n  var intoClauseOpt = new NonTerminal(&quot;intoClauseOpt&quot;);\n  var fromClauseOpt = new NonTerminal(&quot;fromClauseOpt&quot;);\n  var columnItemList = new NonTerminal(&quot;columnItemList&quot;);\n  var columnItem = new NonTerminal(&quot;columnItem&quot;);\n  var columnSource = new NonTerminal(&quot;columnSource&quot;);\n  var asOpt = new NonTerminal(&quot;asOpt&quot;);\n  var aliasOpt = new NonTerminal(&quot;aliasOpt&quot;);\n  var aggregate = new NonTerminal(&quot;aggregate&quot;);\n  var aggregateArg = new NonTerminal(&quot;aggregateArg&quot;);\n  var aggregateName = new NonTerminal(&quot;aggregateName&quot;);\n  var tuple = new NonTerminal(&quot;tuple&quot;);\n  var joinChainOpt = new NonTerminal(&quot;joinChainOpt&quot;);\n  var joinKindOpt = new NonTerminal(&quot;joinKindOpt&quot;);\n  var term = new NonTerminal(&quot;term&quot;);\n  var unExpr = new NonTerminal(&quot;unExpr&quot;);\n  var unOp = new NonTerminal(&quot;unOp&quot;);\n  var binExpr = new NonTerminal(&quot;binExpr&quot;);\n  var binOp = new NonTerminal(&quot;binOp&quot;);\n  var betweenExpr = new NonTerminal(&quot;betweenExpr&quot;);\n  var inExpr = new NonTerminal(&quot;inExpr&quot;);\n  var parSelectStmt = new NonTerminal(&quot;parSelectStmt&quot;);\n  var notOpt = new NonTerminal(&quot;notOpt&quot;);\n  var funCall = new NonTerminal(&quot;funCall&quot;);\n  var stmtLine = new NonTerminal(&quot;stmtLine&quot;);\n  var semiOpt = new NonTerminal(&quot;semiOpt&quot;);\n  var stmtList = new NonTerminal(&quot;stmtList&quot;);\n  var funArgs = new NonTerminal(&quot;funArgs&quot;);\n  var inStmt = new NonTerminal(&quot;inStmt&quot;);\n\n  //BNF Rules\n  this.Root = expression;\n  stmtLine.Rule = stmt + semiOpt;\n  semiOpt.Rule = Empty | &quot;;&quot;;\n  stmtList.Rule = MakePlusRule(stmtList, stmtLine);\n\n  //ID\n  Id.Rule = MakePlusRule(Id, dot, Id_simple);\n\n  //stmt.Rule = createTableStmt | createIndexStmt | alterStmt \n  //          | dropTableStmt | dropIndexStmt \n  //          | selectStmt | insertStmt | updateStmt | deleteStmt\n  //          | &quot;GO&quot; ;\n\n  stmt.Rule = whereClauseOpt;\n\n  //Create table\n  createTableStmt.Rule = CREATE + TABLE + Id + &quot;(&quot; + fieldDefList + &quot;)&quot; + constraintListOpt;\n  fieldDefList.Rule = MakePlusRule(fieldDefList, comma, fieldDef);\n  fieldDef.Rule = Id + typeName + typeParamsOpt + nullSpecOpt;\n  nullSpecOpt.Rule = NULL | NOT + NULL | Empty;\n  typeName.Rule = ToTerm(&quot;BIT&quot;) | &quot;DATE&quot; | &quot;TIME&quot; | &quot;TIMESTAMP&quot; | &quot;DECIMAL&quot; | &quot;REAL&quot; | &quot;FLOAT&quot; | &quot;SMALLINT&quot; | &quot;INTEGER&quot;\n                               | &quot;INTERVAL&quot; | &quot;CHARACTER&quot;\n                               // MS SQL types:  \n                               | &quot;DATETIME&quot; | &quot;INT&quot; | &quot;DOUBLE&quot; | &quot;CHAR&quot; | &quot;NCHAR&quot; | &quot;VARCHAR&quot; | &quot;NVARCHAR&quot;\n                               | &quot;IMAGE&quot; | &quot;TEXT&quot; | &quot;NTEXT&quot;;\n  typeParamsOpt.Rule = &quot;(&quot; + number + &quot;)&quot; | &quot;(&quot; + number + comma + number + &quot;)&quot; | Empty;\n  constraintDef.Rule = CONSTRAINT + Id + constraintTypeOpt;\n  constraintListOpt.Rule = MakeStarRule(constraintListOpt, constraintDef );\n  constraintTypeOpt.Rule = PRIMARY + KEY + idlistPar | UNIQUE + idlistPar | NOT + NULL + idlistPar\n                         | &quot;Foreign&quot; + KEY + idlistPar + &quot;References&quot; + Id + idlistPar;\n  idlistPar.Rule = &quot;(&quot; + idlist + &quot;)&quot;;\n  idlist.Rule = MakePlusRule(idlist, comma, Id); \n\n  //Create Index\n  createIndexStmt.Rule = CREATE + uniqueOpt + INDEX + Id + ON + Id + orderList + withClauseOpt;\n  uniqueOpt.Rule = Empty | UNIQUE;\n  orderList.Rule = MakePlusRule(orderList, comma, orderMember);\n  orderMember.Rule = Id + orderDirOpt;\n  orderDirOpt.Rule = Empty | &quot;ASC&quot; | &quot;DESC&quot;;\n  withClauseOpt.Rule = Empty | WITH + PRIMARY | WITH + &quot;Disallow&quot; + NULL | WITH + &quot;Ignore&quot; + NULL;\n\n  //Alter \n  alterStmt.Rule = ALTER + TABLE + Id + alterCmd;\n  alterCmd.Rule = ADD + COLUMN  + fieldDefList + constraintListOpt \n                | ADD + constraintDef\n                | DROP + COLUMN + Id\n                | DROP + CONSTRAINT + Id;\n\n  //Drop stmts\n  dropTableStmt.Rule = DROP + TABLE + Id;\n  dropIndexStmt.Rule = DROP + INDEX + Id + ON + Id; \n\n  //Insert stmt\n  insertStmt.Rule = INSERT + intoOpt + Id + idlistPar + insertData;\n  insertData.Rule = selectStmt | VALUES + &quot;(&quot; + exprList + &quot;)&quot;; \n  intoOpt.Rule = Empty | INTO; //Into is optional in MSSQL\n\n  //Update stmt\n  updateStmt.Rule = UPDATE + Id + SET + assignList + whereClauseOpt;\n  assignList.Rule = MakePlusRule(assignList, comma, assignment);\n  assignment.Rule = Id + &quot;=&quot; + expression;\n\n  //Delete stmt\n  deleteStmt.Rule = DELETE + FROM + Id + whereClauseOpt;\n\n  //Select stmt\n  selectStmt.Rule = SELECT + selRestrOpt + selList + intoClauseOpt + fromClauseOpt + whereClauseOpt;\n\n  selRestrOpt.Rule = Empty | &quot;ALL&quot; | &quot;DISTINCT&quot;;\n  selList.Rule = columnItemList | &quot;*&quot;;\n  columnItemList.Rule = MakePlusRule(columnItemList, comma, columnItem);\n  columnItem.Rule = columnSource + aliasOpt;\n  aliasOpt.Rule = Empty | asOpt + Id; \n  asOpt.Rule = Empty | AS;\n  columnSource.Rule = aggregate | Id;\n  aggregate.Rule = aggregateName + &quot;(&quot; + aggregateArg + &quot;)&quot;;\n  aggregateArg.Rule = expression | &quot;*&quot;; \n  aggregateName.Rule = COUNT | &quot;Avg&quot; | &quot;Min&quot; | &quot;Max&quot; | &quot;StDev&quot; | &quot;StDevP&quot; | &quot;Sum&quot; | &quot;Var&quot; | &quot;VarP&quot;;\n  intoClauseOpt.Rule = Empty | INTO + Id;\n  fromClauseOpt.Rule = Empty | FROM + idlist + joinChainOpt; \n  joinChainOpt.Rule = Empty | joinKindOpt + JOIN + idlist + ON + Id + &quot;=&quot; + Id;\n  joinKindOpt.Rule = Empty | &quot;INNER&quot; | &quot;LEFT&quot; | &quot;RIGHT&quot;;\n  whereClauseOpt.Rule = Empty | expression;\n\n\n</code></pre>\n\n",
    "PostedDate": "2014-12-10T03:56:36.96-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1330744",
    "ThreadId": "574500",
    "Html": "you have to understand how LALR works and how to fix the conflicts. Read about LALR parsing, there's plenty of info out there.\r<br />\nSorry, no easy way. Irony makes it <strong>easier</strong> to build parser, but you have to know what parser is and how it works. <br />\n",
    "PostedDate": "2014-12-10T12:06:49.777-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1334489",
    "ThreadId": "574500",
    "Html": "Hi Roman,\r<br />\n<br />\nThanks for your reply and sorry for replying late. I would me to help your provide some specific pointers as to what is missing and what to refer to LALR parsing since i am very new to these.\r<br />\n<br />\nThanks Again\r<br />\nPiyush<br />\n",
    "PostedDate": "2014-12-18T04:28:40.287-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1334706",
    "ThreadId": "574500",
    "Html": "Hi\r<br />\n<br />\nA little bit of explanation of conflicts, 'dangling else' and how to solve them:\r<br />\n<a href=\"http://eli-project.sourceforge.net/elionline/syntax_3.html\" rel=\"nofollow\">http://eli-project.sourceforge.net/elionline/syntax_3.html</a>\r<br />\n<br />\nFor deeper reading, my #1 recommendation is always Parsing Techniques, 2 ed\r<br />\n<a href=\"http://www.amazon.com/Parsing-Techniques-Practical-Monographs-Computer/dp/038720248X\" rel=\"nofollow\">http://www.amazon.com/Parsing-Techniques-Practical-Monographs-Computer/dp/038720248X</a>\r<br />\nFocus on LR/LALR algorithms; it is not very difficult reading, but requires quite a time and concentration to go through (very clear!) explanations and examples\r<br />\nReserve a whole weekend for this, at minimum\r<br />\nHave a nice weekend :) !\r<br />\nRoman<br />\n",
    "PostedDate": "2014-12-18T15:33:19.1-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
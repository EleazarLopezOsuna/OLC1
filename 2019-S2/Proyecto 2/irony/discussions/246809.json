[
  {
    "Id": "569228",
    "ThreadId": "246809",
    "Html": "\r\n<p>First, congratulations on Irony, which makes writing scanners and parsers a breeze. It would be even better if the documentation was more thorough, but it's something that should be addressed by the users (I plan on updating the wikibooks based on what I've\r\n understood and the surprisingly helpful comments inside Irony itself).</p>\r\n<p>&nbsp;</p>\r\n<p>However, I feel that there should be a easier, less redundant way to create AST Nodes (disclaimer: it's possible there's something I'm entirely missing here, feel free to correct me)</p>\r\n<p>Right now you associate to a Non Terminal either a Node type that will be instanciated while constructing the Parse Tree, or a delegate that will do the a custom instanciation.</p>\r\n<p>That's fine but inside the node you have to walk the parse tree, essentially duplicating the work done in the grammar itself.</p>\r\n<p>&nbsp;</p>\r\n<p>For instance:</p>\r\n<pre style=\"font-family:consolas\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Try.Rule&nbsp;=&nbsp;TRY&nbsp;&#43;&nbsp;Block<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;TRY&nbsp;&#43;&nbsp;Block&nbsp;&#43;&nbsp;Catch<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;TRY&nbsp;&#43;&nbsp;Block&nbsp;&#43;&nbsp;FINALLY&nbsp;&#43;&nbsp;Block<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;TRY&nbsp;&#43;&nbsp;Block&nbsp;&#43;&nbsp;Catch&nbsp;&#43;&nbsp;FINALLY&nbsp;&#43;&nbsp;Block;</pre>\r\n<p>Associating TryNode to this, I'll have to parse the nodetree inside the init method, essentially restating the 4 possible productions. I could split these productions using 4 different non terminals and specify a different delegate for each, but it's tedious.</p>\r\n<p>The ideal thing would be to have actions inside the production rule (like Bison does), and a kind of matching construct</p>\r\n<p>jb evain suggested to me using something like:</p>\r\n<pre style=\"font-family:consolas\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Try.Rule&nbsp;=&nbsp;TRY&nbsp;&#43;&nbsp;Block   &gt; (a,b) =&gt; delegate taking the two items<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;TRY&nbsp;&#43;&nbsp;Block&nbsp;&#43;&nbsp;Catch &gt; (a,b,c) =&gt; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;TRY&nbsp;&#43;&nbsp;Block&nbsp;&#43;&nbsp;FINALLY&nbsp;&#43;&nbsp;Block &gt; (a,b,c,d) =&gt; ...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;TRY&nbsp;&#43;&nbsp;Block&nbsp;&#43;&nbsp;Catch&nbsp;&#43;&nbsp;FINALLY&nbsp;&#43;&nbsp;Block =&gt; (a,b,c,d) =&gt; ... ;<br><br>But unfortunately this syntax is not possible in C# since you can't override operators in a generic way. <br><br>In a more classic way,<br><br>Try.Rule = ...<br><br>Try.Rule.Actions = new []{(a,b) =&gt; ..., (a,b,c) =&gt; ..., (a,b,c,d) =&gt; ..., (a,b,c,d) =&gt; ...};<br><br>where the Actions array map to the different |'ed terms.<br><br>I'm currently porting the coffeescript compiler to .Net (using Irony), and the original coffeescript parser uses a very neat grammar DSL over jison (see http://jashkenas.github.com/coffee-script/documentation/docs/grammar.html ), jison being a port of Bison in javascript.<br><br><br><br><br><br><br><br><br></pre>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2011-02-20T08:04:08.537-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "569385",
    "ThreadId": "246809",
    "Html": "<p>The idea is to have a single \"+\" expression in non-terminals like TRY, with optional elements. In this case, the list of child nodes for Init is always the same (length), but some of the children can be empty</p>\r\n<p>(have zero children, meaning they are non-existent in source code).&nbsp;</p>\r\n<p>So modify the rules for CATCH, FINALLY to allow them be empty. As for ending block, define a block_opt non-terminal; you may need to add one check that grammar does not enforce:&nbsp;</p>\r\n<p>that two blocks without CATCH or FINALLY between them is not allowed; you should add this check to AST.Init method.</p>\r\n<p>Hope this helps</p>",
    "PostedDate": "2011-02-20T17:25:31.58-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "569673",
    "ThreadId": "246809",
    "Html": "<p>Thanks for replying.</p>\r\n<p>So basically, if I understand correctly, I have to come up with a single production rule for each of my potential AST node. I'm not sure it makes the rules very readable, and some of the Irony samples don't go that way (the C# grammar or the Java one, for instance).</p>\r\n<p>Moreover, going this way makes using the default Irony Ast nodes very tedious, since the Init methods of the nodes assume a specific structure in the ParseTreeNode that is passed.</p>\r\n<p>So if your production rule is slightly different from the one hardcoded in the node, you have to either specify a delegate that acts as an adapter between the two structures, or provide your homebrew ast node which will have to do the manual matching.</p>\r\n<p>I have the impression that having some way to embed the matching rules inside the grammar itself (and not in the node) would make the code a lot less redundant and also make the nodes not too dependant on the exact parsetree structure from the rules.</p>\r\n<p>I'm not saying it's easy, or even feasible, but the overall very very nice experience of writing grammars in Irony becomes harsher when it gets to building an AST.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2011-02-21T08:54:19.11-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "570601",
    "ThreadId": "246809",
    "Html": "<p>Believe it or not, but I've gone thru similar path of thinking. And finally decided to settle with the solution/recommendation as I explained before. Here's the reasoning.&nbsp;</p>\r\n<p>The parser/scanner for a language might be just a verifier - for syntactic correctness... or token type recognizer - for code colorizer. In these simple cases you don't need AST tree, parse tree is enough.</p>\r\n<p>If you build interpreter, you need AST. Next, AST node of specific type represents the most generic form of language construct. Let's look at TRY, but for c#, it's easier.&nbsp;</p>\r\n<p>Your AstTryNode would probably have properties that would contain subelements of the try: TryBody, CatchBlockList (list of nodes), FinalBlock (optional).</p>\r\n<p>CatchBlockList might be empty list, or FinalBlock might be empty, but AstTryNode must still have these properties. Now, the main function of parser becomes not just describing a language in some \"readable\"</p>\r\n<p>way, but MAPPING the input text of Try-block to the elements/properties of TryAstNode. You have to have this mapping somewhere. You may describe BNF rule for a node in several language-equivalent ways,</p>\r\n<p>but if it is a set of variations, you'll have to do an extra job of mapping. I reasoned that the best way and easiest way to do this is to build one generic definition of the construct:</p>\r\n<p>Try-Catch-Finally-block is a TryBlock followed by zero or more CatchBlocks followed by optional FinallyBlock. Then mapping inside AST node initializer becomes trivial.&nbsp;</p>\r\n<p>That seems kinda giving up some freedom in grammar expressions, but you have to remember that the goal is AST construction, not nicely looking stuff.</p>\r\n<p>There is one big trouble with this approach, and I still do not have a good solution for this. Writing a rule as a sequence of optional sub-clauses works ok</p>\r\n<p>if each clause has distinctive starting keyword - like TRY construct. If there are no such keywords, you get shift/reduce conflicts. (this is limitation of LALR parsing algorithm, not Irony per se).</p>\r\n<p>That's what happened for c# and Java grammar,&nbsp;that's why you see all these expanded expressions with variations, instead of a single sum of optional elements.</p>\r\n<p>But for these grammars, we do not need ASTs, we needed just recognition of constructs - for colorizing the text.&nbsp;</p>\r\n<p>Not sure how satisfying is my explanation, but that's all I have - in any case, I do not have a better solution - tried, but could not find anything satisfying.</p>\r\n<p>Roman</p>",
    "PostedDate": "2011-02-22T23:02:13.507-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "1491374",
    "ThreadId": "660815",
    "Html": "The parser for SQL supports many features of TSQL, but there is one pesky detail that I had to solve - nested comments. Apparently, in TSQL you can do something like this:<br />\n<pre><code>/* comment\n/* nested comment\n*/\nstill comment (this would not work in most languages)\n*/\nSELECT 1</code></pre>\n\nTo take care of this, I extended the CommentTerminal class (CommentTerminal.cs) as follows:<br />\n<pre><code>\n#region License\n/* **********************************************************************************\n * Copyright (c) Roman Ivantsov\n * This source code is subject to terms and conditions of the MIT License\n * for Irony. A copy of the license can be found in the License.txt file\n * at the root of this distribution. \n * By using this source code in any fashion, you are agreeing to be bound by the terms of the \n * MIT License.\n * You must not remove this notice from this software.\n * **********************************************************************************/\n#endregion\n\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Irony.Parsing {\n\n  public class CommentTerminal : Terminal {\n    \n    public CommentTerminal(string name, string startSymbol, params string[] endSymbols) : base(name, TokenCategory.Comment) {\n      this.StartSymbol = startSymbol;\n      this.EndSymbols = new StringList();\n      EndSymbols.AddRange(endSymbols);\n      Priority = TerminalPriority.High; //assign max priority\n    }\n\n        public CommentTerminal(string name, string startSymbol, bool canBeNested, params string[] endSymbols) : base(name, TokenCategory.Comment)\n        {\n            this.StartSymbol = startSymbol;\n            this.EndSymbols = new StringList();\n            EndSymbols.AddRange(endSymbols);\n            Priority = TerminalPriority.High; //assign max priority\n            _canBeNested = canBeNested;\n        }\n\n        public string StartSymbol;\n    public StringList EndSymbols;\n    private char[] _endSymbolsFirsts;\n        private char[] _startAndEndSymbolsFirsts;\n        private bool _isLineComment; //true if NewLine is one of EndSymbols; if yes, EOF is also considered a valid end symbol\n    private bool _canBeNested = false;\n\n    #region overrides\n    public override void Init(GrammarData grammarData) {\n      base.Init(grammarData);\n      //_endSymbolsFirsts char array is used for fast search for end symbols using String's method IndexOfAny(...)\n      _endSymbolsFirsts = new char[EndSymbols.Count];\n            _startAndEndSymbolsFirsts = new char[EndSymbols.Count + 1];\n            for (int i = 0; i &lt; EndSymbols.Count; i++) {\n        string sym = EndSymbols[i];\n        _endSymbolsFirsts[i] = sym[0];\n                _startAndEndSymbolsFirsts[i] = sym[0];\n        _isLineComment |= sym.Contains(&quot;\\n&quot;);\n        if (!_isLineComment)\n          SetFlag(TermFlags.IsMultiline); \n      }\n            _startAndEndSymbolsFirsts[EndSymbols.Count] = StartSymbol[0];\n      if (this.EditorInfo == null) {\n        TokenType ttype = _isLineComment ? TokenType.LineComment : TokenType.Comment;\n        this.EditorInfo = new TokenEditorInfo(ttype, TokenColor.Comment, TokenTriggers.None);\n      }\n    }\n\n    public override Token TryMatch(ParsingContext context, ISourceStream source) {\n      Token result;\n      if (context.VsLineScanState.Value != 0) {\n        // we are continuing in line mode - restore internal env (none in this case)\n        context.VsLineScanState.Value = 0;\n      } else {\n        //we are starting from scratch\n        if (!BeginMatch(context, source)) return null;\n      }\n      result = CompleteMatch(context, source);\n      if (result != null) return result;\n      //if it is LineComment, it is ok to hit EOF without final line-break; just return all until end.\n      if (_isLineComment)\n        return source.CreateToken(this.OutputTerminal);\n      if (context.Mode == ParseMode.VsLineScan)\n        return CreateIncompleteToken(context, source);\n      return context.CreateErrorToken(Resources.ErrUnclosedComment);\n    }\n\n    private Token CreateIncompleteToken(ParsingContext context, ISourceStream source) {\n      source.PreviewPosition = source.Text.Length;\n      Token result = source.CreateToken(this.OutputTerminal);\n      result.Flags |= TokenFlags.IsIncomplete;\n      context.VsLineScanState.TerminalIndex = this.MultilineIndex;\n      return result; \n    }\n\n    private bool BeginMatch(ParsingContext context, ISourceStream source) {\n      //Check starting symbol\n      if (!source.MatchSymbol(StartSymbol)) return false;\n      source.PreviewPosition += StartSymbol.Length;\n      return true; \n    }\n    private Token CompleteMatch(ParsingContext context, ISourceStream source) {\n            //Find end symbol\n            int nestLevel = 0;\n      while (!source.EOF()) {\n        int firstCharPos;\n        if (EndSymbols.Count == 1 &amp;&amp; !_canBeNested)\n          firstCharPos = source.Text.IndexOf(EndSymbols[0], source.PreviewPosition);\n        else if(!_canBeNested)\n          firstCharPos = source.Text.IndexOfAny(_endSymbolsFirsts, source.PreviewPosition);\n        else\n            firstCharPos = source.Text.IndexOfAny(_startAndEndSymbolsFirsts, source.PreviewPosition);\n          if (firstCharPos &lt; 0) {\n          source.PreviewPosition = source.Text.Length;\n          return null; //indicating error\n        }\n        //We found a character that might start an end symbol; let's see if it is true.\n        source.PreviewPosition = firstCharPos;\n                if (_canBeNested &amp;&amp; source.MatchSymbol(StartSymbol))\n                {\n                    nestLevel++;\n                }\n                else\n                {\n                    foreach (string endSymbol in EndSymbols)\n                    {\n                        if (source.MatchSymbol(endSymbol))\n                        {\n                            //We found end symbol; eat end symbol only if it is not line comment.\n                            // For line comment, leave LF symbol there, it might be important to have a separate LF token\n                            if (!_isLineComment)\n                                source.PreviewPosition += endSymbol.Length;\n                            if (!_canBeNested || nestLevel == 0)\n                            {\n                                return source.CreateToken(this.OutputTerminal);\n                            }\n                            else\n                            {\n                                nestLevel--;\n                            }\n                        }//if\n                    }//foreach endSymbol\n                }\n        source.PreviewPosition++; //move to the next char and try again    \n      }//while\n      return null; //might happen if we found a start char of end symbol, but not the full endSymbol\n    }//method\n\n    public override IList&lt;string&gt; GetFirsts() {\n      return new string[] { StartSymbol };\n    }\n    #endregion\n  }//CommentTerminal class\n\n\n}\n</code></pre>\n\nUsing the new constructor parameter, you can now allow a nested comment as such:<br />\n<pre><code>var comment = new CommentTerminal(&quot;comment&quot;, &quot;/*&quot;, true, &quot;*/&quot;);</code></pre>\n\nThe same goes for MDX.<br />\nHope this helps someone.<br />\n",
    "PostedDate": "2017-01-19T12:15:55.883-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
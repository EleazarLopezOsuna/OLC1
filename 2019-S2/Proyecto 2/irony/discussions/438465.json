[
  {
    "Id": "1022993",
    "ThreadId": "438465",
    "Html": "When I Press the Parse button after loading the text and grammar I get a dialog box with the following message.Can any one tell me why is it happening? The grammar is very large and I can not insert it here<br />\n<blockquote>\nSystem.NullReferenceException: Object reference not set to an instance of an object.<br />\nat Irony.Parsing.Parser.ExecuteNextAction() in f:\\cloud\\SLA\\OCL\\irony_e79458979314\\Irony\\Parsing\\Parser\\Parser.cs:line 119<br />\nat Irony.Parsing.Parser.ParseAll() in f:\\cloud\\SLA\\OCL\\irony_e79458979314\\Irony\\Parsing\\Parser\\Parser.cs:line 101<br />\nat Irony.Parsing.Parser.Parse(String sourceText, String fileName) in f:\\cloud\\SLA\\OCL\\irony_e79458979314\\Irony\\Parsing\\Parser\\Parser.cs:line 75<br />\nat Irony.GrammarExplorer.fmGrammarExplorer.ParseSample() in f:\\cloud\\SLA\\OCL\\irony_e79458979314\\Irony.GrammarExplorer\\fmGrammarExplorer.cs:line 348<br />\nat Irony.GrammarExplorer.fmGrammarExplorer.btnParse_Click(Object sender, EventArgs e) in f:\\cloud\\SLA\\OCL\\irony_e79458979314\\Irony.GrammarExplorer\\fmGrammarExplorer.cs:line 507<br />\nat System.Windows.Forms.Control.OnClick(EventArgs e)<br />\nat System.Windows.Forms.Button.OnClick(EventArgs e)<br />\nat System.Windows.Forms.Button.OnMouseUp(MouseEventArgs mevent)<br />\nat System.Windows.Forms.Control.WmMouseUp(Message&amp; m, MouseButtons button, Int32 clicks)<br />\nat System.Windows.Forms.Control.WndProc(Message&amp; m)<br />\nat System.Windows.Forms.ButtonBase.WndProc(Message&amp; m)<br />\nat System.Windows.Forms.Button.WndProc(Message&amp; m)<br />\nat System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message&amp; m)<br />\nat System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message&amp; m)<br />\nat System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)<br />\n</blockquote>\n",
    "PostedDate": "2013-03-29T11:17:25.977-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023012",
    "ThreadId": "438465",
    "Html": "well, debug into it and see what's happening. Most likely smth wrong with your grammar, but.. parser shouldn't crash on bad grammars, so likely some sleeping bug in Irony\r<br />\nRoman<br />\n",
    "PostedDate": "2013-03-29T12:22:38.593-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023237",
    "ThreadId": "438465",
    "Html": "Here i have put the grammar fully part by part .please follow the following posts. \r<br />\n```\r\nusing System;\r<br />\nusing System.Linq;\r<br />\nusing System.Collections.Generic;\r<br />\nusing System.Text;\r<br />\nusing Irony.Parsing;\r<br />\nusing PGSoftwareSolutionsInc.PGIrony;\r<br />\nusing System.Globalization;\r<br />\n<br />\nnamespace Irony.Samples.EMFOCL2\r<br />\n{<br />\n<pre><code>/// &lt;summary&gt;\n/// Description of EMOFOCL2Grammer.\n/// &lt;/summary&gt;\n[Language(&quot;SLAng&quot;, &quot;2&quot;, &quot;SLAng grammar&quot;)]\npublic class SLAngGrammer: PGSoftwareSolutionsInc.PGIrony.Grammar&lt;MyAstContext&gt;\n{\n    public SLAngGrammer(): base(false,LanguageFlags.CreateAst)\n    {\n        StringLiteral stringLiteral = TerminalFactory.CreateCSharpString(&quot;StringLiteral&quot;);\n        StringLiteral charLiteral = TerminalFactory.CreateCSharpChar(&quot;CharLiteral&quot;);\n        NumberLiteral number = TerminalFactory.CreateCSharpNumber(&quot;Number&quot;);\n        IdentifierTerminal identifier = TerminalFactory.CreateCSharpIdentifier(&quot;Identifier&quot;);\n        CommentTerminal delimitedComment = new CommentTerminal(&quot;DelimitedComment&quot;, &quot;/[&quot;, &quot;]/&quot;);\n        CommentTerminal SingleLineComment = new CommentTerminal(&quot;SingleLineComment&quot;, &quot;--&quot;,&quot;\\r&quot;, &quot;\\n&quot;, &quot;\\u2085&quot;, &quot;\\u2028&quot;, &quot;\\u2029&quot;);\n        NonGrammarTerminals.Add(SingleLineComment);\n        NonGrammarTerminals.Add(delimitedComment);\n\n        KeyTerm colon = ToTerm(&quot;:&quot;);      \n        KeyTerm dot = ToTerm(&quot;.&quot;);\n        KeyTerm comma = ToTerm(&quot;,&quot;);\n        KeyTerm propertyIs = ToTerm(&quot;-&gt;&quot;);\n        KeyTerm lbr = ToTerm(&quot;{&quot;);\n        KeyTerm rbr = ToTerm(&quot;}&quot;);\n        KeyTerm lpar = ToTerm(&quot;(&quot;);\n        KeyTerm rpar = ToTerm(&quot;)&quot;);\n        KeyTerm scopeIn = ToTerm(&quot;::&quot;);\n        KeyTerm suchThat = ToTerm(&quot;|&quot;);\n        KeyTerm _package = ToTerm(&quot;package&quot;);\n        KeyTerm context = ToTerm(&quot;context&quot;);\n        KeyTerm body = ToTerm(&quot;body&quot;);\n        KeyTerm def = ToTerm(&quot;def&quot;);\n        KeyTerm derive = ToTerm(&quot;derive&quot;);      \n        KeyTerm In = ToTerm(&quot;in&quot;);\n        KeyTerm inv = ToTerm(&quot;inv&quot;);\n        KeyTerm let = ToTerm(&quot;let&quot;);\n        KeyTerm post = ToTerm(&quot;post&quot;);\n        KeyTerm pre = ToTerm(&quot;pre&quot;);\n        KeyTerm Static = ToTerm(&quot;static&quot;);\n        KeyTerm self = ToTerm(&quot;self&quot;);      \n        KeyTerm result = ToTerm(&quot;result&quot;);\n        KeyTerm equalsTo = ToTerm(&quot;=&quot;);\n        KeyTerm _null = ToTerm(&quot;null&quot;);\n        KeyTerm invalid = ToTerm(&quot;invalid&quot;);\n        KeyTerm not =  ToTerm(&quot;not&quot;);\n        KeyTerm and =  ToTerm(&quot;and&quot;);\n        KeyTerm or =  ToTerm(&quot;or&quot;);\n        KeyTerm xor =  ToTerm(&quot;xor&quot;);\n\n     var specification = new TypedNonTerminal&lt;specificationAstNode&gt;();\n     var specificationBody = new TypedNonTerminal&lt;specificationBodyAstNode&gt;(); \n     var package = new TypedNonTerminal&lt;packageAstNode&gt;();\n     var packages = new TypedNonTerminal&lt;packagesAstNode&gt;();\n     var oclPackage = new TypedNonTerminal&lt;oclPackageAstNode&gt;();\n     var emofOclPackage = new TypedNonTerminal&lt;emofOclPackageAstNode&gt;();\n     var packageBody = new TypedNonTerminal&lt;packageBodyAstNode&gt;();\n     var packageBodyItem = new TypedNonTerminal&lt;packageBodyItemAstNode&gt;();\n     var contextExp = new TypedNonTerminal&lt;contextExpAstNode&gt;();\n     var classType = new TypedNonTerminal&lt;classTypeAstNode&gt;(); \n     var enumeration = new TypedNonTerminal&lt;enumerationAstNode&gt;();\n     var primitive = new TypedNonTerminal&lt;primitiveAstNode&gt;();\n     var primitiveType = new TypedNonTerminal&lt;primitiveTypeDeclerationAstNode&gt;();\n     var primitiveTypes = new TypedNonTerminal&lt;primitiveTypesAstNode&gt;();\n     var delimitedIdentifier = new TypedNonTerminal&lt;delimitedIdentifierAstNode&gt;();\n     var classSignature = new TypedNonTerminal&lt;classSignatureAstNode&gt;();\n     var classBody = new TypedNonTerminal&lt;classBodyAstNode&gt;();\n     var classBodyItem = new TypedNonTerminal&lt;classBodyItemAstNode&gt;();\n     var invExp  = new TypedNonTerminal&lt;invExpAstNode&gt;();\n     var functionDefination = new TypedNonTerminal&lt;functionDefinationAstNode&gt;();\n     var attributeDiclaration= new TypedNonTerminal&lt;attributeDiclarationAstNode&gt;();\n     var emofAttributeDiclaration= new TypedNonTerminal&lt;emofAttributeDiclarationAstNode&gt;();\n     var oclAttributeDiclaration= new TypedNonTerminal&lt;oclAttributeDiclarationAstNode&gt;();\n     var type = new TypedNonTerminal&lt;typeAstNode&gt;();\n     var expression = new TypedNonTerminal&lt;expressionAstNode&gt;();\n     var customType = new TypedNonTerminal&lt;customTypeAstNode&gt;();\n     var collectionTpye = new TypedNonTerminal&lt;collectionTpyeAstNode&gt;();\n     var fullType = new TypedNonTerminal&lt;fullTypeAstNode&gt;();\n     var globalType = new TypedNonTerminal&lt;globalTypeAstNode&gt;();\n     var setType = new TypedNonTerminal&lt;setTypeAstNode&gt;();\n     var orderedSetType = new TypedNonTerminal&lt;orderedSetTypeAstNode&gt;();\n     var sequenceType = new TypedNonTerminal&lt;sequenceTypeAstNode&gt;();\n     var bagType = new TypedNonTerminal&lt;bagTypeAstNode&gt;();\n     var functionSignature = new TypedNonTerminal&lt;functionSignatureAstNode&gt;();\n     var functionSignatureBody = new TypedNonTerminal&lt;functionSignatureBodyAstNode&gt;();\n     var functionBody = new TypedNonTerminal&lt;functionBodyAstNode&gt;();\n     var oclFunctionSignature = new TypedNonTerminal&lt;oclFunctionSignatureAstNode&gt;();\n     var emofFunctionSignature = new TypedNonTerminal&lt;emofFunctionSignatureAstNode&gt;();\n     var argumentList = new TypedNonTerminal&lt;argumentListAstNode&gt;(); \n     var variableDiclaration = new TypedNonTerminal&lt;variableDiclarationAstNode&gt;();\n     var emofFunctionBody = new TypedNonTerminal&lt;emofFunctionBodyAstNode&gt;();\n     var oclFunctionBody = new TypedNonTerminal&lt;oclfunctionBodyAstNode&gt;();\n     var singleValueCollectionMember = new TypedNonTerminal&lt;singleValueCollectionMemberAstNode&gt;();\n     var booleanValueCollection = new TypedNonTerminal&lt;booleanValueCollectionAstNode&gt;();\n     var letExp  = new TypedNonTerminal&lt;letExpAstNode&gt;();\n     var ifThenElseExp = new TypedNonTerminal&lt;ifThenElseExpAstNode&gt;();\n     var collectionValueExp = new TypedNonTerminal&lt;collectionValueExpAstNode&gt;();\n     var sum = new TypedNonTerminal&lt;sumAstNode&gt;();\n     var size = new TypedNonTerminal&lt;sizeAstNode&gt;();\n     var first  = new TypedNonTerminal&lt;firstAstNode&gt;(); \n     var last   = new TypedNonTerminal&lt;lastAstNode&gt;(); \n     var at   = new TypedNonTerminal&lt;atAstNode&gt;(); \n     var indexOf   = new TypedNonTerminal&lt;indexOfAstNode&gt;();\n     var countOperation = new TypedNonTerminal&lt;CountOperationAstNode&gt;();\n     var maxOperation = new TypedNonTerminal&lt;maxOperationAstNode&gt;();\n     var minOperation = new TypedNonTerminal&lt;minOperationAstNode&gt;();\n     var valueExp = new TypedNonTerminal&lt;valueExpAstNode&gt;();\n     var includesOperation = new TypedNonTerminal&lt;includesOperationAstNode&gt;();\n     var includesAllOperation = new TypedNonTerminal&lt;includesAllExpAstNode&gt;();\n     var excludesOperation = new TypedNonTerminal&lt;excludesOperationAstNode&gt;();\n     var excludesAllOperation = new TypedNonTerminal&lt;excludesAllOperationAstNode&gt;();\n     var isEmptyOperation = new TypedNonTerminal&lt;isEmptyOperationAstNode&gt;();\n     var notEmptyOperation = new TypedNonTerminal&lt;notEmptyOperationAstNode&gt;();\n     var specialIteratorBodyExp = new TypedNonTerminal&lt;specialIteratorBodyExpAstNode&gt;();       \n     var existsExp = new TypedNonTerminal&lt;existsExpAstNode&gt;(); \n     var forAllExp = new TypedNonTerminal&lt;forallExpAstNode&gt;();   \n     var isUniqueExp = new TypedNonTerminal&lt;isUniqueExpAstNode&gt;();   \n     var anyExp = new TypedNonTerminal&lt;anyExpAstNode&gt;();\n     var oneExp = new TypedNonTerminal&lt;oneExpAstNode&gt;();\n     var selectExp = new TypedNonTerminal&lt;selectExpAstNode&gt;();  \n     var includingOperation = new TypedNonTerminal&lt;includingOperationAstNode&gt;();\n     var excludingOperation = new TypedNonTerminal&lt;excludingOperationAstNode&gt;();\n     var collect = new TypedNonTerminal&lt;collectAstNode&gt;();  \n     var subOrderedSet   = new TypedNonTerminal&lt;subOrderedSetAstNode&gt;(); \n     var symmetricDifference  = new TypedNonTerminal&lt;symmetricDifferenceAstNode&gt;();\n     var prepend   = new TypedNonTerminal&lt;prependAstNode&gt;();\n     var append   = new TypedNonTerminal&lt;appendAstNode&gt;(); \n     var insertAt  = new TypedNonTerminal&lt;insertAtAstNode&gt;(); \n     var intersection = new TypedNonTerminal&lt;intersectionAstNode&gt;();\n     var union = new TypedNonTerminal&lt;unionAstNode&gt;();\n     var asBag = new TypedNonTerminal&lt;asBagAstNode&gt;();\n     var asSequence = new TypedNonTerminal&lt;asSequenceAstNode&gt;();\n     var asOrderdSet = new TypedNonTerminal&lt;asOrderdSetAstNode&gt;();\n     var asSet = new TypedNonTerminal&lt;asSetAstNode&gt;();\n     var flatten   = new TypedNonTerminal&lt;flattenAstNode&gt;();\n     var subSequence   = new TypedNonTerminal&lt;subSequenceAstNode&gt;();\n     var andExp= new TypedNonTerminal&lt;andExpAstNode&gt;();\n     var orExp = new TypedNonTerminal&lt;orExpAstNode&gt;();\n     var notExp = new TypedNonTerminal&lt;notExpAstNode&gt;();\n     var xorExp = new TypedNonTerminal&lt;xorExpAstNode&gt;();\n     var impliesExp = new TypedNonTerminal&lt;impliesExpAstNode&gt;();\n     var comparisonOperator = new TypedNonTerminal&lt;comparisonOperatorAstNode&gt;();\n     var arithmaticOperator = new  TypedNonTerminal&lt;arithmaticOperatorAstNode&gt;();\n     var oclInvExp  = new TypedNonTerminal&lt;oclInvExpAstNode&gt;();\n     var emofInvExp  = new TypedNonTerminal&lt;emofInvExpAstNode&gt;();\n     var operationContextExp = new TypedNonTerminal&lt;operationContextExpAstNode&gt;();\n     var attributeContextExp  = new TypedNonTerminal&lt;attributeContextExpAstNode&gt;(); \n     var classContextExp = new TypedNonTerminal&lt;classContextExpAstNode&gt;();\n     var classContextSignature  = new TypedNonTerminal&lt;classContextSignatureAstNode&gt;();</code></pre>\n\n",
    "PostedDate": "2013-03-30T07:53:30.21-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023242",
    "ThreadId": "438465",
    "Html": "```<br />\n<pre><code>    var attributeContextbody  = new TypedNonTerminal&lt;attributeContextbodyAstNode&gt;();\n     var attributeContextbodyItem  = new TypedNonTerminal&lt;attributeContextbodyItemAstNode&gt;();\n     var deriveExp = new TypedNonTerminal&lt;deriveExpAstNode&gt;();\n     var initExp = new TypedNonTerminal&lt;initExpAstNode&gt;();\n     var operationContextBodyExps  = new TypedNonTerminal&lt;operationContextBodyExpsAstNode&gt;();\n     var operationContextSignature  = new TypedNonTerminal&lt;operationContextSignatureAstNode&gt;();\n     var operationContextBodyItem  = new TypedNonTerminal&lt;operationContextBodyItemAstNode&gt;();\n     var preCondition  = new TypedNonTerminal&lt;preConditionAstNode&gt;();\n     var postCondition  = new TypedNonTerminal&lt;postConditionAstNode&gt;();\n     var bodyExp = new TypedNonTerminal&lt;bodyExpAstNode&gt;();\n     var iterateExp = new TypedNonTerminal&lt;iterateExpAstNode&gt;();\n     var productExp = new TypedNonTerminal&lt;productExpAstNode&gt;();\n     var tupleExp = new TypedNonTerminal&lt;tupleExpAstNode&gt;();\n     var rejectExp = new TypedNonTerminal&lt;rejectExpAstNode&gt;();\n     var collection = new TypedNonTerminal&lt;collectionTypeAstNode&gt;();\n     var tuplElementList = new TypedNonTerminal&lt;tuplElementListAstNode&gt;();\n     var tupleElement = new TypedNonTerminal&lt;tupleElementAstNode&gt;();\n     var binaryOperator = new TypedNonTerminal&lt;binaryOperatorAstNode&gt;();\n     var parameterList= new TypedNonTerminal&lt;parameterListAstNode&gt;();\n     var structuralExp = new TypedNonTerminal&lt;structuralExpAstNode&gt;();\n     var setLiteral = new TypedNonTerminal&lt;setLiteralExpAstNode&gt;();\n     var bagLiteral = new TypedNonTerminal&lt;bagLiteralAstNode&gt;();\n     var orderedSetLiteral = new TypedNonTerminal&lt;orderedSetLiteralAstNode&gt;();\n     var sequenceLiteral = new TypedNonTerminal&lt;sequenceLiteralAstNode&gt;();\n     var tupleLiteral = new TypedNonTerminal&lt;tupleLiteralAstNode&gt;();\n     var literalList = new TypedNonTerminal&lt;literalListAstNode&gt;();\n     var iteratorList = new TypedNonTerminal&lt;iteratorListAstNode&gt;();\n     var iteratorInitializationList = new TypedNonTerminal&lt;iteratorInitializationListAstNode&gt;();\n     var iteratorInitialization = new TypedNonTerminal&lt;iteratorInitializationAstNode&gt;();\n     var collectionValue = new TypedNonTerminal&lt;collectionValueAstNode&gt;();\n     var ArrayType = new TypedNonTerminal&lt;ArrayTypeAstNode&gt;();\n     var binaryBooleanOperator = new TypedNonTerminal&lt;binaryBooleanOperatorAstNode&gt;();\n     var oclIsTypeOf = new TypedNonTerminal&lt;oclIsTypeOfAstNode&gt;();\n     var typedValueExp = new TypedNonTerminal&lt;typedValueExpAstNode&gt;();\n     var unTypedValueExp = new TypedNonTerminal&lt;unTypedValueExpAstNode&gt;();\n     var instanceMemberAccess = new TypedNonTerminal&lt;instanceMemberAccessAstNode&gt;();\n     var instanceMathodAccess = new TypedNonTerminal&lt;instanceMathodAccessAstNode&gt;();\n\n       specification.Rule = &quot;specification&quot;+identifier+lbr+specificationBody+rbr;\n       specificationBody.Rule = MakePlusRule(packages,package);\n       package.Rule =oclPackage|emofOclPackage;\n       oclPackage.Rule =_package+identifier+packageBody+&quot;endpackage&quot;;\n       emofOclPackage.Rule = _package+identifier+lbr+packageBody+rbr;\n       packageBody.Rule = MakeStarRule(packageBody,null,packageBodyItem);\n       packageBodyItem.Rule = primitive|enumeration|classType|contextExp|package;\n\n       primitive.Rule=&quot;primitive&quot;+primitiveTypes+identifier+&quot;IDENTICAL&quot;;\n       primitiveTypes.Rule = ToTerm(&quot;Real&quot;)|ToTerm(&quot;Integer&quot;)|ToTerm(&quot;String&quot;)|ToTerm(&quot;Boolean&quot;);\n\n       enumeration.Rule =&quot;enumeration&quot;+identifier+lbr+delimitedIdentifier+rbr;\n       delimitedIdentifier.Rule =MakePlusRule(delimitedIdentifier,comma,identifier); \n\n       classType.Rule = classSignature+lbr+classBody+rbr;\n       classSignature.Rule  = ToTerm(&quot;class&quot;)+identifier\n                              |ToTerm(&quot;abstract&quot;)+ToTerm(&quot;class&quot;)+identifier\n                              |ToTerm(&quot;abstract&quot;)+ToTerm(&quot;class&quot;)+identifier+ToTerm(&quot;extends&quot;)+identifier\n                              |ToTerm(&quot;class&quot;)+identifier+ToTerm(&quot;extends&quot;)+type;\n       classBody.Rule = MakeStarRule(classBody,classBodyItem);\n       classBodyItem.Rule =attributeDiclaration|functionDefination|invExp;\n\n       attributeDiclaration.Rule = oclAttributeDiclaration|emofAttributeDiclaration;\n       oclAttributeDiclaration.Rule = def+colon+identifier+type+ReduceHere()\n                                      |def+colon+identifier+type+PreferShiftHere()+equalsTo+expression+ReduceHere()\n                                      |def+colon+&quot;attr&quot;+identifier+type+PreferShiftHere()+equalsTo+expression+ReduceHere()\n                                      |def+colon+&quot;attr&quot;+identifier+type+ReduceHere();\n       emofAttributeDiclaration.Rule = identifier+colon+type+ReduceHere()\n                                       |ToTerm(&quot;component&quot;)+identifier+colon+type+ToTerm(&quot;opposite&quot;)+identifier+ReduceHere()\n                                       |ToTerm(&quot;component&quot;)+identifier+colon+type+ToTerm(&quot;unique&quot;)+ToTerm(&quot;opposite&quot;)+identifier+ReduceHere()\n                                       |identifier+colon+type+equalsTo+expression+ReduceHere()\n                                       |identifier+colon+type+ToTerm(&quot;opposite&quot;)+identifier+ReduceHere()\n                                       |identifier+colon+type+ToTerm(&quot;unique&quot;)+ToTerm(&quot;opposite&quot;)+identifier+ReduceHere()\n                                       |identifier+colon+type+ToTerm(&quot;unique&quot;)+ReduceHere();\n\n       type.Rule = primitiveTypes|customType;\n       customType.Rule = fullType|globalType|ArrayType|collectionTpye|tupleExp;\n       fullType.Rule= identifier+PreferShiftHere()+scopeIn+PreferShiftHere()+fullType|identifier;\n       globalType.Rule = PreferShiftHere()+scopeIn+fullType\n                        |PreferShiftHere()+scopeIn+ArrayType;\n       ArrayType.Rule = fullType+&quot;[&quot;+&quot;*&quot;+&quot;]&quot;\n                        |fullType+&quot;[&quot;+identifier+&quot;]&quot;\n                        |fullType+&quot;[&quot;+number+&quot;]&quot;\n                        |fullType+&quot;[&quot;+number+comma+number+&quot;]&quot;\n                        |fullType+&quot;[&quot;+number+comma+&quot;*&quot;+&quot;]&quot;;\n       collectionTpye.Rule = setType|orderedSetType|sequenceType|bagType|collection;\n       setType.Rule = &quot;Set(&quot;+customType+&quot;)&quot;;\n       orderedSetType.Rule = &quot;OrderedSet(&quot;+customType+&quot;)&quot;;\n       sequenceType.Rule = &quot;Sequence(&quot;+customType+&quot;)&quot;;\n       bagType.Rule = &quot;Bag(&quot;+customType+&quot;)&quot;;\n       collection.Rule = &quot;Collection(&quot;+customType+&quot;)&quot;;\n       tupleExp.Rule = &quot;Tuple&quot;+lbr+argumentList+rbr;\n\n       functionDefination.Rule = functionSignature+functionBody;\n       functionSignature.Rule = oclFunctionSignature|emofFunctionSignature;\n       oclFunctionSignature.Rule = def+colon+functionSignatureBody;\n       functionSignatureBody.Rule = identifier+lpar+argumentList+rpar+colon+type\n                                    |identifier+lpar+argumentList+rpar+colon+type+ToTerm(&quot;ordered&quot;)+ToTerm(&quot;unique&quot;)\n                                    |identifier+lpar+argumentList+rpar+colon;\n       argumentList.Rule = MakePlusRule(argumentList,comma,variableDiclaration)|Empty;\n       variableDiclaration.Rule = identifier+colon+type;\n       emofFunctionSignature.Rule = functionSignatureBody;\n       functionBody.Rule = oclFunctionBody|emofFunctionBody;\n       oclFunctionBody.Rule = equalsTo+expression;\n       emofFunctionBody.Rule =equalsTo+lbr+expression+rbr; \n\n       expression.Rule = valueExp|structuralExp;\n\n       valueExp.Rule =typedValueExp\n                     |unTypedValueExp\n                     |valueExp+PreferShiftHere()+binaryOperator+valueExp\n                     |ToTerm(&quot;not&quot;)+valueExp\n                     |lpar+valueExp+rpar;\n\n        unTypedValueExp.Rule = booleanValueCollection\n                               |ToTerm(&quot;false&quot;)|ToTerm(&quot;true&quot;)\n                               |collectionValue\n                               |tupleLiteral\n                               |singleValueCollectionMember\n                               |collectionValueExp\n                               |iterateExp\n                               |stringLiteral\n                               |charLiteral\n                               |number\n                               |self\n                               |oclIsTypeOf\n                               |unTypedValueExp+lpar+parameterList+rpar\n                               |instanceMemberAccess\n                               |instanceMathodAccess\n                               |ToTerm(&quot;-&quot;)+number;\n\n        typedValueExp.Rule = fullType+dot+instanceMemberAccess\n                            |globalType+dot+instanceMemberAccess\n                            |typedValueExp+dot+identifier+lpar+parameterList+rpar;\n\n       instanceMemberAccess.Rule = MakePlusRule(instanceMemberAccess,dot,identifier);\n       instanceMathodAccess.Rule = unTypedValueExp+dot+identifier+lpar+parameterList+rpar;\n\n       parameterList.Rule = MakeStarRule(parameterList,comma,valueExp)|ifThenElseExp;\n\n       booleanValueCollection.Rule = includesOperation|includesAllOperation|excludesOperation|excludesAllOperation\n                         |isEmptyOperation|notEmptyOperation|existsExp|forAllExp|isUniqueExp|anyExp|oneExp;</code></pre>\n\n",
    "PostedDate": "2013-03-30T08:01:54.633-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023246",
    "ThreadId": "438465",
    "Html": "<pre><code>   oclIsTypeOf.Rule = valueExp+dot+ToTerm(&quot;oclIsTypeOf&quot;)+lpar+type+rpar;\n\n       binaryOperator.Rule = comparisonOperator|arithmaticOperator|binaryBooleanOperator; \n       arithmaticOperator.Rule = ToTerm(&quot;/&quot;)|ToTerm(&quot;div&quot;)|ToTerm(&quot;*&quot;)|ToTerm(&quot;+&quot;)|ToTerm(&quot;-&quot;);\n       comparisonOperator.Rule = ToTerm(&quot;&gt;&quot;)|ToTerm(&quot;&lt;&quot;)|ToTerm(&quot;&gt;=&quot;)|ToTerm(&quot;&lt;=&quot;)|ToTerm(&quot;&lt;&gt;&quot;)|equalsTo;\n       binaryBooleanOperator.Rule = ToTerm(&quot;and&quot;)|ToTerm(&quot;or&quot;)|ToTerm(&quot;xor&quot;)|ToTerm(&quot;implies&quot;);\n\n\n       includesOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;includes&quot;)+lpar+valueExp+rpar;                  \n       includesAllOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;includesAll&quot;)+lpar+identifier+rpar;                         \n       excludesOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;excludes&quot;)+lpar+identifier+rpar;                      \n       excludesAllOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;excludesAll&quot;)+lpar+identifier+rpar;                           \n       isEmptyOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;isEmpty&quot;)+lpar+rpar;                     \n       notEmptyOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;notEmpty&quot;)+lpar+rpar;                     \n       existsExp.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;exists&quot;)+lpar+specialIteratorBodyExp+rpar;              \n       forAllExp.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;forAll&quot;)+lpar+specialIteratorBodyExp+rpar;           \n       isUniqueExp.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;isUnique&quot;)+lpar+specialIteratorBodyExp+rpar;              \n       anyExp.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;any&quot;)+lpar+specialIteratorBodyExp+rpar;          \n       oneExp.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;one&quot;)+lpar+specialIteratorBodyExp+rpar;          \n       specialIteratorBodyExp.Rule =delimitedIdentifier+colon+type+suchThat+valueExp\n                                   |argumentList+suchThat+valueExp\n                                   |valueExp;\n\n       collectionValue.Rule = setLiteral|bagLiteral|orderedSetLiteral|sequenceLiteral ;\n       setLiteral.Rule  = &quot;Set&quot;+lbr+literalList+rbr\n                          |&quot;Set&quot;+lpar+type+rpar+lbr+literalList+rbr;\n       bagLiteral.Rule  = &quot;Bag&quot;+lbr+literalList+rbr\n                         |&quot;Bag&quot;+lpar+type+rpar+lbr+literalList+rbr;\n       orderedSetLiteral.Rule  =&quot;OrderedSet&quot;+lbr+literalList+rbr\n                                |&quot;OrderedSet&quot;+lpar+type+rpar+lbr+literalList+rbr;\n       sequenceLiteral.Rule  =&quot;Sequence&quot;+lbr+literalList+rbr\n                              |&quot;Sequence&quot;+lpar+type+rpar+lbr+literalList+rbr;\n       literalList.Rule = MakeStarRule(literalList,comma,valueExp); \n       tupleLiteral.Rule=&quot;Tuple&quot;+lbr+tuplElementList+rbr;\n       tuplElementList.Rule = MakePlusRule(tuplElementList,comma,tupleElement);            \n       tupleElement.Rule =variableDiclaration+equalsTo+valueExp|identifier+equalsTo+valueExp;\n       collectionValueExp.Rule =includingOperation|excludingOperation|selectExp|rejectExp\n                                |union|intersection|insertAt|append|prepend|symmetricDifference|subOrderedSet|collect|productExp\n                                |subSequence|flatten|asSet|asOrderdSet|asSequence|asBag;\n       includingOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;including&quot;)+lpar+identifier+rpar;            \n       excludingOperation.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;excluding&quot;)+lpar+identifier+rpar;\n       selectExp.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;select&quot;)+lpar+specialIteratorBodyExp+rpar;\n       rejectExp.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;reject&quot;)+lpar+specialIteratorBodyExp+rpar;\n       union.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;union&quot;)+lpar+valueExp+rpar;\n       intersection.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;intersection&quot;)+lpar+identifier+rpar;\n       insertAt.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;insertAt&quot;)+lpar+number+comma+identifier+rpar;\n       append.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;append&quot;)+lpar+identifier+rpar;\n       prepend.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;prepend&quot;)+lpar+identifier+rpar;\n       symmetricDifference.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;symmetricDifference&quot;)+lpar+identifier+rpar;                     \n       subOrderedSet.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;subOrderedSet&quot;)+lpar+number+comma+number+rpar;               \n       collect.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;collect&quot;)+lpar+specialIteratorBodyExp+rpar\n                    |valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;collect&quot;)+lpar+identifier+rpar\n                    |valueExp+dot+identifier+lpar+argumentList+rpar\n                    |valueExp+PreferShiftHere()+propertyIs+identifier+lpar+argumentList+rpar;\n       productExp.Rule =valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;product&quot;)+lpar+identifier+rpar;                \n       subSequence.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;subSequence&quot;)+lpar+number+comma+number+rpar;                  \n       flatten.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;flatten&quot;)+lpar+rpar;           \n       asSet.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;asSet&quot;)+lpar+rpar;         \n       asOrderdSet.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;asOrderdSet&quot;)+lpar+rpar;                 \n       asSequence.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;asSequence&quot;)+lpar+rpar;              \n       asBag.Rule=valueExp+PreferShiftHere()+propertyIs+ToTerm(&quot;asBag&quot;)+lpar+rpar;\n\n       singleValueCollectionMember.Rule = maxOperation|minOperation|countOperation|at|indexOf|first|last|sum|size;\n       maxOperation.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;max()&quot;\n                           |iterateExp+PreferShiftHere()+propertyIs+&quot;max()&quot;;       \n       minOperation.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;min()&quot;\n                           |iterateExp+PreferShiftHere()+propertyIs+&quot;min()&quot;;\n       countOperation.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;count(&quot;+identifier+&quot;)&quot;\n                            |iterateExp+PreferShiftHere()+propertyIs+&quot;count(&quot;+identifier+&quot;)&quot;;\n       at.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;at(&quot;+identifier+&quot;)&quot;\n                 |iterateExp+PreferShiftHere()+propertyIs+&quot;at(&quot;+identifier+&quot;)&quot;;\n       indexOf.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;indexOf(&quot;+identifier+&quot;)&quot;\n                      |iterateExp+PreferShiftHere()+propertyIs+&quot;indexOf(&quot;+identifier+&quot;)&quot;;\n       first.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;first()&quot;\n                    |iterateExp+PreferShiftHere()+propertyIs+&quot;first()&quot;;\n       last.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;last()&quot;\n                   |iterateExp+PreferShiftHere()+propertyIs+&quot;last()&quot;;\n       sum.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;sum()&quot;\n                  |iterateExp+PreferShiftHere()+propertyIs+&quot;sum()&quot;;\n       size.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;size()&quot;\n                   |iterateExp+PreferShiftHere()+propertyIs+&quot;size()&quot;;\n\n       iterateExp.Rule = valueExp+PreferShiftHere()+propertyIs+&quot;iterate&quot;+lpar+iteratorList+&quot;;&quot;\n                         +iteratorInitializationList+suchThat+expression+rpar;\n       iteratorList.Rule = MakePlusRule(iteratorList,comma,variableDiclaration);\n       iteratorInitializationList.Rule = MakePlusRule(iteratorInitializationList,comma,iteratorInitialization);\n       iteratorInitialization.Rule = variableDiclaration+equalsTo+valueExp;\n\n       structuralExp.Rule = ifThenElseExp|letExp;\n\n       ifThenElseExp.Rule = &quot;if&quot;+valueExp+&quot;then&quot;+expression+&quot;endif&quot;\n                           |&quot;if&quot;+valueExp+&quot;then&quot;+expression+&quot;else&quot;+expression+&quot;endif&quot;;\n\n       letExp.Rule = let+variableDiclaration+equalsTo+valueExp+In+expression\n                    |let+identifier+equalsTo+valueExp+In+expression ;\n\n       invExp.Rule = oclInvExp|emofInvExp;\n       oclInvExp.Rule = inv+identifier+colon+expression\n                        |inv+colon+expression;\n       emofInvExp.Rule =&quot;invariant&quot;+lbr+expression+rbr;\n\n       contextExp.Rule = classContextExp|attributeContextExp|operationContextExp;\n\n       classContextExp.Rule = classContextSignature+classBody;\n       classContextSignature.Rule = context+type\n                                    |context+identifier+colon+type;\n       classBody.Rule = MakePlusRule(classBody,null,classBodyItem);\n       classBodyItem.Rule = invExp|attributeDiclaration|functionDefination;\n\n       attributeContextExp.Rule = context+type+colon+type+attributeContextbody;\n       attributeContextbody.Rule = MakePlusRule(attributeContextbody,null,attributeContextbodyItem);\n       attributeContextbodyItem.Rule = initExp|deriveExp;\n\n       initExp.Rule = ToTerm(&quot;init&quot;)+colon+equalsTo+valueExp;\n\n       deriveExp.Rule = ToTerm(&quot;derive&quot;)+colon+expression;\n\n       operationContextExp.Rule = operationContextSignature+invExp+operationContextBody</code></pre>\n\n",
    "PostedDate": "2013-03-30T08:11:02.133-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023248",
    "ThreadId": "438465",
    "Html": "operationContextSignature.Rule = context+customType+PreferShiftHere()+scopeIn+functionSignature;<br />\n<pre><code>       operationContextBodyExps.Rule = MakePlusRule(operationContextBodyExps,null,operationContextBodyItem);\n       operationContextBodyItem.Rule = preCondition|bodyExp|postCondition;\n\n       preCondition.Rule = pre+identifier+colon+valueExp\n                          |pre+colon+valueExp;\n\n       bodyExp.Rule = body+colon+expression;\n\n       postCondition.Rule = post+colon+valueExp\n                            |post+identifier+colon+valueExp;\n\n       MarkPunctuation(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;, &quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;, &quot;:&quot;);\n       MarkMemberSelect(dot,propertyIs);\n       RegisterOperators(1, lpar,rpar);\n       RegisterOperators(2, &quot;let&quot;,&quot;in&quot;);\n       RegisterOperators(3, letExp,In);\n       RegisterOperators(4, dot,scopeIn);\n       RegisterOperators(5, not);\n       RegisterOperators(6, &quot;*&quot;,&quot;/&quot;);\n       RegisterOperators(7, letExp,In);\n       RegisterOperators(8, dot,scopeIn);\n       RegisterOperators(9, &quot;+&quot;,&quot;-&quot;);\n       RegisterOperators(10, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;);\n       RegisterOperators(11, &quot;=&quot;, &quot;&lt;&gt;&quot;);\n       RegisterOperators(12, and);\n       RegisterOperators(13, or);\n       RegisterOperators(14, xor);\n       RegisterOperators(15, &quot;=&quot;, &quot;&lt;&gt;&quot;);\n\n       this.Root = specification; \n    }\n\n     public override void SkipWhitespace(ISourceStream source) {\n          while (!source.EOF()) {\n                 var ch = source.PreviewChar;\n                 switch (ch) {\n                              case ' ':\n                              case '\\t':\n                              case '\\r':\n                              case '\\n':\n                              case '\\v':\n                              case '\\u2085':\n                              case '\\u2028':\n                              case '\\u2029':\n                                    source.PreviewPosition++;\n                                    break;\n                              default:\n                              //Check unicode class Zs\n                              UnicodeCategory chCat = char.GetUnicodeCategory(ch);\n                              if (chCat == UnicodeCategory.SpaceSeparator) //it is whitespace, continue moving\n                                  continue;//while loop \n                              //Otherwize return\n                              return;\n                }//switch\n           }//while\n     }\n\n     protected override MyAstContext GetContext(LanguageData language) \n     {\n        return new MyAstContext(language);\n     }</code></pre>\n\n}<br />\n<pre><code> public class MyAstContext :PGSoftwareSolutionsInc.PGIrony.AstContext  {\n    public MyAstContext(LanguageData language) : base(language) {}\n}\n\n public class TypedNonTerminal&lt;TAstNode&gt; : TypedNonTerminal&lt;MyAstContext,TAstNode&gt; \n where TAstNode : AstNode&lt;MyAstContext&gt;{}\n\n      public class     specificationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     specificationBodyAstNode : ListNode&lt;MyAstContext&gt; {}  \n      public class     packageAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     packagesAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     oclPackageAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     emofOclPackageAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     packageBodyAstNode : ListNode&lt;MyAstContext&gt; {} \n      public class     packageBodyItemAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     contextExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     classTypeAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     enumerationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     primitiveAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     primitiveTypeDeclerationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     primitiveTypesAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     delimitedIdentifierAstNode : ListNode&lt;MyAstContext&gt; {} \n      public class     classSignatureAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     classBodyAstNode : ListNode&lt;MyAstContext&gt; {} \n      public class     classBodyItemAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     invExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     functionDefinationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     attributeDiclarationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     emofAttributeDiclarationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     oclAttributeDiclarationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     typeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     expressionAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     customTypeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     collectionTpyeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     fullTypeAstNode : ListNode&lt;MyAstContext&gt; {} \n      public class     globalTypeAstNode : ListNode&lt;MyAstContext&gt; {} \n      public class     setTypeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     orderedSetTypeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     sequenceTypeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     bagTypeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     functionSignatureAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     functionSignatureBodyAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     functionBodyAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     oclFunctionSignatureAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     emofFunctionSignatureAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     argumentListAstNode : ListNode&lt;MyAstContext&gt; {}  \n      public class     variableDiclarationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     emofFunctionBodyAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     oclfunctionBodyAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     singleValueCollectionMemberAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     booleanValueCollectionAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     letExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     ifThenElseExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     collectionValueExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     sumAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     sizeAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     firstAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     lastAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     atAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     indexOfAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     CountOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     maxOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     minOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     valueExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     includesOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     includesAllExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     excludesOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     excludesAllOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     isEmptyOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     notEmptyOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     specialIteratorBodyExpAstNode : AstNode&lt;MyAstContext&gt; {}        \n      public class     existsExpAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     forallExpAstNode : AstNode&lt;MyAstContext&gt; {}    \n      public class     isUniqueExpAstNode : AstNode&lt;MyAstContext&gt; {}    \n      public class     anyExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     oneExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     selectExpAstNode : AstNode&lt;MyAstContext&gt; {}   \n      public class     includingOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     excludingOperationAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     collectAstNode : AstNode&lt;MyAstContext&gt; {}   \n      public class     subOrderedSetAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     symmetricDifferenceAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     prependAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     appendAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     insertAtAstNode : AstNode&lt;MyAstContext&gt; {}  \n      public class     intersectionAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     unionAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     asBagAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     asSequenceAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     asOrderdSetAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     asSetAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     flattenAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     subSequenceAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     andExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     orExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     notExpAstNode : AstNode&lt;MyAstContext&gt; {} \n      public class     xorExpAstNode : AstNode&lt;MyAstContext&gt; {} </code></pre>\n\n",
    "PostedDate": "2013-03-30T08:13:15.84-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023249",
    "ThreadId": "438465",
    "Html": "<pre><code>public class     impliesExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     binaryOperatorAstNode : AstNode&lt;MyAstContext&gt; {}  \n          public class     comparisonOperatorAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     arithmaticOperatorAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     oclInvExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     emofInvExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     operationContextExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     attributeContextExpAstNode : AstNode&lt;MyAstContext&gt; {}  \n          public class     classContextExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     classContextSignatureAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     attributeContextbodyAstNode : ListNode&lt;MyAstContext&gt; {} \n          public class     attributeContextbodyItemAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     deriveExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     initExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     operationContextBodyExpsAstNode : ListNode&lt;MyAstContext&gt; {} \n          public class     operationContextSignatureAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     operationContextBodyItemAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     preConditionAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     postConditionAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     bodyExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     iterateExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     productExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     tupleExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     rejectExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     collectionTypeAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     tuplElementListAstNode : ListNode&lt;MyAstContext&gt; {} \n          public class     tupleElementAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     binaryBooleanOperatorAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     structuralExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     setLiteralExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     bagLiteralAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     orderedSetLiteralAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     sequenceLiteralAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     tupleLiteralAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     literalListAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     iteratorListAstNode : ListNode&lt;MyAstContext&gt; {} \n          public class     iteratorInitializationListAstNode : ListNode&lt;MyAstContext&gt; {} \n          public class     iteratorInitializationAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     collectionValueAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     parameterListAstNode : ListNode&lt;MyAstContext&gt; {} \n          public class     ArrayTypeAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     oclIsTypeOfAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     typedValueExpAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     unTypedValueExpAstNode : ListNode&lt;MyAstContext&gt; {} \n          public class     instanceMemberAccessAstNode : AstNode&lt;MyAstContext&gt; {} \n          public class     instanceMathodAccessAstNode : AstNode&lt;MyAstContext&gt; {}  \n         \n\n}</code></pre>\n\n",
    "PostedDate": "2013-03-30T08:16:28.75-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023251",
    "ThreadId": "438465",
    "Html": "rivantsov\r<br />\n<br />\nThanks for your response I have put the entire grammar above please help me to find out what is going wrong.\r<br />\n<br />\nNadvi<br />\n",
    "PostedDate": "2013-03-30T08:25:35.5-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023331",
    "ThreadId": "438465",
    "Html": "I have seen that if I remove\r<br />\n<br />\n instanceMemberAccess\r<br />\n<br />\nfrom  unTypedValueExp the being crashed is stopped. <br />\n<pre><code>  unTypedValueExp.Rule = booleanValueCollection\n                                       |ToTerm(&quot;false&quot;)|ToTerm(&quot;true&quot;)\n                                   |collectionValue\n                                   |tupleLiteral\n                                   |singleValueCollectionMember\n                                   |collectionValueExp\n                                       |iterateExp\n                                       |stringLiteral\n                                       |charLiteral\n                                       |number\n                                       |self\n                                       |oclIsTypeOf\n                                       |unTypedValueExp+lpar+parameterList+rpar\n                                   |instanceMemberAccess\n                                       |instanceMathodAccess\n                                       |ToTerm(&quot;-&quot;)+number;</code></pre>\n\n",
    "PostedDate": "2013-03-30T15:30:55.65-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023462",
    "ThreadId": "438465",
    "Html": "please share full grammar as one text file - too much trouble to merge all these pieces\r<br />\nuse ge.tt - one way to do it easily<br />\n",
    "PostedDate": "2013-03-31T09:31:19.703-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023471",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nI have uploaded the grammar file <a href=\"http://ge.tt/9KHTGfc/v/0?c\" rel=\"nofollow\">SLAang</a>\r<br />\n<br />\nWith regards \r<br />\nNadvi<br />\n",
    "PostedDate": "2013-03-31T09:59:11.353-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023482",
    "ThreadId": "438465",
    "Html": "immediately hit this:\r<br />\n<br />\nparameterList.Rule = MakeStarRule(parameterList,comma,valueExp)|ifThenElseExp;\r<br />\n<br />\nthis is abs wrong thing to do - MakeStarRule result should NOT be messed up with anything on assignment\r<br />\nFind all places like these and fix<br />\n",
    "PostedDate": "2013-03-31T10:33:04.143-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023488",
    "ThreadId": "438465",
    "Html": "Thank you for quick response \r<br />\n<br />\nI have done \r<br />\nparameterList.Rule = MakeStarRule(parameterList,comma,expression);\r<br />\n<br />\nbut no change.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-03-31T10:42:45.757-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023494",
    "ThreadId": "438465",
    "Html": "you have another case here:<br />\n<pre><code>  argumentList.Rule = MakePlusRule(argumentList, comma, variableDiclaration) | Empty;</code></pre>\n\njust change it to MakeStarRule\r<br />\nAbout the grammar - too many external dependencies, it's not runnable for me. Please refactor into a single compilable file/class. In general, it is a good practice to start with straight grammar-only stuff, make sure it works, and then add AST/execution stuff - but in such a way that it can be easily pushed-out, and have back grammar-only file<br />\n",
    "PostedDate": "2013-03-31T10:56:51.667-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023518",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir,\r<br />\n<br />\n<br />\nThank you for your advice.\r<br />\n<br />\nI changed according to your advice but no change .\r<br />\n<br />\nI uploaded the grammar file and the source file to be parsed both are open able by notepad. The link is <a href=\"http://ge.tt/9KHTGfc?c\" rel=\"nofollow\">Grammar and source</a>\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-03-31T12:59:07.79-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023523",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum \r<br />\n<br />\nI have an observation . The non terminal fullType and instanceMemberAccess is as follows \r<br />\n<br />\n   fullType -&gt; Identifier :: fullType \r<br />\n   fullType -&gt; Identifier \r<br />\n<br />\n   instanceMemberAccess -&gt; instanceMemberAccess . Identifier \r<br />\n   instanceMemberAccess -&gt; Identifier \r<br />\n<br />\nbut in parser state S498 and S522<br />\n<pre><code>fullType -&gt; Identifier · [.]\ninstanceMemberAccess -&gt; Identifier · [. ( -&gt; &gt; &lt; &gt;= &lt;= &lt;&gt; = / div * + - and or xor implies )]\n</code></pre>\n\nMy question is why is the lookahead  [.] for fullType.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-03-31T13:18:58.817-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023550",
    "ThreadId": "438465",
    "Html": "here's my findings:<br />\n<ol>\n<li>Has valueExp and ValueExp - is it intentional?!</li>\n<li>\nNeed to register div, implies as op:<br />\n  RegisterOperators(12, &quot;div&quot;, &quot;implies&quot;);\n</li>\n<li>\nAdd PreferShift in variableDeclaration: <br />\n  variableDiclaration.Rule = identifier + PreferShiftHere() + colon + type;<br />\n</li>\n</ol>\nthen grammar has no conflicts. It fails to parse your large file, smth to do with &quot;::&quot; double-colon separated lists, work on this\r<br />\nI did NOT encounter any Irony parser crashes as you reported at the beginning of this thread. Do you still have them? It can be connected to these Make-list fixes.. \r<br />\nRoman<br />\n",
    "PostedDate": "2013-03-31T15:26:43.657-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023599",
    "ThreadId": "438465",
    "Html": "answering your previous question, about [.] lookahead. Lookaheads are symbols that might appear AFTER the expression, so they mostly come from other Rules that use the non-terminal, not from the rule of NT itself. So for fullType, the dot comes from some other rule(s) that use fulltype - find them, analyze, and you'll probably find it.<br />\n",
    "PostedDate": "2013-03-31T20:13:06.623-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1023826",
    "ThreadId": "438465",
    "Html": "As-Salam-Wa-alicum\r<br />\n<br />\nSir,\r<br />\n<br />\nThank you very much for spending your valuable time for me. I apologies for my unintentional mistake.For removing TypedNonterminal I ran a replace operation which replaced the tyed from typedValueEx.I have register\r<br />\n<br />\n RegisterOperators(6, &quot;*&quot;, &quot;/&quot;, &quot;div&quot;); \r<br />\n RegisterOperators(15, &quot;implies&quot;)\r<br />\n<br />\nand changed variableDiclaration according to your advice.\r<br />\n<br />\nPlease give me a guidance on working on  &quot;::&quot; double-colon.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-04-01T09:13:39.293-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1024046",
    "ThreadId": "438465",
    "Html": "Wa-alicum-As-Salam\r<br />\nWell, not sure when I can get to this. Look at grammar rules, are missing anything around this :: symbol? It might be also the consequence of all these PreferShiftHere() and ReduceThis() hints you sprinkled everywhere. These hints effectively hide the conflict, telling the parser to use one alternative, always. And the error case you see might be in fact suppressed alternative.\r<br />\nRoman<br />\n",
    "PostedDate": "2013-04-01T22:35:16.467-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1032732",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir,\r<br />\n<br />\nThank you very much for your advice and by that I can remove the grammar errors but the &quot;Fatal error in code colorizer.Colorizing has been disabled&quot; comes again.\r<br />\nPlease help me to find-out what mistake I have done here.I have removed 2 Make List rule by recursion and they work well.\r<br />\n<br />\nI have uploaded DebugLog.xml which records the exception,stacktrace and tokens.I also have uploaded  the grammar file and the test file at <a href=\"http://ge.tt/4DEXVSe\" rel=\"nofollow\">Files</a>.\r<br />\n<br />\nThe summary of the exception is _shiftAction.NewState is null at Irony.Parsing.PrecedenceBasedParserAction.ToString().\r<br />\nThe concern is why it is null for a specific case and how to make it not null from grammar.\r<br />\n<br />\nThank you very much again for reading my mail by spending your valuable time.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-04-18T15:32:47.337-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1032825",
    "ThreadId": "438465",
    "Html": "no problem, will try to look at it soon, maybe on weekend, sorry can't promise immediate response<br />\n",
    "PostedDate": "2013-04-18T23:31:46.903-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1033710",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir,\r<br />\n<br />\nThank you very much for quick response.For pinpointing the problem I further debugged and get the following output<br />\n<pre><code>&lt;Looging threadName = &quot;&quot; threadId = &quot;9&quot;&gt;\n&lt;MethodStatus message = &quot;Calling S416.BuilderData.GetNextState(.) \n                                         from Irony.Parsing.PrecedenceHint.Apply(Irony.Parsing.LanguageData, \n                                            instanceName - gt  Identifier ·)&quot; threadName = &quot;&quot; threadId = &quot;9&quot; /&gt;\n&lt;MethodStatus message = &quot;newState is null&quot; threadName = &quot;&quot; threadId = &quot;9&quot; /&gt;\n&lt;MethodStatus message = &quot;ReduceItem is:instanceName - gt  Identifier &quot; threadName = &quot;&quot; threadId = &quot;9&quot; /&gt;\n&lt;MethodStatus message = &quot;Calling S573.BuilderData.GetNextState(.) \n                                          from Irony.Parsing.PrecedenceHint.Apply(Irony.Parsing.LanguageData, \n                                            instanceName - gt  Identifier ·)&quot; threadName = &quot;&quot; threadId = &quot;9&quot; /&gt;\n&lt;MethodStatus message = &quot;newState is null&quot; threadName = &quot;&quot; threadId = &quot;9&quot; /&gt;\n&lt;MethodStatus message = &quot;ReduceItem is:instanceName - gt  Identifier &quot; threadName = &quot;&quot; threadId = &quot;9&quot; /&gt;\n&lt;/Looging&gt;</code></pre>\n\nThe related states are<br />\n<pre><code>State S416 (Inadequate)\n  Reduce items:\n    instanceName -&gt; Identifier · [.]\n    memberName -&gt; Identifier · [. -&gt; &gt; &lt; &gt;= &lt;= &lt;&gt; = / div * + - and or xor implies pre body post } )\n                                               then , endif else in | init derive primitive enumeration \n                                               class abstract context package inv invariant def Identifier component endpackage]\n    functionName -&gt; Identifier · [(]\n  Transitions: \n\nState S573 (Inadequate)\n  Reduce items:\n    instanceName -&gt; Identifier · [.]\n    memberName -&gt; Identifier · [. -&gt; &gt; &lt; &gt;= &lt;= &lt;&gt; = / div * + - and or xor implies pre body post } )\n                                               then , endif else in | init derive primitive enumeration\n                                               class abstract context package inv invariant def Identifier component endpackage]\n  Transitions: </code></pre>\n\nThe summary is from high level the problematic grammar rules are<br />\n<pre><code>             instanceName.Rule = identifier;\n            memberName.Rule = identifier;</code></pre>\n\nNow the concern is the rules works in others state like S151 well<br />\n<pre><code>State S151 (Inadequate)\n  Reduce items:\n    objectType -&gt; Identifier · [::]\n    instanceName -&gt; Identifier · [. -&gt; &gt; &lt; &gt;= &lt;= &lt;&gt; = / div * + - and or xor implies pre body post inv \n                                              invariant def Identifier component } primitive \n                                              enumeration   class abstract context package\n                                              endpackage ) then , endif else in | init derive]\n    functionName -&gt; Identifier · [(]\n  Transitions: </code></pre>\n\nplease help me here to find out the problem in the rule.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-04-21T19:20:27.943-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1033794",
    "ThreadId": "438465",
    "Html": "Ok, finally got to it. First, there were a few compile errors in grammar - missing non-terminal declarations (typedValueExp, unTypedValueExp), added these. Then reproduced the exception that disables the colorizer- it appears a bug: Precedence hint tried to fix the conflict in places where it is unfixable. I fixed the bug (added some validation code) and pushed sources - get latest, not zip but Sources from Mercurial. \r<br />\nThe added code in fix brings 2 extra conflicts in grammar. They appear to come from the problematic rules that you mention - for instanceName and memberName. The problem here is that all these names are 'identical' for parser; they are introduced in formal grammar description to clarity (of explanation) but they bring conflict to LALR parser. Remove memberName, instanceName non-terminals from grammar and replace all occurrences in rules with 'identifier'. Find all other rules that similarly introduce just alias for another term, like memberName - this brings conflict. Fix all these rules. \r<br />\nAnd without without fixing these conflicts, parsing of sample fails. Another thing - do not register 'dot' as operator. Don't do things just to make conflicts go away - fix them for real!\r<br />\nRoman<br />\n",
    "PostedDate": "2013-04-22T00:29:21.053-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1034214",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir,\r<br />\n<br />\nThank you very much for fixing the error .Would you like to advice me on how can I clarify the grammar because after parsing when I process the parse tree or abstract syntax  tree it hep me to do by traversing .\r<br />\n<br />\nThank you very much again for reading my mail by spending your valuable time and fixing the error quickly .\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-04-22T16:34:29.127-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1034256",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir, \r<br />\n<br />\nIf I remove dot from operator registration I get 8 conflict please help me here .\r<br />\n<br />\nl uploaded the grammar file at <a href=\"http://ge.tt/4DEXVSe\" rel=\"nofollow\">SLAng Grammar</a>\r<br />\n<br />\nThank you very much again for reading my mail by spending your valuable time.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-04-22T18:35:05.947-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1034977",
    "ThreadId": "438465",
    "Html": "looking into this<br />\n",
    "PostedDate": "2013-04-24T00:42:44.37-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1034986",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir, \r<br />\n<br />\nMay be the link is missing.\r<br />\n<br />\nThank you for response.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-04-24T01:02:50.703-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1035210",
    "ThreadId": "438465",
    "Html": "no, nothing is missing, what I meant is that I'm working on it, expect response soon<br />\n",
    "PostedDate": "2013-04-24T09:52:50.307-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1035318",
    "ThreadId": "438465",
    "Html": "here's fixed version:\r<br />\n<a href=\"http://ge.tt/94592ye/v/0?c\" rel=\"nofollow\">http://ge.tt/94592ye/v/0?c</a><br />\n",
    "PostedDate": "2013-04-24T13:43:06.32-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1035321",
    "ThreadId": "438465",
    "Html": "Now some comments<br />\n<ol>\n<li>The biggest problem is compound identifier lists - identifiers or function calls connected with dots: 'foo.Bar(x).prop' More problems come from other similar lists with delimiters &quot;::&quot; and &quot;-&gt;&quot; instead of dot. This is a kinda known problem (same happens in c#), attempt to define exact definitions of each list separately brings a lot of conflicts. So the solution is to define one generic list that covers all variations, let it parse, and then verify after parsing that the parsed list is valid for the place in the source. I defined such list as chainedSequenceExt - it is a sequence of identifiers or function calls, optionally starting with &quot;::&quot;, delimited by &quot;::&quot;, &quot;.&quot; or &quot;-&gt;&quot;, and ending with array spec (like [number]). Here is the definition:</li>\n</ol>\n<pre><code>      var sequenceDelimiter = new NonTerminal(&quot;sequenceDelimiter&quot;); //dot, ::,  -&gt;\n      var chainedSequence = new NonTerminal(&quot;chainedSequence&quot;);\n      var chainedSequenceExt = new NonTerminal(&quot;chainedSequenceExt&quot;); \n      var sequenceMember = new NonTerminal(&quot;sequenceMember&quot;);\n      var arrayDim = new NonTerminal(&quot;arrayDim&quot;);\n      var arraySpecOpt = new NonTerminal(&quot;arraySpecOpt&quot;);\n\n      sequenceMember.Rule = identifier | functionCall;\n      sequenceDelimiter.Rule = dot | scopeIn | propertyIs; // . :: -&gt;\n      chainedSequence.Rule = MakePlusRule(chainedSequence, sequenceDelimiter, sequenceMember); \n      arrayDim.Rule = &quot;*&quot; | identifier | number | number + comma + number | number + comma + &quot;*&quot;;\n      arraySpecOpt.Rule = Empty | &quot;[&quot; + arrayDim + &quot;]&quot;;\n      // Note: defining scopeInOpt (with rule: Empty|scopeIn) - does not work. \n      chainedSequenceExt.Rule = scopeIn + chainedSequence + arraySpecOpt | chainedSequence + arraySpecOpt;\n</code></pre>\n\nUse it in all places instead of objectType, customType, etc. I did not remove these, just reassigned them (like 'var customType = chainedSequenceExt;') - cleanup all these. There are many terms and nonTerminals now declared but not used anymore - clean this up.<br />\nAnd remember - you need to add after-parse verification of the chainedSequenceExt lists. <br />\n<br />\nNote that in most places (like in expression argument), a single identifier is in fact a primitive case of chainedSequenceExt; so if you have already included chainedSequenceExt as an alternative of some rule, do not include identifier - it will bring conflict, because parser does not know which to use to interpret a single identifier.   \n<br />\n<ol>\n<li>\nYour other trouble comes from the attempt to define concrete function names in grammar (like 'collect', 'insertAt'), and to define rules for using them explicitly. This messes up things completely. Do not do this, they are just function calls, so let them be parsed as this. Recognize them as special, built-in methods when analysing the parse tree. I removed/disabled all these special function definitions <br />\nAfter this all conflicts are gone. The grammar now 'defines' a broader language, so it must be supplemented with after grammar checks - do it.<br />\n</li>\n<li>\nHad to bring dot as operator back. It appears you allow dot to be applied to expressions, like: <br />\n(t - startDate.inMs()).round()<br />\n<br />\nso added dot to binaryOperator and set to highest prec value<br />\n</li>\n<li>\nNow have a parse error, unexpected &quot;;&quot; symbol here, right after 'Schedule'<br />\n</li>\n</ol>\n<pre><code>  schedule-&gt;iterate(s : Schedule ; \n                    next : Schedule = schedule-&gt;any(true) |\n                    if next.nextStartDate(t) = -1   </code></pre>\n\nI did not find &quot;;&quot; symbol defined anywhere in grammar, so this is something missing or not implemented yet. <br />\n",
    "PostedDate": "2013-04-24T13:46:13.46-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1035414",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir, \r<br />\n<br />\nThank you very much . You are working hard for this. In my thesis I will acknowledge you.Actually you removed the iterateExp that's why these lines are not parsed.I have add the code to functionCallArgs but stile it gives parser error.Invalid  character ';' but in immediate previous grammar it was parse able.Please help me here.From this grammar it seems to me that after parsing a lot of work has to do. To avoid the work I explicitly define the expressions .\r<br />\n<br />\nI uploaded the grammar at <a href=\"http://ge.tt/4DEXVSe\" rel=\"nofollow\">SLAng grammar</a>\r<br />\n<br />\nThank you very much again for reading my mail by spending your valuable time and working on it.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-04-24T19:51:15.257-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1036192",
    "ThreadId": "438465",
    "Html": "Man, it's time to take over the thing, rollup your sleeves and start pushing it. I've fixed all the conflicts (the most serious ones), so now you can move in small increments. Just start modifying this parameter definition when it is a 'lambda' to bring back the old code I removed - as far as I understand this is the problem now\r<br />\nTry it, read something about LALR parsing and about conflicts, try it again. Let me know if you're stuck\r<br />\nRoman<br />\n",
    "PostedDate": "2013-04-26T10:16:58.95-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1042451",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum\r<br />\n<br />\nSir,\r<br />\n<br />\nThank you very much for your effort but the way you advice need so many work at comiletime to determine the actual thing because of its generality \r<br />\nand it is possible to make it a little more specific.I did it but when I try to refactor emofAttributeDiclaration,functionSignatureBody and ArrayType so \r<br />\nmany conflict come.Please help me here.My grammar file and the test file is <a href=\"http://ge.tt/67HuuRg\" rel=\"nofollow\">here</a>  By the way do you have the original grammar\r<br />\nfile on which you do work to fix conflict?\r<br />\n<br />\nThank you very much again for reading my mail by spending your valuable time and working on it.\r<br />\n<br />\nWith regards\r<br />\nNadvi<br />\n",
    "PostedDate": "2013-05-12T08:10:37.943-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1043559",
    "ThreadId": "438465",
    "Html": "hi\r<br />\nsorry, do not have much time right now, it would be a few days\r<br />\nRoman<br />\n",
    "PostedDate": "2013-05-14T14:24:21.793-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1049393",
    "ThreadId": "438465",
    "Html": "Hi<br />\nLooking at your grammar, and at OCL spec (<a href=\"http://www.omg.org/spec/OCL/ISO/19507/PDF\" rel=\"nofollow\">http://www.omg.org/spec/OCL/ISO/19507/PDF</a>)<br />\nOne conflict is <br />\nReduce-reduce conflict. State S418, lookaheads: ). Selected reduce on first production in conflict set.<br />\n<br />\nThe conflict is coming from these  2 productions in state S418<br />\n<br />\n   functionCall -&gt; Identifier ( ·parameterList ) <br />\n   collect  -&gt; valueExp . Identifier ( ·argumentList ) <br />\n<br />\n(The actual conflict is for empty lists inside parenthesis, parser does not know how to treat it - as empty parameterList or argumentList)<br />\nNow, looking at the language spec, section 7.7.2, subsection shorthand for collect - can't quite match it... shouldn't it be parameterList instead of argumentList?<br />\nArgumentList consists of var declarations like  'var + : + type' , and I don't find anything like this in the spec - but paramList is there.<br />\nWhen I change to parameterList in the grammar, the conflict goes away<br />\n",
    "PostedDate": "2013-05-27T21:05:03.097-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1049395",
    "ThreadId": "438465",
    "Html": "another thing: bagLiteral has empty name in grammar code<br />\n",
    "PostedDate": "2013-05-27T21:07:14.773-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1051848",
    "ThreadId": "438465",
    "Html": "As-Salam-wa-alicum<br />\n<br />\nSir,<br />\n<br />\nThank you very much for your effort and thats are very helpful.I get another shift-reduce conflicts with the <br />\n<br />\nattributeModifir.Rule = ToTerm(&quot;component&quot;) | Empty;<br />\n<br />\nplease help me here.I have uploaded the grammar code <a href=\"http://ge.tt/7f9vGJi/v/0\" rel=\"nofollow\">here</a>.<br />\n<br />\nThank you very much again for reading my mail by spending your valuable time and working on it.<br />\n<br />\nWith regards<br />\nNadvi<br />\n",
    "PostedDate": "2013-06-02T13:20:08.617-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
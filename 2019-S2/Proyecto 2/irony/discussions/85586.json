[
  {
    "Id": "291505",
    "ThreadId": "85586",
    "Html": "<p>Hi, I've created a grammar for a very basic language. Basically you can write: {someguid1} [, dist({someguid2}[ , : {someguid3}] )].</p>\r\n<p>The problem is that it's taking roughly 15ms to generate the parse tree which is unacceptable as there are a large number (up to ~60000) strings to parse. Typically the number of terminals within the string won't be very large (generally &lt; 5, possibly up to 50).</p>\r\n<p>I'll be running a profiler over this in the coming days but thought I'd ask if there are any obvious tips before I begin?</p>\r\n<p>Thanks in advance.</p>\r\n<p>Michael</p>\r\n<p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">Imports</span> Irony.Parsing\r\n\r\n<span style=\"color:Blue\">Namespace</span> Grammars\r\n    &lt;Language(<span style=\"color:#A31515\">&quot;Qubit LocSpec GUID Format&quot;</span>, <span style=\"color:#A31515\">&quot;1.0&quot;</span>, <span style=\"color:#A31515\">&quot;Grammar for the definition of a persisted location specification within a dimension.&quot;</span>)&gt; _\r\n    <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Class</span> clsLocSpecGuidGrammar\r\n        <span style=\"color:Blue\">Inherits</span> clsQubitGrammar\r\n\r\n<span style=\"color:Blue\">#Region</span> <span style=\"color:#A31515\">&quot;Constuctors&quot;</span>\r\n\r\n        <span style=\"color:Green\">' Matches a GUID (e.g. '{00000000-0000-0000-0000-000000000000}')</span>\r\n        <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Const</span> GuidRegex <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;\\{[0-9a-f]{8}\\-[0-9a-f]{4}\\-[0-9a-f]{4}\\-[0-9a-f]{4}\\-[0-9a-f]{12}\\}&quot;</span>\r\n\r\n        <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Const</span> StatementsIdentifier <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;stmts&quot;</span>\r\n        <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Const</span> StatementIdentifer <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;stmt&quot;</span>\r\n        <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Const</span> GuidsIdentifier <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;guids&quot;</span>\r\n\r\n        <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Const</span> GuidIdentifier <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;guid&quot;</span>\r\n        <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Const</span> ValueDistributionIdentifer <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;valueDist&quot;</span>\r\n        <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Const</span> VariableDistributionIdentifer <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;variableDist&quot;</span>\r\n        <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Const</span> VariableIdentifier <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;variable&quot;</span>\r\n\r\n        <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Sub</span> <span style=\"color:Blue\">New</span>()\r\n            <span style=\"color:Blue\">MyBase</span>.<span style=\"color:Blue\">New</span>(<span style=\"color:Blue\">False</span>) <span style=\"color:Green\">' False means case insensitive</span>\r\n\r\n            GrammarComments = <span style=\"color:#A31515\">&quot;Expressions for persisted dimension location specifications.&quot;</span>\r\n\r\n            <span style=\"color:Blue\">Dim</span> stmts = <span style=\"color:Blue\">New</span> NonTerminal(StatementsIdentifier)\r\n            <span style=\"color:Blue\">Dim</span> stmt = <span style=\"color:Blue\">New</span> NonTerminal(StatementIdentifer)\r\n\r\n            <span style=\"color:Blue\">Dim</span> valueDist = <span style=\"color:Blue\">New</span> NonTerminal(ValueDistributionIdentifer)\r\n            <span style=\"color:Blue\">Dim</span> variableDist = <span style=\"color:Blue\">New</span> NonTerminal(VariableDistributionIdentifer)\r\n\r\n            <span style=\"color:Blue\">Dim</span> guids = <span style=\"color:Blue\">New</span> NonTerminal(GuidsIdentifier)\r\n\r\n            <span style=\"color:Blue\">Dim</span> guid = <span style=\"color:Blue\">New</span> RegexBasedTerminal(GuidIdentifier, GuidRegex)\r\n\r\n            <span style=\"color:Blue\">Dim</span> variable = <span style=\"color:Blue\">New</span> RegexBasedTerminal(VariableIdentifier, GuidRegex)\r\n\r\n            <span style=\"color:Blue\">Dim</span> dist <span style=\"color:Blue\">As</span> KeyTerm = ToTerm(<span style=\"color:#A31515\">&quot;dist&quot;</span>)\r\n            <span style=\"color:Blue\">Dim</span> leftBracket <span style=\"color:Blue\">As</span> KeyTerm = ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>)\r\n            <span style=\"color:Blue\">Dim</span> rightBracket <span style=\"color:Blue\">As</span> KeyTerm = ToTerm(<span style=\"color:#A31515\">&quot;)&quot;</span>)\r\n            <span style=\"color:Blue\">Dim</span> comma <span style=\"color:Blue\">As</span> KeyTerm = ToTerm(<span style=\"color:#A31515\">&quot;,&quot;</span>)\r\n            <span style=\"color:Blue\">Dim</span> colon <span style=\"color:Blue\">As</span> KeyTerm = ToTerm(<span style=\"color:#A31515\">&quot;:&quot;</span>)\r\n\r\n            <span style=\"color:Green\">' Specify the non-terminal which is the root of the AST.</span>\r\n            Root = stmts\r\n\r\n            stmts.Rule = MakePlusRule(stmts, comma, stmt)\r\n            stmt.Rule = valueDist <span style=\"color:Blue\">Or</span> variableDist <span style=\"color:Blue\">Or</span> guid\r\n\r\n            guids.Rule = MakePlusRule(guids, comma, guid)\r\n\r\n            variableDist.Rule = dist + leftBracket + guids + colon + variable + rightBracket\r\n            valueDist.Rule = dist + leftBracket + guids + rightBracket\r\n\r\n            RegisterPunctuation(dist, leftBracket, rightBracket, comma, colon)\r\n\r\n            LanguageFlags = LanguageFlags.CreateAst\r\n        <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Sub</span>\r\n\r\n<span style=\"color:Blue\">#End Region</span>\r\n\r\n    <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Class</span>\r\n\r\n<span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Namespace</span>\r\n</pre>\r\n</div>\r\n</p>",
    "PostedDate": "2010-02-16T16:56:15.657-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "291519",
    "ThreadId": "85586",
    "Html": "<p>I think it's obvious - use of Regex terminal. It eats all your processing time,&nbsp;regex's are inherently slow. Write custom Guid terminal.</p>",
    "PostedDate": "2010-02-16T18:27:41.027-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "291773",
    "ThreadId": "85586",
    "Html": "<p>As a second thought - you might create your custom&nbsp;GuidTerminal by sub-classing it from DataTerminalBase and override method ConvertValue.</p>",
    "PostedDate": "2010-02-17T09:31:02.887-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "291965",
    "ThreadId": "85586",
    "Html": "<p>I only just noticed your second suggestion -- and I haven't tried it -- although I don't imagine it would speed things up? Also, did you mean DataLiteralBase or is there a new class that released recently that I don't have in my build?</p>\r\n<p>I've tested the RegexBasedTerminal against the (VERY simple - assume that { is disallowed unless it's a valid GUID) GuidTerminal below and the difference is basically identical (35626ms using RegexBasedTerminal, 35895 using the GuidTerminal). I'm still planning on pulling out a profiler when I get a chance (this is actually a completed piece of functionality that could probably be improved.)</p>\r\n<p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>        <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Class</span> GuidTerminal\r\n            <span style=\"color:Blue\">Inherits</span> Terminal\r\n\r\n            <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Sub</span> <span style=\"color:Blue\">New</span>(<span style=\"color:Blue\">ByVal</span> name <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span>)\r\n                <span style=\"color:Blue\">MyBase</span>.<span style=\"color:Blue\">New</span>(name)\r\n            <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Sub</span>\r\n\r\n            <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Overloads</span> <span style=\"color:Blue\">Overrides</span> <span style=\"color:Blue\">Function</span> TryMatch(<span style=\"color:Blue\">ByVal</span> context <span style=\"color:Blue\">As</span> ParsingContext, <span style=\"color:Blue\">ByVal</span> source <span style=\"color:Blue\">As</span> ISourceStream) <span style=\"color:Blue\">As</span> Token\r\n                <span style=\"color:Blue\">If</span> (source.PreviewChar &lt;&gt; <span style=\"color:#A31515\">&quot;{&quot;</span>c) <span style=\"color:Blue\">Then</span>\r\n                    <span style=\"color:Blue\">Return</span> <span style=\"color:Blue\">Nothing</span>\r\n                <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">If</span>\r\n\r\n                source.PreviewPosition += 38 <span style=\"color:Green\">' Length of a GUID.</span>\r\n\r\n                <span style=\"color:Blue\">Return</span> source.CreateToken(OutputTerminal)\r\n            <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Function</span>\r\n\r\n        <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Class<br></span> <br></pre>\r\n</div>\r\n</p>",
    "PostedDate": "2010-02-17T18:11:17.833-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "292286",
    "ThreadId": "85586",
    "Html": "<p>How are you measuring performance? what are these numbers you provide? Are you measuring the time in Grammar Explorer or some similar tool with UI? Keep in mind that you may be measuring time it takes to fill the tree/listbox/grid - whatever you use for display. 35 seconds seem like very long time, on average Irony parses at 10k lines per second for complex grammar like c#, unless you are parsing 500k lines file. Try it in grammar explorer - it shows you pure parsing time, without time spent on updating UI.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-02-18T10:07:19.087-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "412534",
    "ThreadId": "85586",
    "Html": "<p>Hi. Firstly, apologies for the slow reply.</p>\r\n<p>I was performing the timing using a Stopwatch which was started directly before the .Parse() and stopped directly afterwards. What was interesting to note was that the times seemed to fluctuate massively, even though the input was relativey the same (the input is a actually a large number of small fragments (up to ~60, 000), rather than one large fragment).</p>\r\n<p>After some more research it appeared that the problem only happened in debug mode while referencing a release DLL, which is very strange behaviour. For the moment I've added the Irony project to our solution which is an immediate fix - it works fast in debug and is compiled as a release DLL.</p>\r\n<p>When I get some more time I'll certainly be looking into this more as it seems like very, very strange behaviour.</p>\r\n<p>Thanks for all your assistance. The parsing times are now basically negligible with respect to the other processing that takes place.</p>",
    "PostedDate": "2010-02-28T16:48:53.833-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "413284",
    "ThreadId": "85586",
    "Html": "<p>Hi</p>\r\n<p>I think I know what the problem is. The key here is your phrase that the input is large number of small fragments rather than one big file. If you look at SourceStream class, you'll see that there are two different implementations of CurrentChar method - for &nbsp;debug and release. In release mode I don't check for boundaries but allow IndexOutOfRangeException to be thrown. The idea was that it happens once at the end of (supposedly) long file, so it would be better for performance to let it happen but in return to gain on avoiding the boundaries check. Now I see that in situation like yours it can really hurt. I will probably get rid of release version and switch to always use &quot;Debug&quot; variant, with boundary checks.</p>\r\n<p>thanks for the hint</p>\r\n<p>roman</p>",
    "PostedDate": "2010-03-02T10:18:03.843-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "413472",
    "ThreadId": "85586",
    "Html": "<p>Hi Roman,</p>\r\n<p>The funny thing is I read your discussion with Kirill Osenkov (him asking about live geometry/Silverlight) and did look at the code and saw the #DEBUG/#RELEASE stuff. What I'm confused about is the fact that it was only slow when referencing a release DLL in a debug environment, as opposed to a release DLL in a release environment (which was fine). AFAIK the conditionals should be evaluated when the DLL is compiled -- thus there should be no difference whatsoever if the DLL is referenced from within a debug environment or a release environment?</p>\r\n<p>When I get some time I'll look into it further.</p>\r\n<p>Cheers,</p>\r\n<p>Michael</p>",
    "PostedDate": "2010-03-02T18:51:07.453-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "458160",
    "ThreadId": "85586",
    "Html": "<p>Hi Roman,</p>\r\n<p>I stumbled upon this #DEBUG/#RELEASE discussion and decided to add my '2 cents'.</p>\r\n<p>Setting try/catch handler in release version adds more processor cycles then simple IF with boundary check in debug one, not to mention up to 100K+ burned cycles it takes .NET to throw/catch even a single exception.</p>\r\n<p>Using simpler code that looks like .. return PreviewPosition &lt; Text.Length ? Text[PreviewPosition] : '\\0'; will provide best results in this situation, (use &lt; instead of &gt;= for more frequent outcome, as it is better aligned with CPU branch predictor policies).</p>\r\n<p>Cheers, Victor.</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-06-21T11:05:30.233-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
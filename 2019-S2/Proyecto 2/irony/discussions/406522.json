[
  {
    "Id": "955093",
    "ThreadId": "406522",
    "Html": "\r\n<p>I'm new to the whole world of formal language definitions and grammars, and maybe I'm using the wrong tool for the job, but I'd like to use Irony because I've been playing with it and it's just cool...</p>\r\n<p>I want to parse files that should have a certain structure. The file is separated into sections, with each section having a series of options. Options can have values which are double-quoted strings or plus-lists of integers/decimal numbers/&quot;heads&quot;. A &quot;head&quot;\r\n has the form (positive int):(positive int) e.g. 1:6 or 19:3. Comments are started using a ; and last until the end of the line. The whole file might look something like this:</p>\r\n<pre>[section1]   ; section titles are surrounded by square brackets\noption1    =    7\noption2=&quot;some string value&quot;\n\n\n; blank lines are ignored\n\n[another_section]\n\nheads   =1:2,8:1,3:2\nanother_option = 1.0,2.04,0.01</pre>\r\n<p>Each option or section title must be on its own line. Sections cannot be nested.</p>\r\n<p>My attempt at a grammar in Irony looked like this:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">var</span> stringValue = <span style=\"color:blue\">new</span> IdentifierTerminal(<span style=\"color:#a31515\">&quot;String value&quot;</span>);\n<span style=\"color:blue\">var</span> quotedString = <span style=\"color:blue\">new</span> StringLiteral(<span style=\"color:#a31515\">&quot;Quoted string&quot;</span>, <span style=\"color:#a31515\">&quot;\\&quot;&quot;</span>);\n<span style=\"color:blue\">var</span> _decimal = <span style=\"color:blue\">new</span> NumberLiteral(<span style=\"color:#a31515\">&quot;Decimal&quot;</span>);\n<span style=\"color:blue\">var</span> integer = <span style=\"color:blue\">new</span> NumberLiteral(<span style=\"color:#a31515\">&quot;Integer&quot;</span>, NumberOptions.IntOnly | NumberOptions.NoDotAfterInt);\n\n<span style=\"color:blue\">var</span> root = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Root&quot;</span>);\n<span style=\"color:blue\">var</span> section = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Section&quot;</span>);\n<span style=\"color:blue\">var</span> sectionTitle = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Section title&quot;</span>);\n<span style=\"color:blue\">var</span> options = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Options&quot;</span>);\n<span style=\"color:blue\">var</span> option = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Option&quot;</span>);\n<span style=\"color:blue\">var</span> optionName = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Option name&quot;</span>);\n<span style=\"color:blue\">var</span> optionValue = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Option value&quot;</span>);\n<span style=\"color:blue\">var</span> head = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Head&quot;</span>);\n<span style=\"color:blue\">var</span> multipleHeads = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Multiple heads&quot;</span>);\n<span style=\"color:blue\">var</span> multipleInts = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Multiple ints&quot;</span>);\n<span style=\"color:blue\">var</span> multipleDecimals = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;Multiple decimals&quot;</span>);\n\n\n<span style=\"color:blue\">var</span> comma = ToTerm(<span style=\"color:#a31515\">&quot;,&quot;</span>);\n<span style=\"color:blue\">var</span> col = ToTerm(<span style=\"color:#a31515\">&quot;:&quot;</span>);\n<span style=\"color:blue\">var</span> eq = ToTerm(<span style=\"color:#a31515\">&quot;=&quot;</span>);\n\n<span style=\"color:blue\">var</span> lb = ToTerm(<span style=\"color:#a31515\">&quot;[&quot;</span>);\n<span style=\"color:blue\">var</span> rb = ToTerm(<span style=\"color:#a31515\">&quot;]&quot;</span>);\n\nRegisterBracePair(<span style=\"color:#a31515\">&quot;[&quot;</span>, <span style=\"color:#a31515\">&quot;]&quot;</span>);\n\nMarkPunctuation(lb, rb, eq, comma, col);\n\n<span style=\"color:blue\">var</span> comment = <span style=\"color:blue\">new</span> CommentTerminal(<span style=\"color:#a31515\">&quot;Comment&quot;</span>, <span style=\"color:#a31515\">&quot;;&quot;</span>, Environment.NewLine);\nNonGrammarTerminals.Add(comment);\n\n\nroot.Rule = MakePlusRule(root, NewLinePlus, section); <span style=\"color:green\">// NewLinePlus will skip over blank lines?</span>\n\nsection.Rule = sectionTitle &#43; NewLinePlus &#43; options;\nsectionTitle.Rule = lb &#43; stringValue &#43; rb;\noptions.Rule = MakePlusRule(options, NewLinePlus, option);\noption.Rule = optionName &#43; eq &#43; optionValue;\n\n\noptionName.Rule = stringValue;\noptionValue.Rule = quotedString | multipleInts | multipleDecimals | multipleHeads;\nhead.Rule = integer &#43; col &#43; integer;\nmultipleInts.Rule = MakePlusRule(multipleInts, comma, integer);\nmultipleDecimals.Rule = MakePlusRule(multipleDecimals, comma, _decimal);\nmultipleHeads.Rule = MakePlusRule(multipleHeads, comma, head);\n\nRoot = root;\n</pre>\r\n</div>\r\n<p>This gives the conflict: <em>Shift-reduce conflict. State S12, lookaheads [LF]. Selected shift as preferred action.</em></p>\r\n<p><em>State S12 (Inadequate)</em><br>\r\n<em>&nbsp; Shift-reduce conflicts on inputs: LF</em><br>\r\n<em>&nbsp; Shift items:</em><br>\r\n<em>&nbsp;&nbsp;&nbsp; Options -&gt; Options &middot;LF&#43; Option </em><br>\r\n<em>&nbsp;&nbsp;&nbsp; LF&#43; -&gt; &middot;LF </em><br>\r\n<em>&nbsp;&nbsp;&nbsp; LF&#43; -&gt; &middot;LF&#43; LF </em><br>\r\n<em>&nbsp; Reduce items:</em><br>\r\n<em>&nbsp;&nbsp;&nbsp; Section -&gt; Section title LF&#43; Options &middot; [EOF LF]</em><br>\r\n<em>&nbsp; Transitions: LF&#43;-&gt;S17, LF-&gt;S7</em></p>\r\n<p>I'm not sure how to resolve this, or if my approach is completely wrong? I'm also wondering if my handling of the number literals is correct? - Will the parser ever mistake integers and decimals?<em></em></p>\r\n<p>Thanks in advance<em></em></p>\r\n<p><em>-Edit: I'm pretty certain my handling of the numbers is <strong>not</strong> correct, I think I was just being lazy and leaning on Irony's magic to sort it out for me - it doesn't give a conflict after all. Would I need to extend the grammar by a lot\r\n to do this properly? Cheers<br>\r\n</em></p>\r\n",
    "PostedDate": "2012-12-12T06:04:29.09-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "955953",
    "ThreadId": "406522",
    "Html": "\r\n<p>Make NewLinePlus part of rules (at the end), instead of specifying it as list delimiter:</p>\r\n<p>&nbsp;</p>\r\n<p></p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>      root.Rule = MakePlusRule(root, section); <span style=\"color:green\">// NewLinePlus will skip over blank lines?</span>\r\n      section.Rule = sectionTitle + options;\r\n      sectionTitle.Rule = lb + stringValue + rb + NewLinePlus;\r\n      options.Rule = MakePlusRule(options, option);\r\n      option.Rule = optionName + eq + optionValue + NewLinePlus;\r\n\r\n</pre>\r\n</div>\r\n<p></p>\r\n<p>Just checked, no conflicts, it parses 'successfully' your sample, except it errors on colon-delimited list in option value: &quot;1:2,8:1,3:2&quot;</p>\r\n<p>but this is a different story. Set higher priority for 'integer':</p>\r\n<pre>integer.Priority&nbsp;=&nbsp;TerminalPriority.High;</pre>\r\n<p>That fixes it.</p>\r\n<p>In general, I would recommend to avoid defining two conflicting numbers. Better define just decimal, and then after parsing verify that in places where only integer is allowed, there's in fact integer.</p>\r\n<p>&nbsp;</p>\r\n",
    "PostedDate": "2012-12-13T23:36:52.48-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956107",
    "ThreadId": "406522",
    "Html": "\r\n<p>Thanks Roman, that did work. I've modified the grammar to exclude the different types of number, and also to allow more general strings as the\r\n<em>section title</em> and <em>option name</em> non-terminals; they should be allowed to contain any characters except whitespace, square brackets, double quotes and equals, for example:</p>\r\n<pre>[123more_general_title@?:]\n1_option = 1\n\n[.,_()*&amp;]\n1_option\\\\1 = 2:2,3:4</pre>\r\n<p>The modified grammar uses a RegexBasedTerminal instead of a StringLiteral:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">var</span> generalString = <span style=\"color:blue\">new</span> RegexBasedTerminal(<span style=\"color:#a31515\">&quot;General string&quot;</span>, <span style=\"color:#a31515\">&quot;[^\\\\s\\&quot;=\\\\[\\\\]]&#43;&quot;</span>);\n\n...\n\nsectionTitle.Rule = lb &#43; generalString &#43; rb &#43; NewLinePlus;\n\n...\n\noptionName.Rule = generalString;\n\n...\n</pre>\r\n</div>\r\n<p>Is this the correct approach?</p>\r\n<p>Out of interest, I notice Irony tends to use public fields in favour of properties - is this a design choice for performance reasons or does it simply reflect the Alpha stage of the project?</p>\r\n<p>Thanks a lot for your help</p>\r\n",
    "PostedDate": "2012-12-14T06:31:49.753-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "956343",
    "ThreadId": "406522",
    "Html": "\r\n<p>Regex use - why not, just keep in mind it is slower than alternatives (like IdentifierTerminal, with extra allowed symbols)</p>\r\n<p>Using fields - I'm one of the few (I think few) folks who don't see any reason to use properties when Field works fine. Only 'religious' BS - thu shalt not use fields :)</p>\r\n<p>Fields are faster, source code is more compact, and binaries are smaller as a result. And easy to replace with property, if the need ever arises</p>\r\n<p>Roman</p>\r\n",
    "PostedDate": "2012-12-14T16:57:06.923-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "961613",
    "ThreadId": "406522",
    "Html": "\r\n<p>A little off topic but the point of using properties instead of fields is that it isn't easy to change later. Yes it's easy to change from a&nbsp;field&nbsp;to a property&nbsp;in your code, but if other's code depends on your code, you may start to have\r\n problems. Specifically someone might use reflection to grab the field, and then use it, and if you change it to a property, that breaks.</p>\r\n<p>I too don't see a huge benefit of using properties everywhere, but in API's that are to be widely used, and someone might use reflection on it (which is likely considering the fact that this project attracts people interested in language design, and therefore\r\n are likely to be interested in reflection). It also doesn't make the code less compact, all you need to add (on the same line) is&nbsp;&nbsp;{ get; set; }.</p>\r\n<p>As for performance:&nbsp;<a href=\"http://www.ademiller.com/blogs/tech/2008/08/c-inline-methods-and-optimization/\">http://www.ademiller.com/blogs/tech/2008/08/c-inline-methods-and-optimization/</a>&nbsp;It seems as if the get and set methods are nearly always\r\n inlined anyways, so there should be no performance impact, and if even if they don't get inlined, then the tiny overhead they add wouldn't matter except in the most critical sections of code.&nbsp;</p>\r\n<p>I agree that most of the people use them religiously, but it's because they don't understand what's going on, and smarter people tell them they should use them (C# designed the {get;set;} shortcut specifically because people should use properties for API\r\n sections)</p>\r\n",
    "PostedDate": "2012-12-20T05:52:03.193-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "963066",
    "ThreadId": "406522",
    "Html": "\r\n<p>I'm one of the religous followers of Propertyism - it allows you to control access to the setter and react to properties being set. Even if you don't want to react to a property change right now, you may want to in the future. Having conceeded that, making\r\n everything in the public interface a property then makes things uniform.</p>\r\n<p>I do a lot of my work in WPF, so properties come in pretty handy there too. It's quite rare in my code to have a plain old field field style { get; set; } property.</p>\r\n",
    "PostedDate": "2012-12-20T11:39:50.76-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "963382",
    "ThreadId": "406522",
    "Html": "\r\n<p>Religious issues aside, here's the statistics: since project was first published (4 years), there was a single (one, uno, 1 !!!) request to change a field to property, because the object was used in WPF binding in some user-built tool - which I happily satisfied.\r\n Just changed ';' =&gt; ' {get;set;}'. Nobody ever noticed - no other code changes, no test breaks, nothing. It's not worth even discussing I think. Just personal coding style, like placing braces or indent size - no impact on anything.</p>\r\n<p>YAGNI - remember?</p>\r\n<p>Cheers</p>\r\n<p>Roman</p>\r\n",
    "PostedDate": "2012-12-20T12:58:34.157-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
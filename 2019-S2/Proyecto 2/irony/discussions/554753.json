[
  {
    "Id": "1279662",
    "ThreadId": "554753",
    "Html": "I'm having difficulty with conflicts on declaration versus statement. The following rule fails to detect a pointer declaration with initializer.<br />\n<pre><code>blockItemList.Rule = MakePlusRule(blockItemList, blockItem);\nblockItem.Rule = declaration | statement;</code></pre>\n\nThe type of line it's failing on would be:<br />\n<pre><code>MyType *x = foo();</code></pre>\n\nWhen I remove labeledStatement and expressionStatement from statement's rule (both may start with identifier), this type of declaration is recognized correctly.  I fixed labeledStatement by starting it with a regex terminal rather than identifier... \r<br />\n<br />\nWhat's the best way to force Irony to exhaust the declaration rule first before trying statement? Or, can I add to the grammar as Irony parses so that it can register MyType as a terminal rather than an identifier?  I think I may fundamentally misunderstand how this is all supposed to work, because I thought it would try a different rule if one fails.<br />\n",
    "PostedDate": "2014-07-31T10:32:30.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1280076",
    "ThreadId": "554753",
    "Html": "there's no way currently to 'force Irony to exhaust' one statement and on failure try another. This is backtracking (exploring multiple paths). This is how basic LALR works. I suspect there are grammar conflicts there - refactor your grammar and fix the conflicts before you start parsing. The conflict error message points you to problem in your grammar, when parser has multiple paths to go; it chooses an arbitrary one and apparently that's not what you wanted. So - refactor the grammar and fix the conflicts. How to refactor - read about LALR shift/reduce conflicts - google it. <br />\n",
    "PostedDate": "2014-08-01T10:10:17.527-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1280088",
    "ThreadId": "554753",
    "Html": "Thanks for the reply.  I'll be the first to admit I'm not the best at this stuff.  At the same time, I'm not sure how to make C grammar non-ambiguous using Irony.  It easily gets confused between &quot;(type cast)(type cast)a&quot; and &quot;(type cast)(a * b)&quot;.  This is because identifier is used for both type and variable name.  Is there a recommended way to dynamically add and remove types and variables from the grammar, so that identifier doesn't need to be used?  This would greatly disambiguate my grammar.  I read somewhere that GCC used to use a symbol table hack for their LALR parsing of C.<br />\n",
    "PostedDate": "2014-08-01T10:25:03.453-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1280160",
    "ThreadId": "554753",
    "Html": "It seems a lot of my problems were due to the Q() method, and a lot are being solved by my symbol table hack... but if you have a better suggestion for that, I'm all for it.\r<br />\n<br />\nNew question: how to handle pre-processor includes?  I want to come upon the symbol #include &quot;header.h&quot; and replace it with the contents of header.h without running a preprocessor, if possible.  Can I dynamically change the parser source text?<br />\n",
    "PostedDate": "2014-08-01T13:36:37.37-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1287279",
    "ThreadId": "554753",
    "Html": "Hi again\r<br />\nabout c language and problems with LALR parsing it. Unfortunately, C syntax does not fit well with LALR in general. There are even claims that C grammar (and especially C++) is not even context-free grammar, so it does not belong to the category of grammars fit for these kind of parsers. You mention the type cast expressions - this is the kind of things that make it non context free - parser has to take the semantic context into consideration when interpreting symbols. \r<br />\nAs for preprocessor commands - there's no support for this in Irony, and providing support for this (particularly includes) would require significant changes to Scanner. \r<br />\n<br />\nI'm working on a new version, and support for C-style pre-processor with macros and includes is considered too. It's all in design phase, still, not sure when I can produce anything downloadable - many other things keep me away from this. Sorry for bad news. \r<br />\nRoman<br />\n",
    "PostedDate": "2014-08-06T11:49:24.577-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1309098",
    "ThreadId": "554753",
    "Html": "Well, it's not ideal, but I've gotten things to a useable point by making a symbol table hack and then porting <a href=\"https://github.com/xtravar/CppNet\" rel=\"nofollow\">jcpp to C#</a>.  My actual grammar isn't ready for release, but here's a sample of hijacking the source for processing (in case anyone is this crazy).  Irony's been a great learning tool, but long-term I should probably rewrite as recursive-descent...<br />\n<pre><code>public class Parser : Irony.Parsing.Parser\n    {\n        static MethodInfo _thisParseAll;\n        static MethodInfo _thisReset;\n        static Parser()\n        {\n            _thisParseAll = typeof(Irony.Parsing.Parser).GetMethod(&quot;ParseAll&quot;, BindingFlags.NonPublic | BindingFlags.Instance);\n            _thisReset = typeof(Irony.Parsing.Parser).GetMethod(&quot;Reset&quot;, BindingFlags.NonPublic | BindingFlags.Instance);\n        }\n\n        public Parser(Grammar grammar) : base(grammar){\n        }\n\n        private void Reset()\n        {\n            _thisReset.Invoke(this, null);\n        }\n\n        private void ParseAll()\n        {\n            _thisParseAll.Invoke(this, null);\n        }\n\n        public new ParseTree Parse(string fileName)\n        {\n            Reset();\n            Context.Source = new PreprocessedSourceStream(fileName);\n            Context.SetCurrentParseTree(new ParseTree(null, fileName));\n            Context.SetStatus(ParserStatus.Parsing);\n            var sw = new Stopwatch();\n            sw.Start();\n            ParseAll();\n            //Set Parse status\n            var parseTree = Context.CurrentParseTree;\n            bool hasErrors = parseTree.HasErrors();\n            if(hasErrors)\n                parseTree.SetStatus(ParseTreeStatus.Error);\n            else if(Context.Status == ParserStatus.AcceptedPartial)\n                parseTree.SetStatus(ParseTreeStatus.Partial);\n            else\n                parseTree.SetStatus(ParseTreeStatus.Parsed);\n            //Build AST if no errors and AST flag is set\n            bool createAst = this.Language.Grammar.LanguageFlags.IsSet(LanguageFlags.CreateAst);\n            if(createAst &amp;&amp; !hasErrors)\n                Language.Grammar.BuildAst(Language, parseTree);\n            //Done; record the time\n            sw.Stop();\n            parseTree.ParseTimeMilliseconds = sw.ElapsedMilliseconds;\n            if(parseTree.ParserMessages.Count &gt; 0)\n                parseTree.ParserMessages.Sort(LogMessageList.ByLocation);\n            return parseTree;\n        }\n    }\n\n    public static class ParsingContextHacks\n    {\n\n        static PropertyInfo _propertyStatus;\n        static PropertyInfo _propertyCurrentParseTree;\n        static ParsingContextHacks()\n        {\n\n            _propertyStatus = typeof(Irony.Parsing.ParsingContext).GetProperty(&quot;Status&quot;);\n            _propertyCurrentParseTree = typeof(Irony.Parsing.ParsingContext).GetProperty(&quot;CurrentParseTree&quot;);\n        }\n\n        public static void SetStatus(this ParsingContext context, ParserStatus status)\n        {\n            _propertyStatus.SetValue(context, status);\n        }\n\n        public static void SetCurrentParseTree(this ParsingContext context, ParseTree parseTree)\n        {\n            _propertyCurrentParseTree.SetValue(context, parseTree);\n        }\n    }\n\n    public static class ParseTreeHacks\n    {\n        static PropertyInfo _propertyStatus;\n\n        static ParseTreeHacks()\n        {\n            _propertyStatus = typeof(Irony.Parsing.ParseTree).GetProperty(&quot;Status&quot;);\n        }\n\n        public static void SetStatus(this ParseTree context, ParseTreeStatus status)\n        {\n            _propertyStatus.SetValue(context, status);\n        }\n    }</code></pre>\n\n<pre><code>public class PreprocessedSourceStream : ISourceStream\n    {\n        CppNet.Preprocessor _preprocessor;\n        StringBuilder _buffer;\n        bool _eof;\n\n        public PreprocessedSourceStream(string fileName)\n        {\n            var pp = new Preprocessor();\n            pp.addFeature(Feature.DIGRAPHS);\n            pp.addFeature(Feature.TRIGRAPHS);\n            pp.addFeature(Feature.OBJCSYNTAX);\n            pp.addWarning(Warning.IMPORT);\n            pp.addFeature(Feature.INCLUDENEXT);\n            pp.setListener(new PreprocessorListener());\n\n            pp.getSystemIncludePath().Add(@&quot;C:\\XcodeDefault.xctoolchain\\usr\\include&quot;);\n            pp.getSystemIncludePath().Add(@&quot;C:\\XcodeDefault.xctoolchain\\usr\\lib\\clang\\6.0\\include&quot;);\n            pp.getFrameworksPath().Add(@&quot;C:\\iPhoneOS8.0.sdk\\System\\Library\\Frameworks&quot;);\n            pp.getSystemIncludePath().Add(@&quot;C:\\iPhoneOS8.0.sdk\\usr\\include&quot;);\n\n            pp.addMacro(&quot;__AARCH64_SIMD__&quot;);\n            pp.addMacro(&quot;__ARM64_ARCH_8__&quot;);\n            pp.addMacro(&quot;__ARM_NEON__&quot;);\n            pp.addMacro(&quot;__LITTLE_ENDIAN__&quot;);\n            pp.addMacro(&quot;__REGISTER_PREFIX__&quot;, &quot;&quot;);\n            pp.addMacro(&quot;__arm64&quot;, &quot;1&quot;);\n            pp.addMacro(&quot;__arm64__&quot;, &quot;1&quot;);\n\n            pp.addMacro(&quot;__APPLE_CC__&quot;, &quot;6000&quot;);\n            pp.addMacro(&quot;__APPLE__&quot;);\n            //pp.addMacro(&quot;TARGET_CPU_ARM64&quot;, &quot;1&quot;);\n            pp.addMacro(&quot;__GNUC__&quot;, &quot;4&quot;);\n            pp.addMacro(&quot;OBJC_NEW_PROPERTIES&quot;);\n            pp.addMacro(&quot;__STDC_HOSTED__&quot;, &quot;1&quot;);\n            pp.addMacro(&quot;__MACH__&quot;);\n            Version version = new Version(&quot;8.0.0.0&quot;);\n            pp.addMacro(&quot;__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__&quot;, string.Format(&quot;{0:0}{1:00}{2:00}&quot;, version.Major, version.Minor, version.Revision));\n\n            pp.addMacro(&quot;__STATIC__&quot;);\n\n\n            pp.addInput(new CppNet.FileLexerSource(fileName));\n            _preprocessor = pp;\n\n            _buffer = new StringBuilder();\n        }\n\n        public Irony.Parsing.Token CreateToken(Terminal terminal)\n        {\n            var tokenText = GetPreviewText();\n            return new Irony.Parsing.Token(terminal, this.Location, tokenText, tokenText);\n        }\n        public Irony.Parsing.Token CreateToken(Terminal terminal, object value)\n        {\n            var tokenText = GetPreviewText();\n            return new Irony.Parsing.Token(terminal, this.Location, tokenText, value);\n        }\n\n        public bool EOF()\n        {\n            return _eof &amp;&amp; _location.Position == _buffer.Length;\n        }\n\n        SourceLocation _location;\n        public SourceLocation Location\n        {\n            get\n            {\n                return _location;\n            }\n            set\n            {\n                _location = value;\n            }\n        }\n\n        public bool MatchSymbol(string symbol)\n        {\n            FillTo(_previewPosition + symbol.Length);\n            if(_buffer.Length &lt; _previewPosition + symbol.Length) {\n                return false;\n            }\n            int cmp = string.Compare(_buffer.ToString(_previewPosition, symbol.Length), 0, symbol, 0, symbol.Length, StringComparison.CurrentCulture);\n            return cmp == 0;\n        }\n\n        public char NextPreviewChar\n        {\n            get\n            {\n                FillTo(_previewPosition + 10);\n                if(_buffer.Length &lt;= _previewPosition + 1) { return '\\0'; }\n\n                return _buffer[_previewPosition + 1];\n            }\n        }\n\n        public int Position\n        {\n            get\n            {\n                return _location.Position;\n            }\n            set\n            {\n                _location.Position = value;\n\n            }\n        }\n\n        public char PreviewChar\n        {\n            get\n            {\n                FillTo(_previewPosition + 10);\n                if(_buffer.Length &lt;= _previewPosition) { return '\\0'; }\n\n                return _buffer[_previewPosition];\n            }\n        }\n\n        int _previewPosition;\n        public int PreviewPosition\n        {\n            get\n            {\n                return _previewPosition;\n            }\n            set\n            {\n                _previewPosition = value;\n            }\n        }\n\n        public string Text\n        {\n            get {\n                FillTo(Math.Max(_buffer.Length + 1000, _previewPosition));\n                return _buffer.ToString();\n            }\n        }\n\n\n        private void FillTo(int position)\n        {\n            if(_eof) {\n                return;\n            }\n            while(_buffer.Length &lt; position) {\n                CppNet.Token token = _preprocessor.token();\n                if(token.getType() == CppNet.Token.EOF) {\n                    _eof = true;\n                    return;\n                }\n                _buffer.Append(token.getText());\n            }\n        }\n\n        private string GetPreviewText()\n        {\n            FillTo(_previewPosition);\n            var until = _previewPosition;\n            if(until &gt; _buffer.Length) until = _buffer.Length;\n            var p = _location.Position;\n            string text = _buffer.ToString(p, until - p);\n            return text;\n        }\n    }</code></pre>\n\n",
    "PostedDate": "2014-09-29T18:34:13.42-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "1133590",
    "ThreadId": "472443",
    "Html": "Hi, I have been using the GrammarExplorer provided by the project to write a new grammar.\r<br />\nThere seems to be a simple problem. The grammar generates a good ast as well as a parse tree but when there is an Identifier it fails. All the AstNode classes have been overridden. Is it grammar dependent ? or something generic that I must have overlooked.\r<br />\n<br />\npartial grammar:<br />\n<pre><code>//Terminals\nvar Identifier = new IdentifierTerminal(&quot;Identifier&quot;);\nvar Select = ToTerm(&quot;SELECT&quot;);\n\n//Non Terminals\nvar Columns  = new NonTerminal(&quot;Columns&quot;,typeof(Columns));\nvar ColumnOpt = new NonTerminal(&quot;ColumnOpt&quot;,typeof(ColumnOpt));\nvar Column   = new NonTerminal(&quot;Column&quot;,typeof(Column));\nvar SelectStatement = new NonTerminal(&quot;SelectStatement&quot;,typeof(SelectStatement));\nvar Joins = new NonTerminal(&quot;Joins&quot;,typeof(Joins));\nvar AllJoins = new NonTerminal(&quot;AllJoins&quot;,typeof(AllJoins));\n\n//Rules\nColumns.Rule = ColumnOpt|ToTerm(&quot;*&quot;);\nColumnOpt.Rule = MakePlusRule(ColumnOpt, Comma, Column);\nColumn.Rule = Expression|(Expression+ToTerm(&quot;AS&quot;)+Identifier);\nSelectStatement.Rule = (Select + Columns) | (Select + Columns + From + AllJoins);\nJoins.Rule = ToTerm(&quot;CROSS&quot;)|ToTerm(&quot;INNER&quot;);\nAllJoins.Rule = Identifier |( Identifier + Joins + ToTerm(&quot;JOIN&quot;) + Identifier) |( Identifier + Joins + ToTerm(&quot;JOIN&quot;) + Identifier + ToTerm(&quot;ON&quot;) + Expression);</code></pre>\n\n*for Expression i have used the example from calculator sample.\r<br />\n<br />\nit recognizes(Expected) &amp;&amp; builds \r<br />\nSELECT *;\r<br />\nbut fails to build Ast for\r<br />\nSELECT * FROM Xyz;<br />\n<pre><code>public class BaseAst : AstNode\n        {\n            AstNode _singleChild;\n            public override void Init(AstContext context, ParseTreeNode treeNode)\n            {\n                base.Init(context, treeNode);\n                var nodes = treeNode.GetMappedChildNodes();\n                foreach (var child in nodes)\n                {\n                    if (child.AstNode != null)\n                        AddChild(string.Empty, child);\n                }\n                AsString = &quot;BaseNode&quot;;\n                if (ChildNodes.Count == 0)\n                    AsString += &quot;*&quot;;\n                else\n                    ChildNodes[ChildNodes.Count - 1].Flags |= AstNodeFlags.IsTail;\n            }\n\n            private object EvaluateEmpty(ScriptThread thread)\n            {\n                return null;\n            }\n\n            private object EvaluateOne(ScriptThread thread)\n            {\n                thread.CurrentNode = this;\n                object result = _singleChild.Evaluate(thread);\n                thread.CurrentNode = Parent;\n                return result;\n            }\n\n            private object EvaluateMultiple(ScriptThread thread)\n            {\n                thread.CurrentNode = this;\n                object result = null;\n                for (int i = 0; i &lt; ChildNodes.Count; i++)\n                {\n                    result = ChildNodes[i].Evaluate(thread);\n                }\n                thread.CurrentNode = Parent;\n                return result;\n            }\n\n            protected override object DoEvaluate(Irony.Interpreter.ScriptThread thread)\n            {\n                thread.CurrentNode = this;\n                lock (LockObject)\n                {\n                    switch (ChildNodes.Count)\n                    {\n                        case 0:\n                            Evaluate = EvaluateEmpty;\n                            break;\n                        case 1:\n                            _singleChild = ChildNodes[0];\n                            Evaluate = EvaluateOne;\n                            break;\n                        default:\n                            Evaluate = EvaluateMultiple;\n                            break;\n                    }\n                }\n                var result = Evaluate(thread);\n                thread.CurrentNode = Parent;\n                return result;\n            }\n        }</code></pre>\n\nI have created AstNode classes for all non terminals type<br />\n<pre><code>public class Columns: BaseAst{ public override void Init(AstContext context,ParseTreeNode treeNode){base.Init(context,treeNode);AsString+=&quot;Columns&quot;;}}\npublic class Column: BaseAst{ public override void Init(AstContext context,ParseTreeNode treeNode){base.Init(context,treeNode);AsString+=&quot;Column&quot;;}}\npublic class ColumnOpt: BaseAst{ public override void Init(AstContext context,ParseTreeNode treeNode){base.Init(context,treeNode);AsString+=&quot;ColumnOpt&quot;;}}\n/*\n..So on..\n*/</code></pre>\n\nWhat could have been wrong ?<br />\n",
    "PostedDate": "2013-12-10T06:08:10.967-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1135217",
    "ThreadId": "472443",
    "Html": "you probably use AstContext class, not InterpreterAstContext - which sets default AST node types for identifier and literals terminals. \r<br />\nEither initialize these in AstContext class, or set these in grammar constructor - assign directly in Identifier terminal.<br />\n",
    "PostedDate": "2013-12-12T11:27:23.91-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "117405",
    "ThreadId": "35322",
    "Html": "Hi there.<br>\r\n<br>\r\nI have been exploring how to make an ambitious compiler framework of my own for the past year or two. I haven't really come to a conclusion yet but I would like to reach out and meet people doing similar things. Well, what I'd <strong>really</strong> like to do is find someone that wants to do the same thing as me, and combine my project with theirs, or share code. There is a chance that you might be that someone, depending.<br>\r\n<br>\r\nMy framework is called Loyc--Language Of Your Choice. I envision Loyc to be an extensible .NET compiler framework that will support multiple languages simultaneously: for example, you would be able to compile a Foo.vb, Bar.cs and Baz.boo into Fubar.dll. I want it to be a basis for language extensions. This means that people will be able to modify the syntax and semantics of C#, boo, or other supported languages with new constructs and features, such as <br>\r\n<br>\r\n- an embedded DSL<br>\r\n- new statements (e.g. you could add &quot;until&quot; and &quot;unless&quot; statements to C#)<br>\r\n- &quot;virtual&quot; data types (which would be transformed into something else at compile time)<br>\r\n- code analysis tools<br>\r\n<br>\r\nIdeally it will be easy to combine new language features written by different people.<br>\r\n<br>\r\nI imagine that Irony could be a basis for Loyc by providing one possible parsing mechanism (I would like people to be able to choose any parsing system they like), a standard AST model, and a standard back-end. However, I may have some concerns about Irony's design and I wonder if you'd be open to design changes at this point. <br>\r\n<br>\r\nHave a good day, sir!<br>\r\n",
    "PostedDate": "2008-09-09T17:24:12.613-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "117450",
    "ThreadId": "35322",
    "Html": "<p>Well, I don't mind being friends with anybody. Nice! - you already have a name for your framework... then what's the problem? I don't quite understand what is your reservations about Irony. It is an open source project, so if you don't like something, you can always take the source and change it to your liking. I can't promise I would&nbsp;quickly respond to any request for&nbsp;new feature or algorithm, but I welcome everybody to contribute&nbsp;any pieces that can be useful for Irony's target audience. I specifically don't insist on exclusive use of LALR parsing algorithm, I'm planning to implement some alternative myself, and would welcome other parser implementation. In fact, the main purpose of latest refactoring of Irony was to enable using different type of parsers.</p>\r\n<p>So, make your suggestions/requests for improvements, and we'll see...</p>\r\n<p>thank you</p>\r\n<p>Roman</p>\r\n",
    "PostedDate": "2008-09-09T21:57:26.057-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "118026",
    "ThreadId": "35322",
    "Html": "I know I can change the source to my liking, but I'm simply saying I wonder if you'd consider design changes, so that I wouldn't have to fork the framework.<br>\r\n<br>\r\nI haven't reviewed the framework in detail; in fact for the most part I have no idea what I'm looking at... but one of the most important things to get right is the AST. Because working with an AST is central to any compiler, it deserves a lot of attention. I would like to see an AST design that is very general, so that it would be appropriate for just about any language and parser. Indeed, I would like an AST design that you take out of the framework and use almost by itself. But your AstNode class has references to some things that are Irony-specific. There's a reference to BnfTerm, and mentions of EvaluationContext, which in turn references LanguageRuntime. What are those last two things? I'd also like to understand the rationale for NodeArgs.<br>\r\n<br>\r\nI'm concerned about the size of the AST. I would like to make a\r\nframework that is quite scalable--specifically, that can scale down to\r\nsmall devices like OLPCs and Smartphones. ASTs can easily suck up huge amounts of memory (from the perspective of a low-power device), and it\r\nlooks like the AST in Irony is far from frugal. Each node contains a List&lt;AstNode&gt;, for example, even leaf nodes, and it uses 4 integers to describe its location in the source code when two could suffice.<br>\r\n<br>\r\nActually, although I picked the same name for my AstNode class, the APIs are so vastly different I wonder if they can be reconciled.<br>\r\n<br>\r\nI would be interested to learn about how you store type information and manage scope information, two problems I haven't thought of solutions for yet. I guess it would be easier if I was designing a compiler specifically for a well-defined, closed language... but when I try to think about what is needed for an extensible compiler, my mind draws a blank. A related issue is the basic question of what kind of type system to have, and I don't even know where to look for ideas.<br>\r\n<br>\r\nBy the way, I can't compile the unit tests in SharpDevelop because the unit test framework is Microsoft-specific; do you know if that framework comes with Visual C# Express?<br>\r\n<br>\r\nP.S. Is CodePlex's email notification of replies working for you? Cuz it didn't for me :(<br>\r\n",
    "PostedDate": "2008-09-11T22:22:25.427-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "118169",
    "ThreadId": "35322",
    "Html": "About AST nodes. AstNode class references a lot of stuff, and this information is used for implementing its intended functionality. You can try making it slimmer, but the problem with this - the slimmest class of all, &quot;Object&quot;, is the most universal&nbsp;and slimmest thing, but it is almost useless, except as universal reference type, blackbox, for temporary holding a ref to an object which ultimately will be downcasted to be useful for its intended purpose. <br>\r\nIf you have an alternative AST node hierarchy - you can transform Irony's tree into your tree using simple node visitor.<br>\r\nThe size of AST - as latest trends show, saving a byte here and there is not a proper way to optimize&nbsp;the app. Micro-optimizations bring almost no effect compared to macro- (large-scale) efficiency of the code. <strong>App performance suxx most of the time not because of micro-inefficiencies, but&nbsp;because it does many things over and over again, on a big scale, and replicates data again and again in different parts of the code jungle.</strong> This is my experience. Memory becomes cheaper and more available even on handhelds and embedded devices, so&nbsp;worrying about single bytes produces only negligible effects. Worse, it can complicate the code so much that it may result in large-scale inefficiencies.<br>\r\nStoring type information, scopes, etc - not much there for now. Code analysis is in beginning phase.<br>\r\nUnit tests - I switched from NUnit to VS test framework, just for convenience of the majority of downloaders - no extra installs, all in VS. Sorry, have no information on Express versions or SharpDevelop.<br>\r\nCodePlex notifications work fine for me, I&quot;ve got notified about your post. <br>\r\nOverall - Irony is just a tool,&nbsp;very powerful indeed, but&nbsp;it is not solution to all world problems. If you try to build all-world-problems-solver,&nbsp;Irony can help but only with the subset of things that it is built to solve. The rest is on your to-do&nbsp;list.<br>\r\nRespectfully<br>\r\nRoman<br>\r\n",
    "PostedDate": "2008-09-12T09:25:29.78-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "121363",
    "ThreadId": "35322",
    "Html": "Hi. Sorry about the slow reply; I've been busy catching up with work (at work).<br>\r\n<br>\r\nAbout AST node size. Of course I'm not worried about single bytes. I'm worried about how big an AST is to represent a moderately large program--say, 1 MB of source code. If such a program consists of 300,000 tokens and 300,000 AST nodes, and each of each requires 150 bytes total, then holding all that in memory would require nearly 90MB. Each integer or reference you remove from an individual node would save 2,400,000 bytes, and an empty List&lt;object&gt; costs about 28*600000=16,800,000 bytes.<br>\r\n<br>\r\nCareful AST design might cut the node size in half, and I wouldn't call 45 MB a micro-inefficiency from the perspective of a cheap laptop. I think that Moore's law is changing, as a global median, from technology getting faster and higher-capacity to merely getting cheaper, and I'd like, eventually at least, to target cheap devices.<br>\r\n<br>\r\nMind you, I don't actually know the node density of a typical program... maybe it's less... but in case it's large, I want a design that can be optimized if necessary. They say premature optimization is evil, but unfortunately some optimizations become difficult or impossible as a code base goes into widespread use. For example, the .NET framework people decided in their design of IEnumerable to require two relatively expensive interface calls (MoveNext and Current) for every iteration, when one call would have been enough. Of course, this optimization is out of the question for Microsoft; it could only have been done near the beginning. Likewise if Irony or Loyc becomes popular, changing any public interface becomes painful, so any optimization that you might like to implement &quot;someday&quot; should be supported by the public interface now.<br>\r\n<br>\r\nMind you, unfortunately it has to be a trade-off--to possibly optimize space you may have to sacrifice some speed. For example, I think that it should be possible for somebody to implement a fixed-size AST node class, that has, for example, exactly two children, or even no children. The current design doesn't allow this, as ChildNodes is a field of type List&lt;AstNode&gt; (well, AstNodeList, splitting hairs). It would be more flexible if ChildNodes were a property that returned IList&lt;AstNode&gt;; a hypothetical fixed-size node class would implement IList&lt;AstNode&gt; directly and its ChildNodes property would simply return <em>this</em>. This is somewhat inefficient speed-wise though; better speed would be obtained by accessing a virtual indexer and Count property on AstNode itself. I guess it sounds like I'm focusing on micro-opimizations again, but I hypothesize that the AST interface (like IEnumerable) is one of the most heavily-used interfaces in any compiler, and it could even become an ad-hoc standard across many compilers--but only if it is well designed. Plus, it's one of the hardest things to change once it is in widespread use. Therefore, in my view, it deserves to be designed more carefully than almost everything else.<br>\r\n<blockquote><em>If you have an alternative AST node hierarchy - you can transform Irony's tree into your tree using simple node visitor.</em><br>\r\n</blockquote>I realize that, but it would be nice to avoid that complication, don't you think?<br>\r\n<br>\r\nMy original AST design actually called for nodes with multiple child lists. For example, to represent a function definition node like<br>\r\n<br>\r\nvoid Foo&lt;T&gt; (int x, int y) { ... }<br>\r\n<br>\r\nThe node would actually have three child lists: a list of generic type parameters, a list of regular parameters and a list of statements in the function. I'm already happy to dump that design in favor of Irony's one-list-per-node approach, so that the function above would be represented instead by an AstNode with three children (or four--one more child for the return type), and each of the three children would be another AstNode with its own list of children.<br>\r\n<br>\r\nThe point is, maybe we have substantially different ideas for\r\nwhat an AST node should have in it, but maybe we could compromise and come to an agreement. At least we could use a common base class or something. And perhaps we could put out a small library with core features that are common to most compiler tools.<br>\r\n<br>\r\nI just tried loading Irony in VC# Express 2008 and the unit test project would not load (&quot;unsupported project type&quot;). The project loads in SharpDevelop but the unit test library dependency is not available.<br>\r\n",
    "PostedDate": "2008-09-27T13:43:54.213-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "121774",
    "ThreadId": "35322",
    "Html": "<p>Hi<br>\r\nYou write:<br>\r\n&nbsp;&nbsp; <em>...maybe we have substantially different ideas for what an AST node should have in it, but maybe we could compromise and come to an agreement. At least we could use a common base class or something. And perhaps we could put out a small library with core features that are common to most compiler tools.</em></p>\r\n<p>I don't mind improving Irony's base classes, and making it better for use in compiler implementations. But it's not enough to simply say &quot;let's remove this property in this object&quot; - you need to see the changes and (possibly) complications in the code, both in the Irony core and in solutions based on it which are result of the change. What I would like to see is a solution or sample that shows deficciencies of current Irony's features. <br>\r\nI think your worries are just the case of &quot;premature optimization&quot;. I've looked at many other compilers and language implementations, and I think Irony does many things much better than many of them. So I suggest you to start with a real sample, and lets go from there. <br>\r\nthank you<br>\r\nRoman<br>\r\n&nbsp;</p>\r\n",
    "PostedDate": "2008-09-29T21:55:43.717-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "121777",
    "ThreadId": "35322",
    "Html": "On another subject, about child nodes. There is a good reason to always keep all sub-nodes in ChildNodes list. Even if you have&nbsp;dedicated fields for specific parts (like in your example for proc node&nbsp;- parameters, statements, etc) - even in this case&nbsp;ChildNodes should contain all of them. The reason is because&nbsp;it is very&nbsp;convenient for iterators/visitors, used by&nbsp;code analysis routines -&nbsp;all child nodes of the node are in one place, so&nbsp;visiting the entire tree in analysis phase is&nbsp;trivial. Look how&nbsp;specific nodes implemented in Irony (in AST namespace)&nbsp;-&nbsp;the specific nodes&nbsp;have&nbsp;dedicated fields for each specific&nbsp;child, but still put all children into ChildNodes. So code analysis visits all nodes using simple algorithm.&nbsp;<br>\r\nRoman<br>\r\n&nbsp;&nbsp;\r\n",
    "PostedDate": "2008-09-29T22:13:09.907-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
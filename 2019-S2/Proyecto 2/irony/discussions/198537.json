[
  {
    "Id": "407101",
    "ThreadId": "198537",
    "Html": "<p>Hey Roman,</p>\r\n<p>I have run into a problem with the Parser where it will not parse a perfectly valid expression.</p>\r\n<p>First of all, here is the code for the grammars that are causing the problem:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> TestGrammar1 : Grammar\r\n{\r\n   <span style=\"color:Blue\">public</span> TestGrammar1()\r\n   {\r\n      <span style=\"color:Blue\">var</span> number = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;Number&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">var</span> foo = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Foo&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> bar = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Bar&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> sum = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Sum&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">this</span>.Root = foo;\r\n\r\n      foo.Rule = <span style=\"color:#A31515\">&quot;Foo&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + bar + <span style=\"color:#A31515\">&quot;,&quot;</span> + sum + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n      bar.Rule = <span style=\"color:#A31515\">&quot;Bar&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n      sum.Rule = <span style=\"color:#A31515\">&quot;Sum&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n\r\n      MarkPunctuation(<span style=\"color:#A31515\">&quot;(&quot;</span>, <span style=\"color:#A31515\">&quot;,&quot;</span>, <span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n   }\r\n}\r\n\r\n<span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> TestGrammar2 : Grammar\r\n{\r\n   <span style=\"color:Blue\">public</span> TestGrammar2()\r\n   {\r\n      <span style=\"color:Blue\">var</span> tg1 = <span style=\"color:Blue\">new</span> TestGrammar1();\r\n\r\n      <span style=\"color:Blue\">var</span> number = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;Number&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">var</span> theRoot = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;TheRoot&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> foo = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Foo&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> bar = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Bar&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">this</span>.Root = theRoot;\r\n      theRoot.Rule = foo | tg1.Root;\r\n      foo.Rule = <span style=\"color:#A31515\">&quot;Foo&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + bar + <span style=\"color:#A31515\">&quot;,&quot;</span> + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n      bar.Rule = <span style=\"color:#A31515\">&quot;Bar&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n\r\n      MarkPunctuation(<span style=\"color:#A31515\">&quot;(&quot;</span>, <span style=\"color:#A31515\">&quot;,&quot;</span>, <span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n   }\r\n}\r\n</pre>\r\n</div>\r\n<p>I separated the grammars into two classes since that is the way my current (much, MUCH more complex grammars) are set up (with one using the other as a sub grammar).<br>I need the functionality to be able to parse an expression from the first grammar (in this case, TestGrammar1), as well as an expression from the second grammar<br>(in this case, TestGrammar2), without having to re-write the entire TG1 inside of TG2 (for maintenance purposes!).&nbsp; Also, since they have conceptually<br>different functionality (when evaluating their ASTs), I would prefer that they remain in separate grammars rather than turning TG1 into a &quot;snippet&quot; root of TG2.</p>\r\n<p>In this case, when parsing an expression using TestGrammar2, it should be able to parse expressions of the form:<br>Foo(Bar(5), Sum(7))&nbsp;&nbsp; &lt;-- Production from TestGrammar1<br>Foo(Bar(5), 7)&nbsp;&nbsp; &lt;-- Production from TestGrammar2</p>\r\n<p>It can correctly parse the expression from TG1, but when it tries to do the one from TG2, it gives the following Parser Error:<br>(0:12) Syntax error, expected: Sum</p>\r\n<p>Clearly, it is a valid production and should have no problem.</p>\r\n<p>As far as I can tell, the problem seems to come from the fact that both Foo statements require a Bar statement as the first &quot;parameter&quot;, but the NTs representing<br>the Bar statements are two separate NTs with the same production.</p>\r\n<p>Brian</p>",
    "PostedDate": "2010-02-25T16:48:28.897-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "407124",
    "ThreadId": "198537",
    "Html": "<p>I think your problem is in two versions of Number literals participating in the final Grammar #2. They look the same but they are distinct and different objects for parser. So just by accident Number#1 is the first in scanning list, it gets to parse the token &quot;5&quot;, so after this the parser is directed into the first grammar's production (because number terminal is from the first grammar). You need to make NumberLiteral (and possibly other terms) in Grammar1 public fields, and reuse them in Grammar2 rules.</p>",
    "PostedDate": "2010-02-25T17:04:28.32-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "412783",
    "ThreadId": "198537",
    "Html": "<p>Roman,</p>\r\n<p>I was able to find two different ways to make it work.&nbsp; The first is by &quot;sharing&quot; both the Bar NT and the open parenthesis key term (both of these are necessary):</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> TestGrammar1 : Grammar\r\n{\r\n   <span style=\"color:Blue\">public</span> NonTerminal Bar = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Bar&quot;</span>);\r\n   <span style=\"color:Blue\">public</span> KeyTerm Key_LP = <span style=\"color:Blue\">null</span>;\r\n\r\n   <span style=\"color:Blue\">public</span> TestGrammar1()\r\n   {\r\n      Key_LP = ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">var</span> number = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;Number_1&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">var</span> foo = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Foo_1&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> sum = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Sum&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">this</span>.Root = foo;\r\n\r\n      foo.Rule = <span style=\"color:#A31515\">&quot;Foo&quot;</span> + Key_LP + Bar + <span style=\"color:#A31515\">&quot;,&quot;</span> + sum + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n      Bar.Rule = <span style=\"color:#A31515\">&quot;Bar&quot;</span> + Key_LP + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n      sum.Rule = <span style=\"color:#A31515\">&quot;Sum&quot;</span> + Key_LP + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n\r\n      MarkPunctuation(<span style=\"color:#A31515\">&quot;(&quot;</span>, <span style=\"color:#A31515\">&quot;,&quot;</span>, <span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n   }\r\n}\r\n\r\n<span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> TestGrammar2 : Grammar\r\n{\r\n   <span style=\"color:Blue\">public</span> TestGrammar2()\r\n   {\r\n      <span style=\"color:Green\">// Grammar.CurrentGrammar is switched to TG1!</span>\r\n      <span style=\"color:Blue\">var</span> tg1 = <span style=\"color:Blue\">new</span> TestGrammar1();\r\n      <span style=\"color:Green\">// But we cannot switch it back -- it is read only!</span>\r\n\r\n      <span style=\"color:Blue\">var</span> number = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;Number_2&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">var</span> theRoot = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;TheRoot&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> foo = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Foo_2&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">this</span>.Root = theRoot;\r\n      theRoot.Rule = foo | tg1.Root;\r\n      <span style=\"color:Green\">// TG1.ToTerm(&quot;Foo&quot;) is really called here</span>\r\n      foo.Rule = <span style=\"color:#A31515\">&quot;Foo&quot;</span> + tg1.Key_LP + tg1.Bar + <span style=\"color:#A31515\">&quot;,&quot;</span> + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n\r\n      <span style=\"color:Green\">// NOTE: This &quot;(&quot; and tg1.Key_LP are separate KeyTerms</span>\r\n      MarkPunctuation(<span style=\"color:#A31515\">&quot;(&quot;</span>, <span style=\"color:#A31515\">&quot;,&quot;</span>, <span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n   }\r\n}\r\n</pre>\r\n</div>\r\n<p>The ugly thing about this solution is that the&nbsp;open paren&nbsp;has to be shared (but oddly, &quot;Foo&quot;, number, and the closed paren do not!).&nbsp; I was confused at first<br>because it looked like both &quot;Foo&quot; and &quot;(&quot; were being passed into the ToTerm(...) function (whether explicitly, or as part of processing the '+' operator), so I<br>didn't understand why &quot;(&quot; had to be shared, but not &quot;Foo&quot;!</p>\r\n<p>It turns out that &quot;(&quot; is passed to the ToTerm function of the Grammar that has the constructor that is currently executing, which leads to two different KeyTerms<br>being made for &quot;(&quot;: one for TG1, and another for TG2 (since they cannot see each other's list of already defined KeyTerms).&nbsp; HOWEVER, when &quot;Foo&quot; is passed<br>to ToTerm(...), it is passed to TG1's ToTerm(...) function, resulting in only one&nbsp;KeyTerm being created for &quot;Foo&quot; (since it was 'already defined in TG1').<br>This is due to the fact that the line:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">var</span> tg1 = <span style=\"color:Blue\">new</span> TestGrammar1();\r\n</pre>\r\n</div>\r\n<p>causes Grammar.CurrentGrammar to change from TG2 to TG1.&nbsp; Since Grammar.CurrentGrammar is readonly, I cannot change it back.</p>\r\n<p>I can see things getting very complicated (and incorrect!) if more than one grammar is used as a &quot;sub grammar&quot;.&nbsp; (For example, if I added a third &quot;parameter&quot; to<br>Foo that was the root of TestGrammar999.)</p>\r\n<p>The other &quot;solution&quot; to the problem is to use inheritance; TG4 inherits from TG3:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> TestGrammar3 : Grammar\r\n{\r\n   <span style=\"color:Blue\">protected</span> NonTerminal m_Bar = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Bar&quot;</span>);\r\n\r\n   <span style=\"color:Blue\">public</span> TestGrammar3()\r\n   {\r\n      <span style=\"color:Blue\">var</span> number = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;Number_3&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">var</span> foo = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Foo_3&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> sum = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Sum&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">this</span>.Root = foo;\r\n\r\n      foo.Rule = <span style=\"color:#A31515\">&quot;Foo&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + m_Bar + <span style=\"color:#A31515\">&quot;,&quot;</span> + sum + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n      m_Bar.Rule = <span style=\"color:#A31515\">&quot;Bar&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n      sum.Rule = <span style=\"color:#A31515\">&quot;Sum&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n\r\n      MarkPunctuation(<span style=\"color:#A31515\">&quot;(&quot;</span>, <span style=\"color:#A31515\">&quot;,&quot;</span>, <span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n   }\r\n}\r\n\r\n<span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> TestGrammar4 : TestGrammar3\r\n{\r\n   <span style=\"color:Blue\">public</span> TestGrammar4()\r\n   {\r\n      <span style=\"color:Green\">// Grammar.CurrentGrammar is never changed</span>\r\n      <span style=\"color:Blue\">var</span> tg3 = <span style=\"color:Blue\">this</span>.Root;\r\n\r\n      <span style=\"color:Blue\">var</span> number = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;Number_4&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> theRoot = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;TheRoot&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> foo = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Foo_4&quot;</span>);\r\n\r\n      <span style=\"color:Blue\">this</span>.Root = theRoot;\r\n      theRoot.Rule = foo | tg3;\r\n      <span style=\"color:Green\">// The &quot;(&quot; KeyTerm from TG3 is reused here since the</span>\r\n      <span style=\"color:Green\">// list of KeyTerms is now &quot;shared&quot;.</span>\r\n      foo.Rule = <span style=\"color:#A31515\">&quot;Foo&quot;</span> + ToTerm(<span style=\"color:#A31515\">&quot;(&quot;</span>) + m_Bar + <span style=\"color:#A31515\">&quot;,&quot;</span> + number + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n\r\n      MarkPunctuation(<span style=\"color:#A31515\">&quot;(&quot;</span>, <span style=\"color:#A31515\">&quot;,&quot;</span>, <span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n   }\r\n}\r\n</pre>\r\n</div>\r\n<p>The benefit is that it isn't as ugly since I don't need to share the open paren KeyTerm and that &quot;Foo&quot; is being passed to the correct ToTerm(...) function (because<br>Grammar.CurrentGrammar isn't changing).&nbsp; However, it is an ugly software design since TG4 isn't really a &quot;more specific type of&quot; TG3.&nbsp; It just USES TG3.</p>\r\n<p>Also, inheritance is not possible when more than one grammar needs to be used as a &quot;sub grammar&quot;.</p>\r\n<p>For now, I will probably go with the inheritance based solution as it is the &quot;lesser of the two uglies&quot;.&nbsp; However, I strongly believe that there is a problem with the current<br>implementation of how Grammar.CurrentGrammar is used, especially in regards to the ToTerm(...) function.</p>\r\n<p>Perhaps the list of KeyTerms should be static so that it can be globally shared?&nbsp; One thing to keep in mind is case sensitivity of grammars...</p>\r\n<p>Brian</p>",
    "PostedDate": "2010-03-01T10:19:37.75-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
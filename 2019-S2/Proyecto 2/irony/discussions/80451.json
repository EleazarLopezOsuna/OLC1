[
  {
    "Id": "275740",
    "ThreadId": "80451",
    "Html": "<p>Roman,</p>\r\n<p>I have been having some problems when trying to use the OR (|) operator to &quot;extend&quot; the possible productions for a non-terminal.&nbsp; I am trying to do this inside of a derived grammar's constructor in order to extend a base grammar.</p>\r\n<p>To keep things (relatively) simple, suppose I had a base grammar called &quot;BasicExpressionGrammar&quot; as follows:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>[Language(<span style=\"color:#A31515\">&quot;Basic Expression Grammar&quot;</span>, <span style=\"color:#A31515\">&quot;1.0&quot;</span>, <span style=\"color:#A31515\">&quot;Base grammar for simple expressions with unary and binary operators&quot;</span>)]\r\n<span style=\"color:Blue\">public</span> <span style=\"color:Blue\">abstract</span> <span style=\"color:Blue\">class</span> BasicExpressionGrammar : Grammar\r\n{\r\n  <span style=\"color:Blue\">private</span> NonTerminal m_Expression;\r\n  <span style=\"color:Blue\">private</span> NonTerminal m_UnaryOperator;\r\n  <span style=\"color:Blue\">private</span> NonTerminal m_BinaryOperator;\r\n  <span style=\"color:Blue\">private</span> NonTerminal m_Term;\r\n\r\n  <span style=\"color:Blue\">public</span> BasicExpressionGrammar()\r\n  {\r\n    m_Expression = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Expression&quot;</span>);\r\n    m_UnaryOperator = <span style=\"color:Blue\">null</span>;\r\n    m_BinaryOperator = <span style=\"color:Blue\">null</span>;\r\n    m_Term = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;Term&quot;</span>);\r\n\r\n    <span style=\"color:Blue\">var</span> parenExp = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;ParenthesisExpression&quot;</span>);\r\n\r\n    <span style=\"color:Blue\">this</span>.Root = m_Expression;\r\n    m_Expression.Rule = m_Term;\r\n    parenExp.Rule = <span style=\"color:#A31515\">&quot;(&quot;</span> + m_Expression + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n    m_Term.Rule = parenExp;\r\n\r\n    MarkTransient(m_Expression, m_Term, parenExp);\r\n\r\n    RegisterPunctuation(<span style=\"color:#A31515\">&quot;(&quot;</span>, <span style=\"color:#A31515\">&quot;)&quot;</span>);\r\n\r\n    <span style=\"color:Green\">// Ignore new lines</span>\r\n    NonGrammarTerminals.Add(NewLine);\r\n\r\n    <span style=\"color:Blue\">this</span>.LanguageFlags =\r\n      LanguageFlags.CreateAst |\r\n      LanguageFlags.CanRunSample;\r\n  }\r\n\r\n  <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">void</span> AddUnaryOperator(<span style=\"color:Blue\">params</span> <span style=\"color:Blue\">string</span>[] ops)\r\n  {\r\n    <span style=\"color:Blue\">if</span>(ops == <span style=\"color:Blue\">null</span> || ops.Length == 0) <span style=\"color:Blue\">return</span>;\r\n\r\n    <span style=\"color:Blue\">if</span>(m_UnaryOperator == <span style=\"color:Blue\">null</span>)\r\n    {\r\n      m_UnaryOperator = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;UnaryOperator&quot;</span>);\r\n      <span style=\"color:Blue\">var</span> unaryExp = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;UnaryExpression&quot;</span>, <span style=\"color:Blue\">typeof</span>(UnExprNode));\r\n      <span style=\"color:Green\">// When the user specifies ANY unary operators,</span>\r\n      <span style=\"color:Green\">// we need to add them to the list of productions from</span>\r\n      <span style=\"color:Green\">// the Expression non-terminal</span>\r\n      m_Expression.Rule = unaryExp | m_Expression.Rule;\r\n      unaryExp.Rule = m_UnaryOperator + m_Term;\r\n      MarkTransient(m_UnaryOperator);\r\n    }\r\n\r\n    <span style=\"color:Blue\">foreach</span>(<span style=\"color:Blue\">var</span> op <span style=\"color:Blue\">in</span> ops)\r\n    {\r\n      <span style=\"color:Blue\">if</span>(m_UnaryOperator.Rule == <span style=\"color:Blue\">null</span>)\r\n      {\r\n        m_UnaryOperator.Rule = op;\r\n      }\r\n      <span style=\"color:Blue\">else</span>\r\n      {\r\n        <span style=\"color:Green\">// Here we need to keep expanding the possible unary</span>\r\n        <span style=\"color:Green\">// operators that can be used.  Can be expanded over</span>\r\n        <span style=\"color:Green\">// multiple calls to this function (from sub-grammars,</span>\r\n        <span style=\"color:Green\">// or even sub-sub-grammars).</span>\r\n        m_UnaryOperator.Rule = op | m_UnaryOperator.Rule;\r\n      }\r\n    }\r\n  }\r\n\r\n  <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">void</span> AddBinaryOperator(<span style=\"color:Blue\">params</span> <span style=\"color:Blue\">string</span>[] ops)\r\n  {\r\n    <span style=\"color:Green\">// See AddUnaryOperator -- basically the same.</span>\r\n  }\r\n\r\n  <span style=\"color:Blue\">protected</span> <span style=\"color:Blue\">void</span> AddExpressionTerm(<span style=\"color:Blue\">params</span> BnfTerm[] terms)\r\n  {\r\n    <span style=\"color:Blue\">foreach</span>(<span style=\"color:Blue\">var</span> term <span style=\"color:Blue\">in</span> terms)\r\n    {\r\n      <span style=\"color:Green\">// Here we are adding new terms that the operators</span>\r\n      <span style=\"color:Green\">// can act on.</span>\r\n      m_Term.Rule = term | m_Term.Rule;\r\n    }\r\n  }\r\n}\r\n</pre>\r\n<pre>As you can see, the base grammar doesn't provide much more than a shell for sub grammars to plug into.  The base grammar could be much more complicated than this.</pre>\r\n<pre>A derived grammar could define what operators it wants to use, as well as what &quot;things&quot; can be operands.  Take a sub grammar that performs integer arithmetic:</pre>\r\n<pre><div style=\"color:Black;background-color:White\"><pre>[Language(<span style=\"color:#A31515\">&quot;IntegerExpressionGrammar&quot;</span>, <span style=\"color:#A31515\">&quot;1.0&quot;</span>, <span style=\"color:#A31515\">&quot;Evaluates integer expressions&quot;</span>)]\r\n<span style=\"color:Blue\">public</span> <span style=\"color:Blue\">class</span> IntegerExpressionGrammar : BasicExpressionGrammar\r\n{\r\n  <span style=\"color:Blue\">public</span> <span style=\"color:Blue\">const</span> NumberFlags IntegerFlags =\r\n    NumberFlags.IntOnly |\r\n    NumberFlags.NoDotAfterInt;\r\n\r\n  <span style=\"color:Blue\">public</span> IntegerExpressionGrammar()\r\n  {\r\n    <span style=\"color:Blue\">var</span> constant = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;Constant&quot;</span>, IntegerFlags);\r\n    <span style=\"color:Blue\">var</span> someFunctionParam = <span style=\"color:Blue\">new</span> NumberLiteral(<span style=\"color:#A31515\">&quot;SomeFunctionParam&quot;</span>, IntegerFlags);\r\n\r\n    <span style=\"color:Green\">// Use your imagination as to what this function will do.</span>\r\n    <span style=\"color:Blue\">var</span> someFunction = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;SomeFunction&quot;</span>, <span style=\"color:Blue\">typeof</span>(SomeFunctionProcessingNode));\r\n\r\n    someFunction.Rule = <span style=\"color:#A31515\">&quot;Foo(&quot;</span> + someFunctionParam + <span style=\"color:#A31515\">&quot;)&quot;</span>;\r\n\r\n    <span style=\"color:Green\">// If I wanted, I don't have to have any unary ops...</span>\r\n    AddUnaryOperator(<span style=\"color:#A31515\">&quot;-&quot;</span>);\r\n    <span style=\"color:Green\">// ... and/or any binary ops</span>\r\n    AddBinaryOperator(<span style=\"color:#A31515\">&quot;+&quot;</span>, <span style=\"color:#A31515\">&quot;-&quot;</span>, <span style=\"color:#A31515\">&quot;*&quot;</span>, <span style=\"color:#A31515\">&quot;/&quot;</span>);\r\n    AddExpressionTerm(constant, someFunction);\r\n  }\r\n}\r\n</pre>\r\n</div>\r\n</pre>\r\n<pre>Here we have defined a subgrammar that performs arithmetic evaluation of integer expressions with some function called &quot;Foo&quot;.  Foo could easily be &quot;Sum&quot;, &quot;Min&quot;, &quot;Max&quot;, etc.</pre>\r\n<pre>Some things to note here are that the base grammar's functionality needs to expand (new terms, operators, etc.) as the sub grammar needs it to.</pre>\r\n<pre>However, I do not know in the sub grammar what all the various &quot;Term&quot;s could be at any given time (nor do I care!).  It just wants to be able to &quot;add&quot; the function &quot;Foo&quot; as a possible term.</pre>\r\n<pre>There could be a sub (sub) grammar that extends IntegerExpressionGrammar, and it won't care what all is in Term either.</pre>\r\n<pre>I have considered having something like &quot;pre-defined&quot; productions with a &quot;custom&quot; non-terminal that can get added.</pre>\r\n<pre><span style=\"color:Green\">// Data member declaration</span>\r\n<span style=\"color:Blue\">protected</span> NonTerminal m_CustomUnaryOp;\r\n\r\n<span style=\"color:Green\">// In constructor:</span>\r\n<span style=\"color:Blue\">var</span> PredefinedUnaryOp = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;PredefinedUnOp&quot;</span>);\r\nm_CustomUnaryOp = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;CustomUnOp&quot;</span>);\r\n\r\nPredefinedUnaryOp.Rule = ToTerm(<span style=\"color:#A31515\">&quot;-&quot;</span>);\r\nm_CustomUnaryOp.Rule = <span style=\"color:Blue\">null</span>;\r\n</pre>\r\n<pre>However, this has a few problems:</pre>\r\n<pre>1) When I set the production for m_CustomUnaryOp, I would need to update PredefinedUnaryOp's rule to be:</pre>\r\n<pre>PredefinedUnaryOp.Rule = ToTerm(&quot;-&quot;) | m_CustomUnaryOp;</pre>\r\n<pre>and the sub classes don't have access to PredefinedUnaryOp.</pre>\r\n<pre>2) If I gave access to PredefinedUnaryOp, they could easily replace the rule for that and ignore m_CustomUnaryOp altogether.  (Sub classes should not be able to &quot;remove&quot; existing productions).</pre>\r\n<pre>3) If I just set:</pre>\r\n<pre>PredefinedUnaryOp.Rule = ToTerm(&quot;-&quot;) | m_CustomUnaryOp</pre>\r\n<pre>and the sub grammar never sets a rule for m_CustomUnaryOp, then there will be an error constructing either the grammar or the Ast (I forget which) since the rule is null.</pre>\r\n<pre>4) If I provide a protected function to perform the update necessary in #1 when the user wants to add custom unary operators, there is nothing that prevents a sub sub [sub...] grammar from calling the same function and replacing the custom operator defined in the sub grammar.</pre>\r\n<pre>I would need to keep overriding this function in every sub grammar and providing yet another custom operator non terminal for it's sub grammar to use... (Which can get messy quickly with a handful of these &quot;extensions&quot; needed for a grammar).</pre>\r\n<pre>It would be far nicer for the OR (|) operator to allow the addition of extra productions in a syntax such as in AddUnaryOperator:</pre>\r\n<pre>m_UnaryOperator.Rule |= someNewOperator;</pre>\r\n<pre>(or)</pre>\r\n<pre>m_UnaryOperator.Rule = m_UnaryOperator.Rule | someNewOperator;</pre>\r\n<pre>(or)</pre>\r\n<pre>m_UnaryOperator.Rule = someNewOperator | m_UnaryOperator.Rule;</pre>\r\n<pre>and then call this inside a protected function so that the sub grammars cannot directly modify m_UnaryOperator's rule.</pre>\r\n</div>",
    "PostedDate": "2010-01-11T08:43:44.63-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "275870",
    "ThreadId": "80451",
    "Html": "<p>I think you should try the following. Instead of using overloaded &quot;|&quot; and &quot;+&quot; operators when modifying rules, you should dig into BnfExpression (Rule property) and make careful alteration of its internal structure in code.</p>\r\n<p>Look at internals of operator overloads, here's a sample. Instead of</p>\r\n<p>&nbsp;&nbsp;&nbsp; m_Expression.Rule = unaryExp | m_Expression.Rule;</p>\r\n<p>do the following:</p>\r\n<p>&nbsp; <strong>var newList = new BnfTermList(); </strong></p>\r\n<p><strong>&nbsp; newList.Add(unaryExp);</strong></p>\r\n<p><strong>&nbsp; m_Expression.Rule.Data.Add(newList);</strong></p>\r\n<p>Look at BnfExpression.Data field&nbsp;-&nbsp;it is OR list of Plus-lists of BNF terms. So modify it directly in code. I think that'll do it</p>\r\n<p>Roman</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-11T13:45:25.993-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "276309",
    "ThreadId": "80451",
    "Html": "<p>Roman,</p>\r\n<p>First of all, thank you for your help.&nbsp; That sounds like a great suggestion.&nbsp; However, BnfExpression.Data is an internal property, and I cannot access it from outside of the assembly.</p>\r\n<p>I rewrote the OR (|) operator as:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Green\">//Pipe/Alternative</span>\r\n<span style=\"color:Blue\">internal</span> <span style=\"color:Blue\">static</span> BnfExpression Op_Pipe(BnfTerm term1, BnfTerm term2) {\r\n  BnfExpression expr1 = term1 <span style=\"color:Blue\">as</span> BnfExpression;\r\n  <span style=\"color:Blue\">if</span> (expr1 == <span style=\"color:Blue\">null</span>)\r\n    expr1 = <span style=\"color:Blue\">new</span> BnfExpression(term1);\r\n  BnfExpression expr2 = term2 <span style=\"color:Blue\">as</span> BnfExpression;\r\n  <span style=\"color:Blue\">if</span> (expr2 == <span style=\"color:Blue\">null</span>)\r\n    expr2 = <span style=\"color:Blue\">new</span> BnfExpression(term2);\r\n  expr1.Data.AddRange(expr2.Data);\r\n  <span style=\"color:Blue\">return</span> expr1;\r\n}\r\n</pre>\r\n</div>\r\n<p>After some testing, it seems to work fine.&nbsp; The ExpressionEvaluatorGrammar in the Irony.Samples builds, parses, and runs correctly even when I change:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>Expr.Rule = Term | UnExpr | BinExpr | PostFixExpr;\r\n</pre>\r\n</div>\r\n<p>to:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>Expr.Rule = Term;\r\nExpr.Rule = Expr.Rule | UnExpr;\r\nExpr.Rule = BinExpr | Expr.Rule;\r\nExpr.Rule |= PostFixExpr;\r\n</pre>\r\n</div>\r\n<p>Basically, I just changed it so that it gets both terms as expressions.&nbsp; Then it &quot;OR&quot;s all of the &quot;Plus&quot; lists in both expressions together (the call to AddRange(...)).</p>\r\n<p>I haven't tested it with GrammarHints (the only other kind of BnfTerm at the moment) as I have no idea what they really are to begin with.</p>\r\n<p>Do you see any problems with this new OR operator implementation?</p>\r\n<p>Brian</p>\r\n<p>UPDATE:</p>\r\n<p>I have found one very minor side-effect of this implementation of the OR operator: The ToString() method on BnfExpression does not always display correctly.</p>\r\n<p>This is due to the fact that the BnfExpression's Data is changed (added to)&nbsp;when it is used on the left hand side of the OR operator (as in Expr.Rule = Expr.Rule | UnExpr), and the string used for ToString() is cached.</p>\r\n<p>The underlying Data is stored correctly, but the ToString() does not update to represent that.&nbsp; The simplest solution is to not cache the ToString().</p>",
    "PostedDate": "2010-01-12T10:35:47.183-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "276757",
    "ThreadId": "80451",
    "Html": "<p>Well, I think this is an interesting suggestion and might (!) be a good improvement. Let me think about this, and if everything works with this I'll put it into next code drop</p>\r\n<p>thanks!</p>\r\n<p>Roman</p>",
    "PostedDate": "2010-01-13T09:47:32.183-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "280312",
    "ThreadId": "80451",
    "Html": "<p>Roman,</p>\r\n<p>I have given this topic a little more thought, and I have a few more suggestions.</p>\r\n<p>1) The solution I had given previously for the OR (|) operator does not follow normal operator guidelines; Operators should not modify the operands.<br>I propose a slightly modified version of the OR (|) operator:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Green\">//Pipe/Alternative</span>\r\n<span style=\"color:Blue\">internal</span> <span style=\"color:Blue\">static</span> BnfExpression Op_Pipe(BnfTerm term1, BnfTerm term2) {\r\n  <span style=\"color:Blue\">var</span> expr1 = term1 <span style=\"color:Blue\">as</span> BnfExpression;\r\n  <span style=\"color:Blue\">if</span> (expr1 == <span style=\"color:Blue\">null</span>)\r\n    expr1 = <span style=\"color:Blue\">new</span> BnfExpression(term1);\r\n  <span style=\"color:Blue\">var</span> expr2 = term2 <span style=\"color:Blue\">as</span> BnfExpression;\r\n  <span style=\"color:Blue\">if</span> (expr2 == <span style=\"color:Blue\">null</span>)\r\n    expr2 = <span style=\"color:Blue\">new</span> BnfExpression(term2);\r\n  <span style=\"color:Blue\">var</span> result = <span style=\"color:Blue\">new</span> BnfExpression();\r\n  result.Data.AddRange(expr1.Data);\r\n  result.Data.AddRange(expr2.Data);\r\n  <span style=\"color:Blue\">return</span> result;\r\n}\r\n</pre>\r\n</div>\r\n<p>The biggest difference here is simply that we do not change the first expression, but rather use it to compute a separate result expression.<br>Since term1 is no longer modified (if it was a BnfExpression to start with), there is no more problem with caching the ToString() method once again.<br>Also, term1 can safely be reused in other rules:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>BnfExpression someExpression = ToTerm(<span style=\"color:#A31515\">&quot;Hello&quot;</span>) + <span style=\"color:#A31515\">&quot;World&quot;</span>;\r\nNonTerminal bobSays = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;BobSays&quot;</span>);\r\nbobSays.Rule = someExpression | ToTerm(<span style=\"color:#A31515\">&quot;Goodbye&quot;</span>);\r\nNonTerminal susanSays = <span style=\"color:Blue\">new</span> NonTerminal(<span style=\"color:#A31515\">&quot;SusanSays&quot;</span>);\r\nsusanSays.Rule = someExpression | ToTerm(<span style=\"color:#A31515\">&quot;Wow&quot;</span>);\r\n</pre>\r\n</div>\r\n<p>2) The AND (+)&nbsp;operator currently allows expressions to be formed that are not in BNF.&nbsp; BNF states that you can only have &quot;OR&quot; lists of &quot;PLUS&quot; lists of terms.<br>However, the current implementation of the AND (+) operator allows the following expression:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>BnfExpression someExpression =\r\n  ToTerm(<span style=\"color:#A31515\">&quot;This&quot;</span>) + (ToTerm(<span style=\"color:#A31515\">&quot;is&quot;</span>) | <span style=\"color:#A31515\">&quot;not&quot;</span> | <span style=\"color:#A31515\">&quot;in&quot;</span> | <span style=\"color:#A31515\">&quot;BNF&quot;</span>)\r\n</pre>\r\n</div>\r\n<p>Logically, this should not be allowed since it creates an expression that is not in BNF.&nbsp; This statement also creates problems when you try to use<br>it as a NonTerminal's Rule with an AST-building grammar.&nbsp; Those pesky extra NonTerminals start showing up that don't have an AstNode type<br>associated with them (&quot;NT0&quot;, &quot;NT1&quot;, etc.).&nbsp; In this case, the extra NT &quot;NT0&quot; shows up as the &quot;is|not|in|BNF&quot; portion of the rule.<br>(With someExpression being created as &quot;This+NT0&quot;).&nbsp; The lack of an AstNode type causes exceptions to get thrown when constructing the AST.</p>\r\n<p>To solve both of these issues, I propose a new AND (+) operator:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Green\">// Plus/sequence</span>\r\n<span style=\"color:Blue\">internal</span> <span style=\"color:Blue\">static</span> BnfExpression Op_Plus(BnfTerm term1, BnfTerm term2) {\r\n  <span style=\"color:Blue\">var</span> expr1 = term1 <span style=\"color:Blue\">as</span> BnfExpression;\r\n  <span style=\"color:Blue\">if</span> (expr1 == <span style=\"color:Blue\">null</span>)\r\n    expr1 = <span style=\"color:Blue\">new</span> BnfExpression(term1);\r\n  <span style=\"color:Blue\">var</span> expr2 = term2 <span style=\"color:Blue\">as</span> BnfExpression;\r\n  <span style=\"color:Blue\">if</span> (expr2 == <span style=\"color:Blue\">null</span>)\r\n    expr2 = <span style=\"color:Blue\">new</span> BnfExpression(term2);\r\n\r\n  <span style=\"color:Green\">// If either one is a Pipe-type expression, it is not BNF</span>\r\n  <span style=\"color:Blue\">if</span> (expr1.Data.Count &gt; 1 || expr2.Data.Count &gt; 1)\r\n    <span style=\"color:Blue\">throw</span> <span style=\"color:Blue\">new</span> ArgumentException(<span style=\"color:#A31515\">&quot;Invalid expression&quot;</span>);\r\n\r\n  <span style=\"color:Blue\">var</span> result = <span style=\"color:Blue\">new</span> BnfExpression();\r\n  result.Data.Add(<span style=\"color:Blue\">new</span> BnfTermList());\r\n  result.Data[0].AddRange(expr1.Data[0]);\r\n  result.Data[0].AddRange(expr2.Data[0]);\r\n\r\n  <span style=\"color:Blue\">return</span> result;\r\n}\r\n</pre>\r\n</div>\r\n<p>Basically, it gets both terms as an expression that should be just a single Plus-list.&nbsp; If either one of them has more than one<br>Plus-list (A &quot;Pipe-type&quot; expression), then it is not in proper BNF, and an exception is thrown.&nbsp; The result is an expression<br>that is a single Plus-list of everything that was in the Plus-list of the first expression followed by the Plus-list of the second<br>expression.</p>\r\n<p>3) In order for these operators to work correctly, the BnfExpression's constructors just be modified slightly:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">public</span> BnfExpression(BnfTerm element) : <span style=\"color:Blue\">this</span>() {\r\n  Data.Add(<span style=\"color:Blue\">new</span> BnfTermList());\r\n  Data[0].Add(element);\r\n}\r\n<span style=\"color:Blue\">public</span> BnfExpression() : <span style=\"color:Blue\">base</span>(<span style=\"color:Blue\">null</span>) {\r\n  Data = <span style=\"color:Blue\">new</span> BnfExpressionData();\r\n}\r\n</pre>\r\n</div>\r\n<p>The only difference is that the line &quot;Data.Add(new BnfTermList());&quot; got moved from the default constructor, to the initial value constructor.<br>The reason for this change is so that when creating an empty expression (via the default constructor), there isn't already a single, empty Plus-list.<br>Without this change, the new OR and AND operators would leave some empty Plus-list &quot;artifacts&quot; with the calls to AddRange.</p>\r\n<p>For example, an expression such as:</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>BnfExpression someExpression =\r\n  ToTerm(<span style=\"color:#A31515\">&quot;This&quot;</span>) | <span style=\"color:#A31515\">&quot;is&quot;</span> | <span style=\"color:#A31515\">&quot;a&quot;</span> | <span style=\"color:#A31515\">&quot;test&quot;</span>;\r\n</pre>\r\n</div>\r\n<p>would have an OR-list looking like:</p>\r\n<p>[&lt;emptyPlusList&gt;, &lt;emptyPlusList&gt;, &lt;emptyPlusList&gt;, &quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;]</p>\r\n<p>&nbsp;</p>\r\n<p>What do you think about these three changes?</p>\r\n<p>Brian</p>",
    "PostedDate": "2010-01-21T16:49:21.06-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "280859",
    "ThreadId": "80451",
    "Html": "<p>Ok, thanks for the suggestions!</p>\r\n<p>1) - changing the Op_pipe implementation. Honestly, I don't see a big value in this change. About caching the ToString value - I'm in fact removing it, it will no longer be a problem. As for reusing &quot;expressions&quot; - this is quite &quot;uncommon&quot; way of forming expressions I think, and I don't see much value in it. What is unusual in this pattern is that you're reusing segments of expressions instead of defining a new non-terminal enclosing the repeated segment - which makes sense in most cases.</p>\r\n<p>2) What you mean probably is that &quot;+&quot; operator forms expressions that are not in &quot;normalized&quot; form - set of productions. You suggest to disallow this at the level of expressions. Irony automatically normalizes such expressions by adding extra non-terminals. You say - it is bad because new nonterminals don't have AST node assigned. But not every grammar&nbsp;has a purpose of creating AST tree, some applications are ok with just parse tree. An example - SearchGrammar in samples, it does not need AST, it works directly with parse tree nodes. And other&nbsp;examples&nbsp;are quite&nbsp;viable - code colorizers, formatters, converters.&nbsp;So in grammars like these, prohibiting use of OR operator inside PLUS expressions would be quite limiting and annoying. Even&nbsp;if a grammar&nbsp;creates AST, still in some cases such no-AST nodes can make sense. I'm actually thinking about adding NoAst flag to term flags - it would allow mark some non-terminals that they don't need AST node, so grammar validation would not throw error.</p>\r\n<p>3) - is necessary only for 1) and 2)</p>\r\n<p>So for now I would prefer leave things as is. I already put in place the change to OP_Pipe you suggested previously.</p>\r\n<p>thanks</p>\r\n<p>Roman</p>",
    "PostedDate": "2010-01-23T00:15:33.197-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
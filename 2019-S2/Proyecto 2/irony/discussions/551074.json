[
  {
    "Id": "1264163",
    "ThreadId": "551074",
    "Html": "I suspect if I understood context-free grammar better, I could answer my own question. Can two production rules use the same starting terminal? Here's an example:<br />\n<pre><code>    public ParserSandbox1Grammar()\n      : base(true)\n    {\n      // 1. Terminals\n\n      // 2. Non-terminals\n      var function = new NonTerminal(&quot;Function&quot;);\n      var functions = new NonTerminal(&quot;Functions&quot;);\n      var global = new NonTerminal(&quot;Global&quot;);\n      var globals = new NonTerminal(&quot;Globals&quot;);\n      var globalsBlock = new NonTerminal(&quot;GlobalsBlock&quot;);\n      var symFile = new NonTerminal(&quot;SymFile&quot;);\n\n      // 3. BNF rules\n      function.Rule = ToTerm(&quot;foo&quot;) + &quot;baz&quot;;\n      functions.Rule = MakeStarRule(functions, function);\n      global.Rule = ToTerm(&quot;foo&quot;) + &quot;bar&quot;;\n      globals.Rule = MakePlusRule(globals, global);\n      globalsBlock.Rule = &quot;(no globals)&quot; | globals;\n      symFile.Rule = globalsBlock + functions;\n      Root = symFile;       // Set grammar root\n\n      //automatically add NewLine before EOF so that our BNF rules work correctly when there's no final line break in source\n      this.LanguageFlags = LanguageFlags.CreateAst | LanguageFlags.NewLineBeforeEOF;\n    }</code></pre>\n\nHere's the input:<br />\n<pre><code>foo bar\nfoo baz</code></pre>\n\n...where &quot;foo bar&quot; is a &quot;global&quot; and &quot;foo baz&quot; is a &quot;function&quot;. Irony tries to interpret &quot;foo baz&quot; as a global, not a function, even though 0 or more functions may follow globals in my example above.<br />\n",
    "PostedDate": "2014-07-09T14:36:53.647-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1264187",
    "ThreadId": "551074",
    "Html": "OK. Here's a little more complex example of the same situation:\r<br />\n<br />\nConsider the following input file:<br />\n<pre><code>source foo\na global\nstatic b global\nstatic s function\n\nsource bar\na global</code></pre>\n\nThere are 1 or more &quot;source&quot; clauses. Each of these clauses has a 1 or more &quot;global&quot;s and 0 or more &quot;function&quot;s. A global or function may start with the &quot;static&quot; keyword. I've parsed this input file with Antlr. Here's the Antlr grammar:<br />\n<pre><code>grammar Hello;\nSOURCE   : 'source';\nGLOBAL   : 'global';\nSTATIC   : 'static';\nFUNCTION : 'function';\nfunction : STATIC? ID FUNCTION;\nglobal   : STATIC? ID GLOBAL;\nsource   : SOURCE ID global+ function*;\nfile     : source+;\nID : [a-z]+ ;             // match lower-case identifiers\nWS : [ \\t\\r\\n]+ -&gt; skip ; // skip spaces, tabs, newlines</code></pre>\n\nThe corresponding Irony grammar in C# is as follows:<br />\n<pre><code>  [Language(&quot;ParserSandbox1Grammar&quot;, &quot;1.0&quot;, &quot;ParserSandbox1 Grammar&quot;)]\n  public class ParserSandbox1Grammar : Grammar\n  {\n    public ParserSandbox1Grammar()\n      : base(true)\n    {\n      // 1. Terminals\n      KeyTerm staticTerm = ToTerm(&quot;static&quot;, &quot;staticTerm&quot;);\n      NonTerminal staticTermOpt = new NonTerminal(&quot;staticTermOpt&quot;, Empty | staticTerm);\n      var identifier = new IdentifierTerminal(&quot;Identifier&quot;);\n\n\n      // 2. Non-terminals\n      var global = new NonTerminal(&quot;Global&quot;);\n      var function = new NonTerminal(&quot;Function&quot;);\n      var source = new NonTerminal(&quot;Source&quot;);\n      var file = new NonTerminal(&quot;SymFile&quot;);\n\n\n      // 3. BNF rules\n      function.Rule = staticTermOpt + identifier + &quot;function&quot;;\n      global.Rule = staticTermOpt + identifier + &quot;global&quot;;\n      source.Rule = &quot;source&quot; + identifier + MakePlusRule(source, global) + MakeStarRule(source, function);\n      file.Rule = MakePlusRule(file, source);\n      Root = file;       // Set grammar root\n\n      //automatically add NewLine before EOF so that our BNF rules work correctly when there's no final line break in source\n      LanguageFlags = LanguageFlags.CreateAst | LanguageFlags.NewLineBeforeEOF;\n    }\n  }</code></pre>\n\nAntlr parses the input file just fine, however Irony throws a syntax error here:<br />\n<pre><code>source foo\na global\nstatic b global\n         ^\n\n&quot;Syntax error, expected: function&quot;</code></pre>\n\nIrony also gives 4 conflicts. I can provide those if you'd like. Why is Irony insisting that this line be a &quot;function&quot; line? The &quot;source&quot; rule allows multiple globals.<br />\n",
    "PostedDate": "2014-07-09T17:03:13.247-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1264192",
    "ThreadId": "551074",
    "Html": "Context-free grammar understanding is not enough - you have to know smth about parsing methods like LR, LALR(1), LL, etc. Irony is LALR(1), while Antlr is LL. Grammar rules should be fine-tuned for a specific method. Irony 'is insisting' on something 'wrong' means that it took one of two equally possible alternatives resulting from ambiguities (conflicts!) that it reports. So no point trying to parse smth before you fix the conflicts. To do this - read more about LALR grammars.<br />\n",
    "PostedDate": "2014-07-09T17:41:40.017-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
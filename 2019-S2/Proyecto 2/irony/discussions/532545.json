[
  {
    "Id": "1210011",
    "ThreadId": "532545",
    "Html": "Hello All,\r<br />\nI am implementing a language in Irony similar to (for now) C#. It was implemented from the C# 4.0 specification. It has issues when parsing method declarations. Specifically, it is failing to reduce to return_type. I have tested changing the <strong>return_type</strong> in <strong>method_header</strong> to <strong>type_ref</strong> and it then recognizes the declaration, but it fails for a <strong>void</strong> return type (for obvious reasons). I feel I am missing something and could use some other eyes on this. Any help would be greatly appreciated.\r<br />\nI have attached the complete grammar to the post in 'issues' of the same title.\r<br />\n<br />\n// NonTerminals\r<br />\n<strong>type_ref</strong>, <strong>return_type</strong>, <strong>method_header</strong>, <strong>method_declaration</strong>\r<br />\n<br />\nKeyTerm @void = ToTerm( &quot;void&quot; );\r<br />\ntype_ref.Rule = value_type | reference_type | type_parameter;\r<br />\nreturn_type.Rule = type_ref |   <a href=\"mailto:@void;\r\n\r\nmethod_header.Rule\" rel=\"nofollow\">@void;\r\n\r\nmethod_header.Rule</a> = member_header + return_type + member_name + type_parameter_list.Q() + open_par + formal_parameter_list.Q() + close_par + type_parameter_constraints_clauses.Q();\r<br />\nmethod_declaration.Rule = method_header + method_body;<br />\n",
    "PostedDate": "2014-02-18T11:15:59.027-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1210308",
    "ThreadId": "532545",
    "Html": "the first question to ask - did you test in GrammarExplorer, and did it show any grammar errors (shift/reduce conflicts)? If not, did you apply any hints or tricks to get rid of conflicts?<br />\n",
    "PostedDate": "2014-02-18T23:09:31.44-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1210698",
    "ThreadId": "532545",
    "Html": "Hey there. Thank you for the reply. I have tested it extensively in the GrammarExplorer and yes, there are many conflicts. My problem is, while I have read many documents on parsing and the specifics to LALR parsers, I fail to understand *why there is a conflict. Also, I fail to understand the proper placement of the <strong>PreferShiftHere()</strong> or <strong>ReduceHere()</strong>. The grammar I have implemented is spiritually identical to the C# 3.0 grammar you included in the samples. I used the <strong>.Q()</strong> method as opposed to the separate __*<em>opt</em>_ style in your example and the naming scheme follows the spec. The main difference in the <strong>method_declaration</strong> is that your example uses <strong>type_ref</strong> while mine uses <strong>return_type</strong>. The important difference (please correct me where I am wrong) is that the sample definition of <strong>type_ref</strong> includes and allowance for the <strong>&quot;void&quot;</strong> keyword/terminal where as this/my implementation and the spec do not (as void is only allowed for a method return type and hence, the additional non-terminal). I have tested the grammar by modifying it to use <strong>type_ref</strong> and added <strong>&quot;void&quot;</strong> to it. It <strong>does</strong> work, but that allows (grammatically) <strong>&quot;void&quot;</strong> to be placed almost anywhere and does not cause a syntax error.\r<br />\n  The problem observed in the GrammarExplorer is that the state transitions through the reductions from <strong>integral_type</strong>-&gt;<strong>int</strong> (for example) all the way to <strong>type_ref</strong> (which is correct) but then stops and does not reduce further to <strong>return_type</strong>. I have no idea where to add a hint. The <strong>method_header</strong> is listed properly (GE output listed below).\r<br />\n  Again, please excuse my ignorance. If you could link me to any reference material that would lead me in the right direction, I would be forever grateful.<br />\n<pre><code>State S934 __(Inadequate)__\n  Shift-reduce conflicts on inputs: identifier\n  Shift items:\n    constant_declaration -&gt; member_header ·const type_ref constant_declarators semi \n    field_declaration -&gt; member_header ·type_ref variable_declarators semi \n    type_ref -&gt; ·value_type \n    value_type -&gt; ·struct_type \n    struct_type -&gt; ·type_name \n    type_name -&gt; ·namespace_or_type_name \n    namespace_or_type_name -&gt; ·identifier Unnamed1 \n    namespace_or_type_name -&gt; ·namespace_or_type_name dot identifier Unnamed38 \n    namespace_or_type_name -&gt; ·qualified_alias_member \n    qualified_alias_member -&gt; ·identifier colon_colon identifier Unnamed8 \n    struct_type -&gt; ·simple_type \n    simple_type -&gt; ·numeric_type \n    numeric_type -&gt; ·integral_type \n    integral_type -&gt; ·sbyte \n    integral_type -&gt; ·byte \n    integral_type -&gt; ·short \n    integral_type -&gt; ·ushort \n    integral_type -&gt; ·int \n    integral_type -&gt; ·uint \n    integral_type -&gt; ·long \n    integral_type -&gt; ·ulong \n    integral_type -&gt; ·char \n    numeric_type -&gt; ·floating_point_type \n    floating_point_type -&gt; ·float \n    floating_point_type -&gt; ·double \n    numeric_type -&gt; ·real \n    simple_type -&gt; ·bool \n    struct_type -&gt; ·nullable_type \n    nullable_type -&gt; ·non_nullable_value_type qmark \n    non_nullable_value_type -&gt; ·type_ref \n    value_type -&gt; ·enum_type \n    enum_type -&gt; ·type_name \n    value_type -&gt; ·pointer_type \n    pointer_type -&gt; ·unmanaged_type astrisk \n    unmanaged_type -&gt; ·integral_type \n    unmanaged_type -&gt; ·floating_point_type \n    unmanaged_type -&gt; ·char \n    unmanaged_type -&gt; ·bool \n    pointer_type -&gt; ·void astrisk \n    type_ref -&gt; ·reference_type \n    reference_type -&gt; ·class_type \n    class_type -&gt; ·type_name \n    class_type -&gt; ·object \n    class_type -&gt; ·dynamic \n    class_type -&gt; ·string \n    reference_type -&gt; ·interface_type \n    interface_type -&gt; ·type_name \n    reference_type -&gt; ·array_type \n    array_type -&gt; ·type_ref rank_specifiers \n    reference_type -&gt; ·delegate_type \n    delegate_type -&gt; ·type_name \n    type_ref -&gt; ·type_parameter \n    type_parameter -&gt; ·attributes identifier \n    attributes -&gt; ·attribute_section+ \n    attribute_section+ -&gt; ·attribute_section+ attribute_section \n    attribute_section+ -&gt; ·attribute_section \n    attribute_section -&gt; ·[ Unnamed2 attribute_list ] \n    constructor_declaration -&gt; member_header ·constructor_declarator method_body \n    constructor_declarator -&gt; ·identifier ( Unnamed55 ) Unnamed56 \n    property_declaration -&gt; member_header ·type_ref member_name { accessor_declarations } \n    extension_property_declaration -&gt; member_header ·type_ref member_name [ this type_ref identifier ] { accessor_declarations } \n    event_declaration -&gt; member_header ·event type_ref variable_declarators semi \n    event_declaration -&gt; member_header ·event type_ref member_name { event_accessor_declarations } \n    indexer_declaration -&gt; member_header ·indexer_declarator { accessor_declarations } \n    indexer_declarator -&gt; ·type_ref this [ formal_parameter_list ] \n    __method_header -&gt; member_header ·return_type member_name Unnamed43 ( Unnamed44 ) Unnamed47__ \n    return_type -&gt; ·type_ref \n    return_type -&gt; ·void \n    class_declaration -&gt; member_header ·class identifier Unnamed50 Unnamed51 Unnamed53 class_body Unnamed58 \n    struct_declaration -&gt; member_header ·struct identifier Unnamed59 Unnamed60 Unnamed61 struct_body Unnamed62 \n    interface_declaration -&gt; member_header ·interface identifier Unnamed63 Unnamed65 Unnamed66 interface_body Unnamed74 \n    enum_declaration -&gt; member_header ·enum identifier Unnamed75 enum_body Unnamed77 \n    delegate_declaration -&gt; member_header ·delegate return_type identifier Unnamed78 ( Unnamed79 ) Unnamed80 semi </code></pre>\n\n",
    "PostedDate": "2014-02-19T10:55:31.663-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1210958",
    "ThreadId": "532545",
    "Html": "Ok, I see where you are in this. Here's the main points<br />\n<ol>\n<li>The main rule: do NOT start parsing until you resolve all conflicts in grammar explorer. Parsing errors you see - failing to parse seemingly correct input - is the direct result of these conflicts. </li>\n<li>\nYou say &quot; I fail to understand why there is a conflict. &quot;. See below. But note, that placing 'PreferShiftHere' hints is not a solution, unless you know for sure what you're doing. These particular hints, non-conditional hints, are rarely usable, only when there's a clear language rule that dictates how to act in case of syntactic ambiguity. One such case is 'dangling else' (google it), and there's a rule that 'else' is always for the closest preceding 'if', so PreferShiftHere is a clear implementation of this 'non-syntax' rule. In cases like you describe, usually you need an extra work, the proper action is NOT always the same and depends on symbols down the stream or some extra info. Another thing BTW - do not use .Q() method, it is effectively deprecated, it is a useful notation in BNF, but causes a lot of problems in Irony grammar, so it's better not use it. <br />\n</li>\n</ol>\nHere's a quick 101 on grammar conflicts. LALR(1) parser is a strict machine operating thru clear rules. Given a 'state' and an input (terminal), decide on reduce or shift action, perform an action, and move to the next state. The key here is 'decide', and ideally, for a given state and input there must always be a single action. Sometimes, there's more than 1 action, the parser is on a road fork, and has no clear choice between alternatives. These situations are detected before parsing anything, during parser state machine construction, and reported as conflicts. All conflicts you see on Grammar Errors page are such situations. Parser builder reports the conflict, but chooses some 'default' action, so it will be able to start parsing - just to give you a chance to fix it later, but it's decisions are not garanteed to be correct. That's what you see as result - wrong parser decisions.<br />\nNow the conflict itself - as far as I can see, it boils down to the following simplified situation. Suppose the parser read the following string (dot indicates the current position):<br />\n<br />\npublic SomeType . Foo<br />\n<br />\nRight after the parser 'swallowed' SomeType, it must decide on reduce or shift action, with 'Foo' as an input. According to your grammar, it is type_ref; after reducing to type_ref, we're in the same place, but now we have a decision to make: is type_ref actually a return_type (so we parsing method), or it should be left as is (we are parsing field or property). It might be one of the following:<br />\n<br />\npublic SomeType Foo;<br />\npublic SomeType Foo() { }<br />\npublic SomeType Foo {get;}<br />\n<br />\n<br />\nIt is easy to see why parser is in trouble here - no way to know, given the information (remember, it is LALR(1), so parser sees only 'Foo', and nothing else). And as you see, the conflict involves not only method_header (as you probably assumed in your first post), but also field and property headers. <br />\nThere are 2 ways to deal with situation (at least, maybe more). BTW, ReduceHere or PreferShiftHere, fixed hints are no way to go - they will suppress the conflict but suggest fixed and wrong decision algorithm for parser.<br />\nFirst, you can make a quick run ahead and see what follows first - semicolon, parenthesis or curly brace. This is what is Grammar.ReduceIf method is doing - it adds a hint with custom action that runs ahead and finds the first character out of given set. c# sample grammar was put together before this hint was there, so it does not use it. Now, keep in mind that it might be not as simple as it seems - you might have more stuff jammed up right after Foo (generic arguments, comments, even conditionals or attributes?) which might make this lookup more complicated; so you have to use careful analysis of all possibilities when you use it. Essentially, it is a quick hack, workaround based on kind of euristic rule.<br />\nThe other possibility is to include 'void' into type_ref, and let parser parse it all. To catch the wrong use of 'void' in property or field you can hook to Reduced event of method_header, property_header, etc, and in event handler run through parsed elements, detect that void was used on property or field, and add parse error - all tools are available there through event args. Apparently this check is missing from c# grammar. Keep in mind, c# grammar is a simplified SAMPLE, incomplete and not a real thing, just a demo to show how to build some basic stuff.<br />\nI hope this clears the trouble you have, and shows some way you can proceed. Good luck. <br />\nSorry, all these troubles are not in general Irony's faults, it is foundational limitations of LALR algorithm - you would have the same trouble with other LALR-based tools. Although admittedly Irony could provide more built-in tricks to deal with stuff like this, one of them is GLR parsing - I wish I had more time to fix all this...<br />\nGood luck<br />\nRoman<br />\n",
    "PostedDate": "2014-02-19T23:21:31.51-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1211373",
    "ThreadId": "532545",
    "Html": "Hey Roman,\r<br />\n  Thank you for all your efforts. You have helped me tremendously. With the information you have given here, I am sure I will be successful with this project. I will make sure to document heavily and post the results for your other users.<br />\n",
    "PostedDate": "2014-02-20T12:50:38.223-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
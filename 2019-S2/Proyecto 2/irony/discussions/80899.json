[
  {
    "Id": "277395",
    "ThreadId": "80899",
    "Html": "<p>HI there. Firstly, I'm brand new to Irony so could be doing something really stupid. Nevertheless...</p>\r\n<p>I've upgraded my Irony DLL from the one I was using in an example (<a href=\"http://www.codeproject.com/KB/recipes/YourFirstDSL.aspx?display=Print\">http://www.codeproject.com/KB/recipes/YourFirstDSL.aspx?display=Print</a>) to the most recent (8499). (The DLLs dont appear to be versioned?)</p>\r\n<p>The main reason I upgraded was to take advange of MarkTransient() to clean up my tree.</p>\r\n<p>My basic grammar was (as far as I know) correct for all the use cases I had. It appears that even simple rules now no longer work. For example:</p>\r\n<pre>var alphas = new NonTerminal(&quot;alphas&quot;);\r\nvar alpha = new NonTerminal(&quot;alpha&quot;);\r\n\r\nalphas.Rule = alpha + alpha;\r\nalpha.Rule = ToTerm(&quot;a&quot;) | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; | &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;;</pre>\r\n<p>This should (I believe) allow me to enter in something trivial like &quot;xy&quot; (without quotes) however it's failing with the message: Invalid character: 'y'.&nbsp;<br>This is a simplified version of the real problem I'm having which is that MakePlusRule() doesn't appear to be working.</p>\r\n<p>Any ideas? Any help would be very much appreciated! It's a great product but I'm going bonkers! Cheers!</p>\r\n<p>My full (existing and new) grammars are below:</p>\r\n<p>EXISTING</p>\r\n<p>&nbsp;</p>\r\n<pre>        public LocSpecGrammar()\r\n        {\r\n            #region Initial setup of the grammar\r\n\r\n            CaseSensitive = false;\r\n\r\n            // define all the terminals and non-terminals\r\n            var program = new NonTerminal(&quot;program&quot;);\r\n\r\n            var stmts = new NonTerminal(&quot;stmts&quot;);\r\n            var stmt = new NonTerminal(&quot;stmt&quot;);\r\n\r\n            var variableDist = new NonTerminal(&quot;variableDist&quot;);\r\n            var valueDist = new NonTerminal(&quot;valueDist&quot;);\r\n\r\n            var variable = new NonTerminal(&quot;variable&quot;);\r\n\r\n            var loc_locSet_locRanges = new NonTerminal(&quot;loc_locSet_locRanges&quot;);\r\n            var loc_locSet_locRange = new NonTerminal(&quot;loc_locSet_locRange&quot;);\r\n            var locSet = new NonTerminal(&quot;locSet&quot;);\r\n            var locRange = new NonTerminal(&quot;locRange&quot;);\r\n            var loc = new NonTerminal(&quot;loc&quot;);\r\n\r\n            var alphanumerics = new NonTerminal(&quot;alphanumerics&quot;);\r\n            var alphanumeric = new NonTerminal(&quot;alphanumeric&quot;);\r\n            var alpha = new NonTerminal(&quot;alpha&quot;);\r\n\r\n            var number = new NumberLiteral(&quot;number&quot;) { DefaultIntTypes = new[] { TypeCode.Int32 } };\r\n\r\n            // specify the non-terminal which is the root of the AST\r\n            Root = program;\r\n\r\n            #endregion\r\n\r\n            #region Grammar definition\r\n\r\n            program.Rule = stmts;\r\n\r\n            stmts.Rule = MakePlusRule(stmts, Symbol(&quot;,&quot;), stmt);\r\n            stmt.Rule = variableDist | valueDist | loc_locSet_locRange;\r\n\r\n            variableDist.Rule = &quot;dist(&quot; + loc_locSet_locRanges + &quot;:&quot; + variable + &quot;)&quot;;\r\n            valueDist.Rule = &quot;dist(&quot; + loc_locSet_locRanges + &quot;)&quot;;\r\n\r\n            variable.Rule = alpha | alpha + alphanumerics;\r\n\r\n            loc_locSet_locRanges.Rule = MakePlusRule(loc_locSet_locRanges, Symbol(&quot;,&quot;), loc_locSet_locRange);\r\n            loc_locSet_locRange.Rule = loc | locSet | locRange;\r\n            locSet.Rule = &quot;#&quot; + alphanumerics;\r\n            locRange.Rule = number + &quot;-&quot; + number | alphanumerics + number + &quot;-&quot; + number;\r\n            loc.Rule = alphanumerics;\r\n\r\n            alphanumerics.Rule = MakePlusRule(alphanumerics, null, alphanumeric);\r\n            alphanumeric.Rule = alpha | number;\r\n\r\n            alpha.Rule = Symbol(&quot;a&quot;) | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; | &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;;\r\n\r\n            #endregion\r\n        }\r\n    }</pre>\r\n<p>NEW</p>\r\n<p>&nbsp;</p>\r\n<pre>[Language(&quot;Qubit LocSpec&quot;, &quot;1.0&quot;, &quot;Grammar for the definition of a location specification within a dimension.&quot;)]\r\n    public class LocSpecGrammar : Grammar\r\n    {\r\n        public LocSpecGrammar()\r\n            : base(false) // false means case insensitive\r\n        {\r\n            #region Initial setup of the grammar\r\n\r\n            GrammarComments = @&quot;Expressions for dimension location specifications.&quot;;\r\n\r\n            var program = new NonTerminal(&quot;program&quot;);\r\n\r\n            var stmts = new NonTerminal(&quot;stmts&quot;);\r\n            var stmt = new NonTerminal(&quot;stmt&quot;);\r\n\r\n            var variableDist = new NonTerminal(&quot;variableDist&quot;);\r\n            var valueDist = new NonTerminal(&quot;valueDist&quot;);\r\n\r\n            var variable = new NonTerminal(&quot;variable&quot;);\r\n\r\n            var loc_locSet_locRanges = new NonTerminal(&quot;loc_locSet_locRanges&quot;);\r\n            var loc_locSet_locRange = new NonTerminal(&quot;loc_locSet_locRange&quot;);\r\n            var locSet = new NonTerminal(&quot;locSet&quot;);\r\n            var locRange = new NonTerminal(&quot;locRange&quot;);\r\n            var loc = new NonTerminal(&quot;loc&quot;);\r\n\r\n            var alphanumerics = new NonTerminal(&quot;alphanumerics&quot;);\r\n            var alphanumeric = new NonTerminal(&quot;alphanumeric&quot;);\r\n            var alpha = new NonTerminal(&quot;alpha&quot;);\r\n\r\n            var number = new NumberLiteral(&quot;number&quot;) { DefaultIntTypes = new[] { TypeCode.Int32 } };\r\n\r\n            // specify the non-terminal which is the root of the AST\r\n            Root = program;\r\n\r\n            #endregion\r\n\r\n            #region Grammar definition\r\n\r\n            program.Rule = stmts;\r\n\r\n            stmts.Rule = MakePlusRule(stmts, ToTerm(&quot;,&quot;), stmt);\r\n            stmt.Rule = variableDist | valueDist | loc_locSet_locRange;\r\n\r\n            variableDist.Rule = &quot;dist(&quot; + loc_locSet_locRanges + &quot;:&quot; + variable + &quot;)&quot;;\r\n            valueDist.Rule = &quot;dist(&quot; + loc_locSet_locRanges + &quot;)&quot;;\r\n\r\n            variable.Rule = alpha | alpha + alphanumerics;\r\n\r\n            loc_locSet_locRanges.Rule = MakePlusRule(loc_locSet_locRanges, ToTerm(&quot;,&quot;), loc_locSet_locRange);\r\n            loc_locSet_locRange.Rule = loc | locSet | locRange;\r\n            locSet.Rule = &quot;#&quot; + alphanumerics;\r\n            locRange.Rule = number + &quot;-&quot; + number | alphanumerics + number + &quot;-&quot; + number;\r\n            loc.Rule = alphanumerics;\r\n\r\n            alphanumerics.Rule = MakePlusRule(alphanumerics, alphanumeric);\r\n            alphanumeric.Rule = alpha | number;\r\n\r\n            alpha.Rule = ToTerm(&quot;a&quot;) | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; | &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot; | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot; | &quot;y&quot; | &quot;z&quot;;\r\n\r\n            #endregion\r\n        }</pre>",
    "PostedDate": "2010-01-14T16:56:24.217-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "277438",
    "ThreadId": "80899",
    "Html": "<p>I think you are missing one important concept - how terminals work in Irony.&nbsp;Looks like you use an&nbsp;expression</p>\r\n<pre>variable.Rule = alpha | alpha + alphanumerics;</pre>\r\n<p>to define an identifier (starts with letter followed by letters or digits).</p>\r\n<p>You should use IdentifierTerminal instead&nbsp;- look how it is done in sample grammars, ExprEvaluator grammar in particular</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-14T20:24:43.653-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "277443",
    "ThreadId": "80899",
    "Html": "<p>Thanks for the quick reply. I didn't see IdentifierTerminal when I was looking around the types -- thanks for that.</p>\r\n<p>Nevertheless, why is my grammar that was working now failing? Have the meanings changed?</p>\r\n<p>I was going to start looking into the other stuff such as CompoundTerminalBase and cleaning up the grammar once I upgraded but it's a bit hard when it suddenly just broke!</p>\r\n<p>To create a Terminal which allows any of the alphanumeric characters [A-Za-z0-9] (with no restriction on ordering) I'm guessing I'd have to do something very similar to IdentifierTerminal?</p>\r\n<p>Sorry if these are stupid questions. I really appreciate your help.</p>",
    "PostedDate": "2010-01-14T20:48:48.42-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "277450",
    "ThreadId": "80899",
    "Html": "<p>I guess a partial answer to my question is that IdentifierTerminal(&quot;identifier&quot;, String.Empty, Strings.DecimalDigits) would give me an alphanumeric with no ordering requirements? e.g. &quot;1abc1&quot;.</p>",
    "PostedDate": "2010-01-14T21:19:00.767-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "277456",
    "ThreadId": "80899",
    "Html": "<p>I'm still having troubles...</p>\r\n<p>So take a very simple grammar:</p>\r\n<p>&nbsp;</p>\r\n<pre>var identifier = new IdentifierTerminal(&quot;identifier&quot;);\r\nvar valueDist = new NonTerminal(&quot;valueDist&quot;);\r\nvalueDist.Rule = &quot;dist(&quot; + identifier + &quot;)&quot;;</pre>\r\n<pre>Root = valueDist;</pre>\r\n<p>I believe that</p>\r\n<pre>dist(ABC123)</pre>\r\n<p>should be valid, right? I get the error 'Invalid character: 'A'.</p>\r\n<p>What am I doing wrong? :(</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-14T21:49:09.073-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "277566",
    "ThreadId": "80899",
    "Html": "<p>There's additional check added lately in KeyTerm code - that keyword should not be followed by a letter or digit. In your case &quot;dist(&quot; is a keyword - it is string constant used in grammar rule and it starts with a letter.</p>\r\n<p>This is logical. To fix this, separate opening brace from initial &quot;dist&quot; prefix:</p>\r\n<p>valueDist.Rule = ToTerm(&quot;dist&quot;) + &quot;(&quot; + identifier + &quot;)&quot;;</p>\r\n<p>This additional check is probably the reason why your original grammar stopped working: all single-letter symbols in this huge OR expression are treated by Irony as keywords, so it won't allow them to be followed by a leter.</p>",
    "PostedDate": "2010-01-15T06:33:53.043-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "278304",
    "ThreadId": "80899",
    "Html": "<p>Thanks a lot for that.</p>\r\n<p>One last problem to tackle (I think)... I currently have allow:</p>\r\n<pre>var locRange = new NonTerminal(&quot;locRange&quot;);\r\nvar number = new NumberLiteral(&quot;number&quot;) { DefaultIntTypes = new[] { TypeCode.Int32 } };</pre>\r\n<pre>var alphanumerics = new IdentifierTerminal(&quot;alphanumerics&quot;, String.Empty, &quot;1234567890&quot;);</pre>\r\n<pre>locRange.Rule =&nbsp;alphanumerics + number + &quot;-&quot; + number;</pre>\r\n<p>i.e. many numbers or a letters followed by a number followed by a dash followed by a number, e.g. LEVEL1-5.</p>\r\n<p>What's the best way to accomplish this? I believe it should be a terminal however I'm still feeling a little overwhelmed...should I create a CustomTerminal? Or try to reuse IdentifierTerminal in some way? An example to get me on the right track would be very much appreciated. Thanks again for all your help!</p>",
    "PostedDate": "2010-01-17T18:13:02.533-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "278312",
    "ThreadId": "80899",
    "Html": "<p>I didn't mention it, but there's also a requirement that the 2nd number be greater than the first.</p>\r\n<p>e.g. L1-5 is valid, L2-1 is invalid. I'm having trouble working out where this logic goes. (Should it go in the terminal or do a post-check of the tree?)</p>",
    "PostedDate": "2010-01-17T18:53:45.317-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "278686",
    "ThreadId": "80899",
    "Html": "<p>Ok, looks like you have&nbsp;elements like &quot;L1-5&quot;, and with these, I don't think that defining locRange as a non-terminal would work for you.&nbsp;You need a custom terminal for sure. Just create a class subclassed from Terminal, create appropriate constructor, and then overwrite TryMatch method and implement custom code doing all this parsing and validation. Follow existing terminals implementations as an example.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-18T16:43:35.967-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "278737",
    "ThreadId": "80899",
    "Html": "<p>Thanks for that. I've taken your suggestion and tried to create a subclassed Terminal, but am still having difficulties. I've based mine off RegexBasedTerminal (increasing source.PreviewPosition, and calling source.CreateToken(OutputTerminal) if succesful. Nevertheless, it's still erroring (entering in L1-5 gives the error: Invalid character: 'L'). Any ideas? Sorry it's in VB (the project is actually in VB, I was just writing a prototype in C#).</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Class</span> LocRangeTerminal\r\n    <span style=\"color:Blue\">Inherits</span> Terminal\r\n\r\n    <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Shared</span> _rgxLocRange <span style=\"color:Blue\">As</span> Regex = <span style=\"color:Blue\">New</span> Regex(<span style=\"color:#A31515\">&quot;(?&lt;Prefix&gt;[a-z0-9_].*?)(?&lt;RangeStart&gt;[0-9]+)-(?&lt;RangeEnd&gt;[0-9]+)&quot;</span>, RegexOptions.Compiled <span style=\"color:Blue\">Or</span> RegexOptions.IgnoreCase)\r\n\r\n    <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Sub</span> <span style=\"color:Blue\">New</span>(<span style=\"color:Blue\">ByVal</span> sName <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span>)\r\n        <span style=\"color:Blue\">MyBase</span>.<span style=\"color:Blue\">New</span>(sName)\r\n    <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Sub</span>\r\n\r\n    <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Overrides</span> <span style=\"color:Blue\">Function</span> TryMatch(<span style=\"color:Blue\">ByVal</span> context <span style=\"color:Blue\">As</span> ParsingContext, <span style=\"color:Blue\">ByVal</span> source <span style=\"color:Blue\">As</span> ISourceStream) <span style=\"color:Blue\">As</span> Irony.Parsing.Token\r\n        <span style=\"color:Blue\">Dim</span> match <span style=\"color:Blue\">As</span> Match = _rgxLocRange.Match(source.Text)\r\n\r\n        <span style=\"color:Blue\">If</span> (match.Success) <span style=\"color:Blue\">Then</span>\r\n            <span style=\"color:Blue\">Dim</span> sPrefix = match.Groups(<span style=\"color:#A31515\">&quot;Prefix&quot;</span>).Value\r\n            <span style=\"color:Blue\">Dim</span> iRangeStart = <span style=\"color:Blue\">CInt</span>(match.Groups(<span style=\"color:#A31515\">&quot;RangeStart&quot;</span>).Value)\r\n            <span style=\"color:Blue\">Dim</span> iRangeEnd = <span style=\"color:Blue\">CInt</span>(match.Groups(<span style=\"color:#A31515\">&quot;RangeEnd&quot;</span>).Value)\r\n\r\n            <span style=\"color:Blue\">If</span> (iRangeEnd &lt;= iRangeStart) <span style=\"color:Blue\">Then</span>\r\n                <span style=\"color:Blue\">Return</span> CreateErrorToken(source)\r\n            <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">If</span>\r\n\r\n            <span style=\"color:Blue\">Dim</span> token <span style=\"color:Blue\">As</span> Token = source.CreateToken(OutputTerminal)\r\n            token.Details = <span style=\"color:Blue\">New</span> LocRangeTokenDetails(sPrefix, iRangeStart, iRangeEnd)\r\n            source.PreviewPosition += source.Text.Length\r\n\r\n            <span style=\"color:Blue\">Return</span> token\r\n        <span style=\"color:Blue\">Else</span>\r\n            <span style=\"color:Blue\">Return</span> CreateErrorToken(source)\r\n        <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">If</span>\r\n    <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Function</span>\r\n\r\n    <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Function</span> CreateErrorToken(<span style=\"color:Blue\">ByVal</span> source <span style=\"color:Blue\">As</span> ISourceStream) <span style=\"color:Blue\">As</span> Token\r\n        <span style=\"color:Blue\">Return</span> source.CreateErrorToken(<span style=\"color:#A31515\">&quot;Invalid format. Format for a location range is: Loc(number1)-(number2) where number2 &gt; number1&quot;</span>)\r\n    <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Function</span>\r\n\r\n<span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Class</span>\r\n\r\n<span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Class</span> LocRangeTokenDetails\r\n\r\n    <span style=\"color:Blue\">Private</span> _sPrefix <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span>\r\n    <span style=\"color:Blue\">Private</span> _iRangeStart <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>\r\n    <span style=\"color:Blue\">Private</span> _iRangeEnd <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>\r\n\r\n    <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Sub</span> <span style=\"color:Blue\">New</span>(<span style=\"color:Blue\">ByVal</span> sPrefix <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span>, <span style=\"color:Blue\">ByVal</span> iRangeStart <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>, <span style=\"color:Blue\">ByVal</span> iRangeEnd <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>)\r\n        _sPrefix = <span style=\"color:Blue\">If</span>(sPrefix <span style=\"color:Blue\">Is</span> <span style=\"color:Blue\">Nothing</span>, <span style=\"color:Blue\">String</span>.Empty, sPrefix)\r\n        _iRangeStart = iRangeStart\r\n        _iRangeEnd = iRangeEnd\r\n    <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Sub</span>\r\n\r\n<span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Class</span>\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-18T21:04:57.983-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "278756",
    "ThreadId": "80899",
    "Html": "<p>By the way, `token` is being returned (the regex succeeds &amp; is valid (enough for testing)).</p>",
    "PostedDate": "2010-01-18T21:58:56.123-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "278763",
    "ThreadId": "80899",
    "Html": "<p>One problem I see is this statement:</p>\r\n<p><span style=\"color:blue\">Dim</span> match <span style=\"color:blue\">As</span> Match = _rgxLocRange.Match(source.Text)</p>\r\n<p>The problem is that source.Text is the entire text, so this statement tries to match source text from the beginning. You should instead match starting with current position: Source.Location.Position</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-01-18T22:26:41.06-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "278873",
    "ThreadId": "80899",
    "Html": "<p>Thanks for that -- I realised that that could cause problems pretty much straight after I posted. As I said though, I was giving it valid data which succeeded with the match (literally the text 'L1-5').</p>\r\n<p>Nevertheless, even though a token was created and the preview position was increased, an error token still exists. Any ideas regarding that?</p>",
    "PostedDate": "2010-01-19T03:18:31.917-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "279051",
    "ThreadId": "80899",
    "Html": "<p>Well, just step through in debugger and see what's going on...</p>",
    "PostedDate": "2010-01-19T09:18:03.01-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "279255",
    "ThreadId": "80899",
    "Html": "<p>Ahh, I have been, it's just pretty complex for somebody that doesn't have a great understanding of parsers :)</p>\r\n<p>It looks like 'L1-5' is first consuming 'L1' as alphanumerics, then consuming '-5' which doesn't match any rule. I'll keep investigating.</p>",
    "PostedDate": "2010-01-19T17:39:07.337-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "279766",
    "ThreadId": "80899",
    "Html": "<p>Hi, I just thought I'd let you know I got it all working...</p>\r\n<p>The problem was I was doing source.PreviewPosition += match.Length AFTER I'd created my new token, which didn't work.</p>\r\n<p>I've attached the working code in case somebody has a similar problem. Thanks again for all your help and for creaing and supporting a great tool.</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>        <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Class</span> LocRangeTerminal\r\n            <span style=\"color:Blue\">Inherits</span> Terminal\r\n\r\n            <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Const</span> PrefixGroupIdentifier <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;Prefix&quot;</span>\r\n            <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Const</span> RangeStartGroupIdentifier <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;RangeStart&quot;</span>\r\n            <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Const</span> RangeEndGroupIdentifier <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:#A31515\">&quot;RangeEnd&quot;</span>\r\n\r\n            <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Shared</span> <span style=\"color:Blue\">ReadOnly</span> _sRegex <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span> = <span style=\"color:Blue\">String</span>.Format(<span style=\"color:#A31515\">&quot;\\G((?&lt;{0}&gt;[a-z0-9_]*?)(?&lt;{1}&gt;[0-9]+)-(?&lt;{2}&gt;[0-9]+))&quot;</span>, PrefixGroupIdentifier, RangeStartGroupIdentifier, RangeEndGroupIdentifier)\r\n            <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Shared</span> <span style=\"color:Blue\">ReadOnly</span> _rgxLocRange <span style=\"color:Blue\">As</span> Regex = <span style=\"color:Blue\">New</span> Regex(_sRegex, RegexOptions.IgnoreCase)\r\n\r\n            <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Sub</span> <span style=\"color:Blue\">New</span>(<span style=\"color:Blue\">ByVal</span> name <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span>)\r\n                <span style=\"color:Blue\">MyBase</span>.<span style=\"color:Blue\">New</span>(name)\r\n            <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Sub</span>\r\n\r\n            <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Overloads</span> <span style=\"color:Blue\">Overrides</span> <span style=\"color:Blue\">Function</span> TryMatch(<span style=\"color:Blue\">ByVal</span> context <span style=\"color:Blue\">As</span> ParsingContext, <span style=\"color:Blue\">ByVal</span> source <span style=\"color:Blue\">As</span> ISourceStream) <span style=\"color:Blue\">As</span> Token\r\n                <span style=\"color:Blue\">Dim</span> match <span style=\"color:Blue\">As</span> Match = _rgxLocRange.Match(source.Text, source.PreviewPosition)\r\n\r\n                <span style=\"color:Blue\">If</span> <span style=\"color:Blue\">Not</span> match.Success <span style=\"color:Blue\">OrElse</span> match.Index &lt;&gt; source.PreviewPosition <span style=\"color:Blue\">Then</span>\r\n                    <span style=\"color:Blue\">Return</span> <span style=\"color:Blue\">Nothing</span>\r\n                <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">If</span>\r\n\r\n                <span style=\"color:Blue\">Dim</span> sPrefix = match.Groups(PrefixGroupIdentifier).Value\r\n                <span style=\"color:Blue\">Dim</span> iRangeStart = <span style=\"color:Blue\">CInt</span>(match.Groups(RangeStartGroupIdentifier).Value)\r\n                <span style=\"color:Blue\">Dim</span> iRangeEnd = <span style=\"color:Blue\">CInt</span>(match.Groups(RangeEndGroupIdentifier).Value)\r\n\r\n                <span style=\"color:Blue\">If</span> (iRangeEnd &lt;= iRangeStart) <span style=\"color:Blue\">Then</span>\r\n                    <span style=\"color:Blue\">Return</span> CreateErrorToken(source)\r\n                <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">If</span>\r\n\r\n                source.PreviewPosition += match.Length\r\n\r\n                <span style=\"color:Blue\">Dim</span> token <span style=\"color:Blue\">As</span> Token = source.CreateToken(OutputTerminal)\r\n                token.Details = <span style=\"color:Blue\">New</span> LocRangeTokenDetails(sPrefix, iRangeStart, iRangeEnd)\r\n\r\n                <span style=\"color:Blue\">Return</span> token\r\n            <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Function</span>\r\n\r\n            <span style=\"color:Blue\">Private</span> <span style=\"color:Blue\">Function</span> CreateErrorToken(<span style=\"color:Blue\">ByVal</span> source <span style=\"color:Blue\">As</span> ISourceStream) <span style=\"color:Blue\">As</span> Token\r\n                <span style=\"color:Blue\">Return</span> source.CreateErrorToken(<span style=\"color:#A31515\">&quot;Location range format is: Loc(number1)-(number2) where number1 &lt; number2.&quot;</span>)\r\n            <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Function</span>\r\n\r\n            <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Class</span> LocRangeTokenDetails\r\n\r\n                <span style=\"color:Blue\">Private</span> _sPrefix <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span>\r\n                <span style=\"color:Blue\">Private</span> _iRangeStart <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>\r\n                <span style=\"color:Blue\">Private</span> _iRangeEnd <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>\r\n\r\n                <span style=\"color:Blue\">Public</span> <span style=\"color:Blue\">Sub</span> <span style=\"color:Blue\">New</span>(<span style=\"color:Blue\">ByVal</span> sPrefix <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">String</span>, <span style=\"color:Blue\">ByVal</span> iRangeStart <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>, <span style=\"color:Blue\">ByVal</span> iRangeEnd <span style=\"color:Blue\">As</span> <span style=\"color:Blue\">Integer</span>)\r\n                    _sPrefix = <span style=\"color:Blue\">If</span>(sPrefix <span style=\"color:Blue\">Is</span> <span style=\"color:Blue\">Nothing</span>, <span style=\"color:Blue\">String</span>.Empty, sPrefix)\r\n                    _iRangeStart = iRangeStart\r\n                    _iRangeEnd = iRangeEnd\r\n                <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Sub</span>\r\n\r\n            <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Class</span>\r\n\r\n        <span style=\"color:Blue\">End</span> <span style=\"color:Blue\">Class</span></pre>\r\n</div>",
    "PostedDate": "2010-01-20T16:06:15.2-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "280861",
    "ThreadId": "80899",
    "Html": "<p>Well, congratulations! you got it working. The code looks ok to me. My only comment would be is that RegEx are relatively slow, compared to custom code going&nbsp;char-by-char. But if performance is not&nbsp;critical for you then&nbsp;regex&nbsp;work fine, and&nbsp;the code&nbsp;is&nbsp;shorter and simpler.</p>\r\n<p>&nbsp;&nbsp;&nbsp;</p>",
    "PostedDate": "2010-01-23T00:20:03.257-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
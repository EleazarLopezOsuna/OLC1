[
  {
    "Id": "1055124",
    "ThreadId": "446621",
    "Html": "Hello,<br />\n<br />\nI am having an issue where nodes marked as transient are still showing up in the parse tree. In my case, the node getting added this way is 'expression'. They are also getting added to the AST, but as null nodes. There is no AstNodeType set for 'expression.'<br />\n<br />\nInstead of a parse tree like:<br />\n<pre><code>   binaryExpression\n      binaryExpression 2 + 6\n      +\n      numberLiteral 6</code></pre>\n\nI'm getting:<br />\n<pre><code>   binaryExpression\n      expression\n         binaryExpression 2 + 6\n      +\n      numberLiteral 6</code></pre>\n\nSorry to codedump, but I'm not sure what other relevant information I could provide, so here is my grammar:<br />\n<pre><code>// Terminals\nvar blockComment = new CommentTerminal(&quot;DelimitedComment&quot;, &quot;{&quot;, &quot;}&quot;);\nNonGrammarTerminals.Add(blockComment);\nMarkPunctuation(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;);\n\nvar numberLiteral = new NumberLiteral(&quot;numberLiteral&quot;, NumberOptions.AllowSign | NumberOptions.AllowStartEndDot | NumberOptions.AllowUnderscore, typeof(NumberNode))\n{\n    DefaultFloatType = TypeCode.Decimal\n};\n\nvar measurementUnit = new IdentifierTerminal(&quot;measurementUnit&quot;)\n{\n    AllFirstChars = LETTERS,\n    AllChars = LETTERS\n};\n\nvar sensor = new IdentifierTerminal(&quot;sensor&quot;)\n{\n    AllFirstChars = &quot;$&quot;,\n    AllChars = LETTERS + DIGITS\n};\n\nvar SUM = ToTerm(&quot;sum&quot;, &quot;sum&quot;);\nvar MEAN = ToTerm(&quot;mean&quot;, &quot;mean&quot;);\nvar MIN = ToTerm(&quot;min&quot;, &quot;min&quot;);\nvar MAX = ToTerm(&quot;max&quot;, &quot;max&quot;);\n\nvar LPAREN = ToTerm(&quot;(&quot;, &quot;lparen&quot;);\nvar RPAREN = ToTerm(&quot;)&quot;, &quot;rparen&quot;);\nvar COMMA = ToTerm(&quot;,&quot;, &quot;comma&quot;);\n\n// Nonterminals\nvar result = new NonTerminal(&quot;result&quot;, typeof(ResultNode));\n\nvar sensorRead = new NonTerminal(&quot;sensorRead&quot;, typeof(SensorNode));\nvar qualifiedNumber = new NonTerminal(&quot;qualifiedNumber&quot;, typeof(QualifiedNumberNode));\nvar qualifiedPrimaryExpression = new NonTerminal(&quot;qualifiedPrimaryExpression&quot;);\nvar qualifiedExpression = new NonTerminal(&quot;qualifiedExpression&quot;);\nvar qualifiedBinaryExpression = new NonTerminal(&quot;qualifiedBinaryExpression&quot;, typeof(QualifiedBinOpNode));\nvar qualifiedAggregateFunctionApplication = new NonTerminal(&quot;qualifiedAggregateFunctionApplication&quot;, typeof(AggregateFunctionInvocationNode));\n\nvar qualifiedArgument = new NonTerminal(&quot;qualifiedArgument&quot;);\nvar qualifiedArgumentList = new NonTerminal(&quot;qualifiedArgumentList&quot;, typeof(QualifiedArgumentList));\n\nvar primaryExpression = new NonTerminal(&quot;primaryExpression&quot;);\nvar expression = new NonTerminal(&quot;expression&quot;);\nvar binaryExpression = new NonTerminal(&quot;binaryExpression&quot;, typeof(BinOpNode));\n\nvar infix = new NonTerminal(&quot;infix&quot;);\nvar additive = new NonTerminal(&quot;additive&quot;);\nvar multiplicative = new NonTerminal(&quot;multiplicative&quot;);\nvar aggregateFunction = new NonTerminal(&quot;aggregateFunction&quot;);\n#endregion\n\n// Rules\n// Operators\naggregateFunction.Rule = SUM | MEAN | MIN | MAX;\n\nadditive.Rule = ToTerm(&quot;+&quot;) | &quot;-&quot;;\nmultiplicative.Rule = ToTerm(&quot;*&quot;) | &quot;/&quot; | &quot;^&quot;;\n\n// Measurement-qualified\nresult.Rule = Empty;\nresult.Rule |= qualifiedExpression;\n\nsensorRead.Rule = sensor;\n\nqualifiedNumber.Rule = primaryExpression + measurementUnit;\n\nqualifiedPrimaryExpression.Rule = sensorRead;\nqualifiedPrimaryExpression.Rule = qualifiedNumber;\nqualifiedPrimaryExpression.Rule |= LPAREN + qualifiedExpression + RPAREN;\n\nqualifiedBinaryExpression.Rule = qualifiedExpression + additive + qualifiedExpression;\nqualifiedBinaryExpression.Rule |= ImplyPrecedenceHere(25) + primaryExpression + multiplicative + qualifiedExpression;\nqualifiedBinaryExpression.Rule |= ImplyPrecedenceHere(20) + qualifiedExpression + multiplicative + primaryExpression;\n\nqualifiedAggregateFunctionApplication.Rule = aggregateFunction + LPAREN + qualifiedArgumentList + RPAREN;\n\nqualifiedExpression.Rule = qualifiedPrimaryExpression | qualifiedBinaryExpression | qualifiedAggregateFunctionApplication;\n\nqualifiedArgument.Rule = qualifiedExpression;\n\nqualifiedArgumentList.Rule = MakeStarRule(qualifiedArgumentList, COMMA, qualifiedArgument);\n\nprimaryExpression.Rule = numberLiteral;\nprimaryExpression.Rule |= LPAREN + expression + RPAREN;\n\nbinaryExpression.Rule = expression + additive + expression;\nbinaryExpression.Rule |= expression + multiplicative + expression;\n\nexpression.Rule = binaryExpression | primaryExpression;\n\n// Operator Precedence\nRegisterOperators(5, Associativity.Left, &quot;+&quot;, &quot;-&quot;);\nRegisterOperators(10, Associativity.Left, &quot;*&quot;, &quot;/&quot;);\nRegisterOperators(15, Associativity.Right, &quot;^&quot;); // we'll worry about this later.\n\nRoot = result;\n\nMarkTransient(\n    infix,\n    additive,\n    multiplicative,\n    aggregateFunction,\n    qualifiedArgument,\n    primaryExpression,\n    expression,\n    qualifiedPrimaryExpression,\n    qualifiedExpression\n);</code></pre>\n\nMeasurement units are user-configurable and not available at parse time; the idea is that a user could enter &quot;20 Gallons + 10 Liters&quot; and get a reasonable result. I was trying to fix an issue where expressions like &quot;(2 * 6) Gallons&quot; were not parsing; they are now parsing but not in the way that I expect. I'm new to BNF so please excuse any inelegance.<br />\n<br />\nAny help would be greatly appreciated.<br />\n<br />\nThank you,<br />\nChris<br />\n",
    "PostedDate": "2013-06-10T16:03:18.293-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1055218",
    "ThreadId": "446621",
    "Html": "your first version (that I got in initial notification email) had 'ReduceHere()' hint in the Rule for expression, so that was my initial guess that this extra hint might cause this behavior. In the current edited version the hint is gone. Does it still work incorrectly? And I guess it does work for other nonterminals like 'additive' and 'multiplicative'. Can you just look at parsing log and to to see what's going on there? If it does not give a clue, try to stop in debugger in place where the parser analyses this Transient flag and 'pops' the child and uses it instead of parent? Let me know how it goes; if you can't find it, I'll go step by step myself. sorry just swamped with other things currently \r<br />\nRoman<br />\n",
    "PostedDate": "2013-06-11T00:08:40.973-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1055399",
    "ThreadId": "446621",
    "Html": "Hello,<br />\n<br />\nI am still having the general issue with posted version, but that particular expression isn't causing the same issue now, sorry. <code>(1*2+6) Gallons</code> is an expression that is currently resulting in surviving 'expression' nodes. The only transient node that I am having the issue with is 'expression.' Looking through the parse log, I wasn't able to find any case where it was using it instead of the parent, but I could also be reading the log wrong. I'll try to step through it in the debugger soon to see if I can figure anything else out.<br />\n<br />\nThank you for the quick reply!<br />\n<ul>\n<li>Chris</li>\n</ul>\n",
    "PostedDate": "2013-06-11T07:17:42.077-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
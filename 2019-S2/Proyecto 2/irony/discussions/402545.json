[
  {
    "Id": "939073",
    "ThreadId": "402545",
    "Html": "\r\n<p>Hi!</p>\r\n<p>According to the provided examples, ScanTokenAndProvideInfoAboutIt() calls _parser.Scanner.VsReadToken(ref state) to retrieve the next token. Basically, everythings works fine except for token.Location.line. This field seems to be steadily incremented, rather\r\n than containing the actual line number of the token. Eg. for the very first token in the file Location.line==2 the first time, then 192, then 195, 213 etc etc</p>\r\n<p>Doing a quick review of the code, I found method VsSetSource() in Scanner.cs, which is called by IScanner.SetSource(). I guess the problem is that one a Context.Source is available, the line-number for newLoc is incremented every time. But since VsSetSource()is\r\n not called in succession for every line (but rather for lines currently modified), the line-numbers will - except for the very first time - never be correct.</p>\r\n<p>The question is: What to do about it? IScanner.SetSource() does not provide any information about which line is currently processed, it just passes the current line as a string... Any ideas?</p>\r\n<p>Regards,</p>\r\n<p>Max</p>\r\n",
    "PostedDate": "2012-11-09T04:38:57.213-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "939249",
    "ThreadId": "402545",
    "Html": "<p>Honestly, have no idea how to fix this. Did not touch this VS integration interface for some time. It would be great if you investigate and suggest a solution or workaround?</p>\r\n<p>thanks</p>\r\n<p>Roman</p>",
    "PostedDate": "2012-11-09T09:56:22.77-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "939295",
    "ThreadId": "402545",
    "Html": "\r\n<p>Hi again!</p>\r\n<p>I invested a little more time and came up with a solution that does the trick. I don't know if this would be the preferred solution from Microsoft, but I couldn't find another way, and the solution is relatively simple. In the following paragraphs I assume\r\n that whoever reads this is familiar with the basic setup / classes of a Visual Studio Language Package, to keep it simple. If something is not clear (or I made some mistake), feel free to say so and I will try to explain better (or correct).</p>\r\n<p>(1) In the main LanguageService class, override the GetColorizer Method:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> MyLanguageService : LanguageService {\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> Colorizer GetColorizer(IVsTextLines buffer) {\n        <span style=\"color:blue\">return</span> <span style=\"color:blue\">new</span> MyColorizer(<span style=\"color:blue\">this</span>, buffer, GetScanner(buffer));\n    }\n}\n</pre>\r\n</div>\r\n<p>(2) Clearly, we now need to provide a costum colorizer class, so create a new MyColorizer.cs file:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> MyColorizer : Colorizer {\n    <span style=\"color:blue\">public</span> MyColorizer(LanguageService svc, IVsTextLines buffer, IScanner scanner) <br>        : <span style=\"color:blue\">base</span>(svc, buffer, scanner) {\n    }\n\n    <span style=\"color:green\">// we need some way to tell the scanner the correct line, otherwise the location </span>\n    <span style=\"color:green\">// cannot be correctly determined, and thus the scope cannot be determined...</span>\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> TokenInfo[] GetLineInfo(IVsTextLines buffer, <span style=\"color:blue\"><br>                                            int</span> line, <br>                                            IVsTextColorState colorState) {\n        <span style=\"color:blue\">if</span> (Scanner != <span style=\"color:blue\">null</span>) {\n            ((MyLineScanner)Scanner).SetSourceLine(line);\n        }\n        <span style=\"color:blue\">return</span> <span style=\"color:blue\">base</span>.GetLineInfo(buffer, line, colorState);\n    }\n}\n</pre>\r\n</div>\r\n<p>Edit/Note: You must do the same thing with ColorizeLine(...). I'm too lazy to edit the code above :-)</p>\r\n<p>(3) Now comes the part that I don't like very much, because it's kind of a hack, but whatever... We need to insert the SetSourceLine() method into the LineScanner class, and adapt the SetSource() method accordingly</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">class</span> MyLineScanner: IScanner {\n    <span style=\"color:blue\">private</span> <span style=\"color:blue\">int</span> _line;\n    <span style=\"color:blue\">private</span> Parser _parser;\n\n    <span style=\"color:blue\">public</span> MyLineScanner(IVsTextLines buffer) {\n        _buffer = buffer;\n        _parser = <span style=\"color:blue\">new</span> Parser(<span style=\"color:blue\">new</span> MyGrammar());\n        _parser.Context.Mode = ParseMode.VsLineScan;\n    }\n\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> SetSourceLine(<span style=\"color:blue\">int</span> line) {\n        _line = line;\n    }\n\n    <span style=\"color:blue\">void</span> IScanner.SetSource(<span style=\"color:blue\">string</span> source, <span style=\"color:blue\">int</span> offset) {\n        _parser.Scanner.VsSetSource(source, offset, _line);\n    }\n}\n</pre>\r\n</div>\r\n<p>(4) Finally, we need to extend the interface of the VsSetSource() method to take an additional line parameter, in file Scanner.cs</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> Scanner  {\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">void</span> VsSetSource(<span style=\"color:blue\">string</span> text, <span style=\"color:blue\">int</span> offset, <span style=\"color:blue\">int</span> cur_line) {\n        <span style=\"color:blue\">var</span> line = cur_line;<span style=\"color:green\">// Context.Source == null ? 0 : Context.Source.Location.Line;</span>\n        <span style=\"color:blue\">var</span> newLoc = <span style=\"color:blue\">new</span> SourceLocation(offset, line, 0);\n        Context.Source = <span style=\"color:blue\">new</span> SourceStream(text, Context.Language.Grammar.CaseSensitive, Context.TabWidth, newLoc); \n    }\n}\n</pre>\r\n</div>\r\n<p>That's basically it. Until now, this solution works perfectly fine for me. I don't think it has any negative side effects, because usually, the LineScanner doesn't need the Location.Line information anyway (I guess otherwise someone would've reported the\r\n problem earlier), and the Line parameter was definitely NOT correct...</p>\r\n<p>Regards,<br>\r\nMax</p>\r\n",
    "PostedDate": "2012-11-09T11:19:08.757-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "910087",
    "ThreadId": "394880",
    "Html": "\r\n<p>Hi,</p>\r\n<p>I tried to create a grammar for a small JSON-like language. In order to define null/true/false, I thought ConstantTerminal would be the way to go. However, I'm running into problems. First I tried to define the grammar like this:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>    [Language(<span style=\"color:#a31515\">&quot;Problem&quot;</span>, <span style=\"color:#a31515\">&quot;0.1&quot;</span>, <span style=\"color:#a31515\">&quot;Problem Grammar...&quot;</span>)]\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> ProblemGrammar : Grammar\n    {\n        <span style=\"color:blue\">public</span> ProblemGrammar()\n            : <span style=\"color:blue\">base</span>(caseSensitive: <span style=\"color:blue\">true</span>)\n        {\n            <span style=\"color:blue\">var</span> nullConst = <span style=\"color:blue\">new</span> ConstantTerminal(<span style=\"color:#a31515\">&quot;null&quot;</span>, <span style=\"color:blue\">typeof</span>(LiteralValueNode));\n            nullConst.Add(<span style=\"color:#a31515\">&quot;null&quot;</span>, <span style=\"color:blue\">null</span>);\n\n            <span style=\"color:blue\">var</span> numberLit = <span style=\"color:blue\">new</span> NumberLiteral(<span style=\"color:#a31515\">&quot;number&quot;</span>, NumberOptions.None, <span style=\"color:blue\">typeof</span>(LiteralValueNode));\n\n            <span style=\"color:blue\">var</span> type = <span style=\"color:blue\">new</span> IdentifierTerminal(<span style=\"color:#a31515\">&quot;type&quot;</span>, IdOptions.None);\n            <span style=\"color:blue\">var</span> field = <span style=\"color:blue\">new</span> IdentifierTerminal(<span style=\"color:#a31515\">&quot;field&quot;</span>, IdOptions.None);\n\n            <span style=\"color:blue\">var</span> comma = ToTerm(<span style=\"color:#a31515\">&quot;,&quot;</span>);\n            <span style=\"color:blue\">var</span> optComma = comma.Q();\n\n            <span style=\"color:blue\">var</span> map = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;map&quot;</span>);\n            <span style=\"color:blue\">var</span> @<span style=\"color:blue\">object</span> = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;object&quot;</span>);\n\n            <span style=\"color:blue\">var</span> value = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;value&quot;</span>);\n            <span style=\"color:blue\">var</span> valuePair = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;valueList&quot;</span>);\n            <span style=\"color:blue\">var</span> fieldValuePair = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;fieldValuePair&quot;</span>);\n            <span style=\"color:blue\">var</span> valuePairList = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;valuePairList&quot;</span>);\n            <span style=\"color:blue\">var</span> fieldValuePairList = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;valuePairList&quot;</span>);\n            \n            value.Rule = nullConst | numberLit | map | @<span style=\"color:blue\">object</span>;\n            \n            valuePair.Rule = value &#43; ToTerm(<span style=\"color:#a31515\">&quot;:&quot;</span>) &#43; value;\n            fieldValuePair.Rule = field &#43; ToTerm(<span style=\"color:#a31515\">&quot;:&quot;</span>) &#43; value;\n\n            valuePairList.Rule = MakePlusRule(valuePairList, comma, valuePair);\n            fieldValuePairList.Rule = MakePlusRule(fieldValuePairList, comma, fieldValuePair);\n            \n            map.Rule = (ToTerm(<span style=\"color:#a31515\">&quot;{&quot;</span>) &#43; valuePairList &#43; optComma &#43; ToTerm(<span style=\"color:#a31515\">&quot;}&quot;</span>));\n            @<span style=\"color:blue\">object</span>.Rule = type &#43; (ToTerm(<span style=\"color:#a31515\">&quot;{&quot;</span>) &#43; fieldValuePairList &#43; optComma &#43; ToTerm(<span style=\"color:#a31515\">&quot;}&quot;</span>));\n\n            MarkPunctuation(<span style=\"color:#a31515\">&quot;{&quot;</span>, <span style=\"color:#a31515\">&quot;}&quot;</span>);\n\n            <span style=\"color:blue\">base</span>.Root = value;\n        }\n    }\n</pre>\r\n</div>\r\n<p>At first glance, this works well. For example, the following is parsed fine:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:#a31515\">MyObject </span>{\n    <span style=\"color:red\">field0</span>: <span style=\"color:blue\">1,</span>\n    <span style=\"color:red\">field1</span>: <span style=\"color:blue\">2,</span>\n    <span style=\"color:red\">field2</span>: <span style=\"color:blue\">3,</span>\n}</pre>\r\n</div>\r\n<p>However, the null constant does not work as expected:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:#a31515\">MyObject </span>{\n    <span style=\"color:red\">field0</span>: <span style=\"color:blue\">null,</span>\n    <span style=\"color:red\">field1</span>: <span style=\"color:blue\">2,</span>\n    <span style=\"color:red\">field2</span>: <span style=\"color:blue\">3,</span>\n}</pre>\r\n</div>\r\n<p>This reports &quot;SyntaxError, expected: {&quot;. This means &quot;null&quot; is matched as a type identifier rather than a constant.</p>\r\n",
    "PostedDate": "2012-09-08T19:19:59.17-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "910088",
    "ThreadId": "394880",
    "Html": "\r\n<p>In an attempt to fix this, I tried changing the priority of the constant.</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>nullConst.Priority = TerminalPriority.ReservedWords;</pre>\r\n</div>\r\n<p>This allows the previous examples to parse. However, it introduces a new problem. For example, this is no longer valid:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:#a31515\">nullary </span>{\n    <span style=\"color:red\">field0</span>: <span style=\"color:blue\">null,</span>\n    <span style=\"color:red\">field1</span>: <span style=\"color:blue\">2,</span>\n    <span style=\"color:red\">field2</span>: <span style=\"color:blue\">3,</span>\n}\n</pre>\r\n</div>\r\n<p>Now, the parser matches the &quot;null&quot; in &quot;nullary&quot; and decides that it is a constant. Everything after &quot;null&quot; yields &quot;SyntaxError, unexpected input&quot;. However, I would like it to be matched as a type identifier. While this is less of a problem than the first\r\n one, it is still annoying.</p>\r\n<p>So in short, my question is: How should I modify my code in order to match &quot;null&quot; as a constant and &quot;nullary&quot; as a type identifier?</p>\r\n",
    "PostedDate": "2012-09-08T19:32:19.91-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "910171",
    "ThreadId": "394880",
    "Html": "\r\n<p>In order to focus on the issue, I have simplified the grammar:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>    [Language(<span style=\"color:#a31515\">&quot;ProblemGrammar&quot;</span>, <span style=\"color:#a31515\">&quot;0.1&quot;</span>, <span style=\"color:#a31515\">&quot;Problem Grammar...&quot;</span>)]\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> ProblemGrammar : Grammar\n    {\n        <span style=\"color:blue\">public</span> ProblemGrammar()\n            : <span style=\"color:blue\">base</span>(caseSensitive: <span style=\"color:blue\">true</span>)\n        {\n            <span style=\"color:blue\">var</span> nullConst = <span style=\"color:blue\">new</span> ConstantTerminal(<span style=\"color:#a31515\">&quot;null&quot;</span>, <span style=\"color:blue\">typeof</span>(LiteralValueNode));\n            nullConst.Add(<span style=\"color:#a31515\">&quot;null&quot;</span>, <span style=\"color:blue\">null</span>);\n            <span style=\"color:green\">//nullConst.Priority = TerminalPriority.ReservedWords;</span>\n\n            <span style=\"color:blue\">var</span> type = <span style=\"color:blue\">new</span> IdentifierTerminal(<span style=\"color:#a31515\">&quot;type&quot;</span>, IdOptions.None);\n            <span style=\"color:blue\">var</span> field = <span style=\"color:blue\">new</span> IdentifierTerminal(<span style=\"color:#a31515\">&quot;field&quot;</span>, IdOptions.None);\n\n            <span style=\"color:blue\">var</span> comma = ToTerm(<span style=\"color:#a31515\">&quot;,&quot;</span>);\n\n            <span style=\"color:blue\">var</span> value = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;value&quot;</span>);\n            <span style=\"color:blue\">var</span> fieldValuePair = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;fieldValuePair&quot;</span>);\n            <span style=\"color:blue\">var</span> fieldValuePairList = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;fieldValuePairList&quot;</span>);\n            <span style=\"color:blue\">var</span> @<span style=\"color:blue\">object</span> = <span style=\"color:blue\">new</span> NonTerminal(<span style=\"color:#a31515\">&quot;object&quot;</span>);\n\n            value.Rule = nullConst | @<span style=\"color:blue\">object</span>;\n            fieldValuePair.Rule = field &#43; ToTerm(<span style=\"color:#a31515\">&quot;:&quot;</span>) &#43; value;\n            fieldValuePairList.Rule = MakePlusRule(fieldValuePairList, comma, fieldValuePair);\n            @<span style=\"color:blue\">object</span>.Rule = type &#43; <span style=\"color:#a31515\">&quot;{&quot;</span> &#43; fieldValuePairList &#43; <span style=\"color:#a31515\">&quot;}&quot;</span>;\n\n            MarkPunctuation(<span style=\"color:#a31515\">&quot;,&quot;</span>, <span style=\"color:#a31515\">&quot;:&quot;</span>, <span style=\"color:#a31515\">&quot;{&quot;</span>, <span style=\"color:#a31515\">&quot;}&quot;</span>);\n\n            <span style=\"color:blue\">base</span>.Root = value;\n        }\n    }</pre>\r\n</div>\r\n<p>And this is my minimal test case:</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre><span style=\"color:#a31515\">nullary</span>{<span style=\"color:red\">a</span>:<span style=\"color:blue\">null</span>}</pre>\r\n</div>\r\n<p>I would like this to parse as:</p>\r\n<pre>value\n    &#43; object\n        &#43; nullary (type)\n        &#43; fieldValuePairList\n            &#43; fieldValuePair\n                &#43; a (field)\n                &#43; value\n                    &#43; (null)</pre>\r\n<p>Should not be too hard, right?</p>\r\n",
    "PostedDate": "2012-09-09T08:08:48.76-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "911049",
    "ThreadId": "394880",
    "Html": "<p>sorry for late reply. Will get to it in a few days; for now, use the same approach as in Json grammar sample; do not use constantTerminal, just use keywords, and for interpreter define values for these in Globals dictionary. Will investigate the issue soon</p>\r\n<p>Roman</p>",
    "PostedDate": "2012-09-11T09:50:43.083-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "911269",
    "ThreadId": "394880",
    "Html": "<p>I had a look at the&nbsp;Json grammar sample. Using the ToTerm-method does indeed solve the issue. However, I have been scratching my head over why exactly that is. In particular, I cannot explain the following&nbsp;behaviour&nbsp;(but maybe it will help you track down the issue):</p>\r\n<p>Since&nbsp;ConstantTerminal did not work and ToTerm-method did, I assumed that this had something to do with the implementation of ConstantTerminal vs. KeyTerm. However, it turns out that this is not the case. Creating a KeyTerm manually results in the same behaviour as with ConstantTerminal. The desired result seems to depend solely on the presence of the term in the&nbsp;KeyTermTable of the grammar. In other words, this works:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">var</span> nullConst = <span style=\"color: blue;\">new</span> KeyTerm(<span style=\"color: #a31515;\">\"null\"</span>, <span style=\"color: #a31515;\">\"null\"</span>);\r\nKeyTerms[<span style=\"color: #a31515;\">\"null\"</span>] = nullConst;\r\n</pre>\r\n</div>\r\n</p>\r\n<p>But this does not:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre><span style=\"color: blue;\">var</span> nullConst = <span style=\"color: blue;\">new</span> KeyTerm(<span style=\"color: #a31515;\">\"null\"</span>, <span style=\"color: #a31515;\">\"null\"</span>);\r\n<span style=\"color: green;\">//KeyTerms[\"null\"] = nullConst;</span>\r\n</pre>\r\n</div>\r\n</p>",
    "PostedDate": "2012-09-11T20:06:20.86-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "913120",
    "ThreadId": "394880",
    "Html": "<p>I may have been wrong about the&nbsp;KeyTermTable, I'm not sure anymore at this point. Anyway, I managed to do most of what I wanted to. There is only one problem that remains, concerning&nbsp;MakeListRule. My lists can be empty and I would really like to allow trailing delimiters for my lists. However, currently setting both&nbsp;TermListOptions.AllowEmpty and TermListOptions.AllowTrailingDelimiter creates a \"Shift-reduce conflict\". Here is an example:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>    [Language(<span style=\"color: #a31515;\">\"ProblemGrammar2\"</span>, <span style=\"color: #a31515;\">\"0.1\"</span>, <span style=\"color: #a31515;\">\"Problem Grammar...\"</span>)]\r\n    <span style=\"color: blue;\">public</span> <span style=\"color: blue;\">class</span> ProblemGrammar2 : Grammar\r\n    {\r\n        <span style=\"color: blue;\">public</span> ProblemGrammar2()\r\n            : <span style=\"color: blue;\">base</span>(caseSensitive: <span style=\"color: blue;\">true</span>)\r\n        {\r\n            <span style=\"color: blue;\">var</span> delimiter = ToTerm(<span style=\"color: #a31515;\">\",\"</span>);\r\n\r\n            <span style=\"color: blue;\">var</span> number = <span style=\"color: blue;\">new</span> NumberLiteral(<span style=\"color: #a31515;\">\"number\"</span>, NumberOptions.None);\r\n            <span style=\"color: blue;\">var</span> numberList = <span style=\"color: blue;\">new</span> NonTerminal(<span style=\"color: #a31515;\">\"numberList\"</span>);\r\n\r\n            <span style=\"color: blue;\">var</span> listOptions = TermListOptions.AllowEmpty | TermListOptions.AllowTrailingDelimiter;\r\n            numberList.Rule = MakeListRule(numberList, delimiter, number, listOptions);\r\n\r\n            <span style=\"color: blue;\">var</span> list = <span style=\"color: blue;\">new</span> NonTerminal(<span style=\"color: #a31515;\">\"list\"</span>);\r\n            list.Rule = <span style=\"color: #a31515;\">\"[\"</span> + numberList + <span style=\"color: #a31515;\">\"]\"</span>;\r\n\r\n            MarkPunctuation(<span style=\"color: #a31515;\">\",\"</span>, <span style=\"color: #a31515;\">\"[\"</span>, <span style=\"color: #a31515;\">\"]\"</span>);\r\n\r\n            <span style=\"color: blue;\">base</span>.Root = list;\r\n        }\r\n    }\r\n</pre>\r\n</div>\r\n</p>\r\n<p>You'll probably know how to fix this. For now, this seems to work:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>        <span style=\"color: blue;\">protected</span> BnfExpression MakeCustomListRule(NonTerminal list, BnfTerm delimiter, BnfTerm listMember)\r\n        {\r\n            <span style=\"color: blue;\">var</span> emptyListContent = <span style=\"color: blue;\">new</span> NonTerminal(listMember.Name + <span style=\"color: #a31515;\">\"-\"</span>);\r\n            emptyListContent.Rule = Empty;\r\n\r\n            <span style=\"color: blue;\">var</span> fullListContent = <span style=\"color: blue;\">new</span> NonTerminal(listMember.Name + <span style=\"color: #a31515;\">\"+\"</span>);\r\n            fullListContent.Rule = (listMember) | (fullListContent + delimiter + listMember);\r\n\r\n            <span style=\"color: blue;\">var</span> listContent = <span style=\"color: blue;\">new</span> NonTerminal(listMember.Name + <span style=\"color: #a31515;\">\"*\"</span>);\r\n            listContent.Rule = (emptyListContent + delimiter.Q()) | (fullListContent + delimiter.Q());\r\n\r\n            emptyListContent.SetFlag(TermFlags.IsList);\r\n            emptyListContent.SetFlag(TermFlags.NoAstNode);\r\n\r\n            fullListContent.SetFlag(TermFlags.IsList);\r\n            fullListContent.SetFlag(TermFlags.NoAstNode);\r\n\r\n            listContent.SetFlag(TermFlags.IsListContainer);\r\n            listContent.SetFlag(TermFlags.NoAstNode);\r\n\r\n            <span style=\"color: blue;\">return</span> listContent;\r\n        }\r\n</pre>\r\n</div>\r\n</p>",
    "PostedDate": "2012-09-15T13:56:17.197-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "916157",
    "ThreadId": "394880",
    "Html": "\r\n<blockquote style=\"border:solid .1em #ccc; font-style:italic; margin:.25em 1em 0 1em; padding:0 .25em 0 .25em\">\r\n<strong>kloffy wrote:</strong><br>\r\n<p>There is only one problem that remains, concerning&nbsp;MakeListRule. My lists can be empty and I would really like to allow trailing delimiters for my lists. However, currently setting both&nbsp;TermListOptions.AllowEmpty and TermListOptions.AllowTrailingDelimiter\r\n creates a &quot;Shift-reduce conflict&quot;.&nbsp;</p>\r\n</blockquote>\r\n<p>No response to this? Is my observation correct or am I doing things wrong? Will this be supported/fixed? Is the work-around that I proposed a good idea?</p>\r\n",
    "PostedDate": "2012-09-22T13:42:14.763-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "916175",
    "ThreadId": "394880",
    "Html": "<p>It is unnecessary to eliminate all shift-reduce and reduce-reduce conflicts; doing so needlessly bloats the grammar. The <em><strong>PreferShiftHere()</strong></em> and <strong><em>ReduceHere()</em></strong> functions exist to resolve the conflicts appropriately while remaining efficient.</p>",
    "PostedDate": "2012-09-22T15:22:14.613-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "916188",
    "ThreadId": "394880",
    "Html": "\r\n<p>Ok, but the example grammar that I posted does not work. (Even if I add&nbsp;TermListOptions.AddPreferShiftHint.)</p>\r\n<p>For example, the following list:</p>\r\n<pre>[1,]</pre>\r\n<p>Yields a &quot;Syntax error, expected: number&quot;.&nbsp;The only way I can get it to work is using my custom make list rule method.</p>\r\n",
    "PostedDate": "2012-09-22T17:32:19.103-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "916205",
    "ThreadId": "394880",
    "Html": "<p>confirmed, it's a flaw in Grammar.MakeListRule. Change it to the following:</p>\r\n<p>\r\n<div style=\"color: black; background-color: white;\">\r\n<pre>    <span style=\"color: blue;\">protected</span> BnfExpression MakeListRule(NonTerminal list, BnfTerm delimiter, BnfTerm listMember, TermListOptions options = TermListOptions.PlusList) {\r\n      <span style=\"color: green;\">//If it is a star-list (allows empty), then we first build plus-list</span>\r\n      <span style=\"color: blue;\">var</span> isPlusList = !options.IsSet(TermListOptions.AllowEmpty);\r\n      <span style=\"color: blue;\">var</span> allowTrailingDelim = options.IsSet(TermListOptions.AllowTrailingDelimiter) &amp; delimiter != <span style=\"color: blue;\">null</span>;\r\n      NonTerminal plusList = isPlusList ? list : <span style=\"color: blue;\">new</span> NonTerminal(listMember.Name + <span style=\"color: #a31515;\">\"+\"</span>);\r\n      <span style=\"color: green;\">//\"list\" is the real list for which we will construct expression - it is either extra plus-list or original listNonTerminal. </span>\r\n      <span style=\"color: green;\">// In the latter case we will use it later to construct expression for listNonTerminal</span>\r\n      plusList.SetFlag(TermFlags.IsList);\r\n      plusList.Rule = plusList;  <span style=\"color: green;\">// rule =&gt; list</span>\r\n      <span style=\"color: blue;\">if</span> (delimiter != <span style=\"color: blue;\">null</span>)\r\n        plusList.Rule += delimiter;  <span style=\"color: green;\">// rule =&gt; list + delim</span>\r\n      <span style=\"color: blue;\">if</span> (options.IsSet(TermListOptions.AddPreferShiftHint))\r\n        plusList.Rule += PreferShiftHere(); <span style=\"color: green;\">// rule =&gt; list + delim + PreferShiftHere()</span>\r\n      plusList.Rule += listMember;          <span style=\"color: green;\">// rule =&gt; list + delim + PreferShiftHere() + elem</span>\r\n      plusList.Rule |= listMember;        <span style=\"color: green;\">// rule =&gt; list + delim + PreferShiftHere() + elem | elem</span>\r\n      <span style=\"color: blue;\">if</span> (isPlusList) {\r\n        <span style=\"color: green;\">// if we build plus list - we're almost done; plusList == list</span>\r\n        <span style=\"color: green;\">// add trailing delimiter if necessary; for star list we'll add it to final expression</span>\r\n        <span style=\"color: blue;\">if</span> (allowTrailingDelim)\r\n          plusList.Rule |= list + delimiter; <span style=\"color: green;\">// rule =&gt; list + delim + PreferShiftHere() + elem | elem | list + delim</span>\r\n      } <span style=\"color: blue;\">else</span> {\r\n        <span style=\"color: green;\">// Setup list.Rule using plus-list we just created</span>\r\n        list.Rule = Empty | plusList;\r\n        <span style=\"color: blue;\">if</span> (allowTrailingDelim)\r\n          list.Rule |= plusList + delimiter | delimiter;\r\n        plusList.SetFlag(TermFlags.NoAstNode);\r\n        list.SetFlag(TermFlags.IsListContainer); <span style=\"color: green;\">//indicates that real list is one level lower</span>\r\n      } \r\n      <span style=\"color: blue;\">return</span> list.Rule; \r\n    }<span style=\"color: green;\">//method</span>\r\n\r\n</pre>\r\n</div>\r\n</p>\r\n<p>That should work now. I will push the update soon. Sorry, but never thought of this scenario (star list with allow trailing delim)</p>\r\n<p>Roman</p>",
    "PostedDate": "2012-09-22T21:05:09.753-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "916208",
    "ThreadId": "394880",
    "Html": "\r\n<p>about your original problem with constants. First, the original idea was to use it for &quot;special looking&quot; constants. The comment on top in ConstantTerminal says:</p>\r\n<pre>&nbsp;<span>//This&nbsp;terminal&nbsp;allows&nbsp;to&nbsp;declare&nbsp;a&nbsp;set&nbsp;of&nbsp;constants&nbsp;in&nbsp;the&nbsp;input&nbsp;language</span>\n&nbsp;&nbsp;<span>//&nbsp;It&nbsp;should&nbsp;be&nbsp;used&nbsp;when&nbsp;constant&nbsp;symbols&nbsp;do&nbsp;not&nbsp;look&nbsp;like&nbsp;normal&nbsp;identifiers;&nbsp;e.g.&nbsp;in&nbsp;Scheme,&nbsp;#t,&nbsp;#f&nbsp;are&nbsp;true/false</span>\n&nbsp;&nbsp;<span>//&nbsp;constants,&nbsp;and&nbsp;they&nbsp;don't&nbsp;fit&nbsp;into&nbsp;Scheme&nbsp;identifier&nbsp;pattern.</span>\n</pre>\r\n<p>But I see the problem, the terminal should work even if accidentally used in cases like yours. Here's the fix. Add the following line at the end of constructor of ConstantTerminal:&nbsp;</p>\r\n<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>this</span>.Priority&nbsp;=&nbsp;<span>TerminalPriority</span>.High;&nbsp;<span>//constants&nbsp;have&nbsp;priority&nbsp;over&nbsp;normal&nbsp;identifiers</span>\n</pre>\r\n<p>And change TryMatch implementation to:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black; background-color:white\">\r\n<pre>    <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> Token TryMatch(ParsingContext context, ISourceStream source) {\n      <span style=\"color:blue\">string</span> text = source.Text;\n      <span style=\"color:blue\">foreach</span> (<span style=\"color:blue\">var</span> entry <span style=\"color:blue\">in</span> Constants) {\n        source.PreviewPosition = source.Position;\n        <span style=\"color:blue\">var</span> constant = entry.Key;\n        <span style=\"color:blue\">if</span> (source.PreviewPosition &#43; constant.Length &gt; text.Length) <span style=\"color:blue\">continue</span>;\n        <span style=\"color:blue\">if</span> (source.MatchSymbol(constant)) {\n          source.PreviewPosition &#43;= constant.Length;\n          <span style=\"color:blue\">if</span> (!<span style=\"color:blue\">this</span>.Grammar.IsWhitespaceOrDelimiter(source.PreviewChar))\n            <span style=\"color:blue\">continue</span>; <span style=\"color:green\">//make sure it is delimiter</span>\n          <span style=\"color:blue\">return</span> source.CreateToken(<span style=\"color:blue\">this</span>.OutputTerminal, entry.Value);\n        }\n      }\n      <span style=\"color:blue\">return</span> <span style=\"color:blue\">null</span>;\n    }\n\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Basically I added check that the constant is followed by delimiter or whitespace. That should work now. Thanks for finding this</p>\r\n<p>Roman</p>\r\n",
    "PostedDate": "2012-09-22T21:51:16.72-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "919373",
    "ThreadId": "394880",
    "Html": "<p>Thank you for fixing this issue. It works perfectly now!</p>",
    "PostedDate": "2012-09-29T06:02:03.713-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
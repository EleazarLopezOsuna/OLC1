[
  {
    "Id": "1320271",
    "ThreadId": "571582",
    "Html": "Below is my grammar.  If I give it, what I would call  an invalid input - &quot;test1:test2:test3&quot;, then it gets into an infinite loop and eats memory like crazy and never returns from the parse method ...  I'd probably want it to error out, or maybe return &quot;test1:test2&quot; as a ModifierName and &quot;test3&quot; as the ModifierValue ...  Any Ideas on how I would accomplish this?<br />\n<pre><code>   class SearchGrammar: Grammar\n    {\n        public SearchGrammar(): base(false)\n        {\n            // Terminals\n            var Term = new IdentifierTerminal(&quot;Term&quot;, @&quot;!@#$%^*_'.?-\\/&quot;, @&quot;!@#$%^*_\\/'.?0123456789&quot;);\n            Term.CharCategories.AddRange(new UnicodeCategory[] {\n                UnicodeCategory.UppercaseLetter, //Ul\n                UnicodeCategory.LowercaseLetter, //Ll\n                UnicodeCategory.TitlecaseLetter, //Lt\n                UnicodeCategory.ModifierLetter,  //Lm\n                UnicodeCategory.OtherLetter,     //Lo\n                UnicodeCategory.LetterNumber,     //Nl\n                UnicodeCategory.DecimalDigitNumber, //Nd\n                UnicodeCategory.ConnectorPunctuation, //Pc\n                UnicodeCategory.SpacingCombiningMark, //Mc\n                UnicodeCategory.NonSpacingMark,       //Mn\n                UnicodeCategory.Format                //Cf\n            });\n            //StartCharCategories are the same\n            Term.StartCharCategories.AddRange(Term.CharCategories); \n\n\n            var Phrase = new StringLiteral(&quot;Phrase&quot;, &quot;\\&quot;&quot;);\n            var ImpliedAnd = new ImpliedSymbolTerminal(&quot;ImpliedAnd&quot;);\n\n            // Non-Terminals\n            var BinaryExpression = new NonTerminal(&quot;BinaryExpression&quot;);\n            var BinaryOp = new NonTerminal(&quot;BinaryOp&quot;);\n            var NotExpression = new NonTerminal(&quot;NotExpression&quot;);\n            var NotOp = new NonTerminal(&quot;NotOp&quot;);\n            var Expression = new NonTerminal(&quot;Expression&quot;);\n            var PrimaryExpression = new NonTerminal(&quot;PrimaryExpression&quot;);\n            var ParenthesizedExpression = new NonTerminal(&quot;ParenthesizedExpression&quot;);\n            var ModifierExpression = new NonTerminal(&quot;ModifierExpression&quot;);\n            var SearchExpression = new NonTerminal(&quot;SearchExpression&quot;);\n\n            var ModifierName = new NonTerminal(&quot;ModifierName&quot;);\n            var ModifierValue = new NonTerminal(&quot;ModifierValue&quot;);\n           \n            this.Root = Expression;\n\n            Expression.Rule = Empty | PrimaryExpression | BinaryExpression | NotExpression;\n            \n            BinaryExpression.Rule = Expression + BinaryOp + Expression;\n            \n            BinaryOp.Rule = ImpliedAnd | &quot;and&quot; | &quot;&amp;&quot; | &quot;or&quot; | &quot;|&quot;;\n\n            NotExpression.Rule = NotOp + Expression;\n\n            NotOp.Rule = ToTerm(&quot;-&quot;) | &quot;not&quot;;\n\n            PrimaryExpression.Rule = SearchExpression\n                                    | ParenthesizedExpression\n                                    | ModifierExpression;\n\n            SearchExpression.Rule = Term | Phrase;\n\n            ParenthesizedExpression.Rule = &quot;(&quot; + Expression + &quot;)&quot;;\n\n            ModifierExpression.Rule = ModifierName + &quot;:&quot; + ModifierValue;\n            ModifierName.Rule = Term | Phrase;\n            ModifierValue.Rule = Term | Phrase;\n\n            MarkTransient(PrimaryExpression, ModifierName, ModifierValue, Expression, BinaryOp, NotOp);\n            MarkPunctuation(&quot;(&quot;, &quot;)&quot;, &quot;:&quot;);\n            RegisterOperators(10, &quot;or&quot;, &quot;|&quot;);\n            RegisterOperators(20, &quot;and&quot;, &quot;&amp;&quot;);\n            RegisterOperators(20, ImpliedAnd);\n            RegisterOperators(30, &quot;-&quot;, &quot;not&quot;);\n            RegisterBracePair(&quot;(&quot;, &quot;)&quot;);\n\n            AddToNoReportGroup(ImpliedAnd);\n            AddToNoReportGroup(&quot;(&quot;, &quot;)&quot;);\n        }\n    }</code></pre>\n\n",
    "PostedDate": "2014-11-08T07:57:07.26-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1321416",
    "ThreadId": "571582",
    "Html": "your trouble is a combination of ImpliedSymbol (ImpliedAnd) and the fact that empty string can be interpreted as an expression. \r<br />\nSo parser when seeing a simple term &quot;Term&quot; starts thinking that this is in fact:\r<br />\nIdent ImpliedAnd EmptyExpr\r<br />\n<br />\nwhich results in reduce to BinaryExpression then Expression, and then cycle starts again: \r<br />\nExpr -&gt; Expr ImpliedAnd EmptyExpr\r<br />\n<br />\nRemove Empty from Expression.Rule, and then everything starts working. Anyway I think it is wrong arrangement to have\r<br />\n<br />\n<br />\nAs for catching this infinite loop, it probably might be caught, but it's a bit tricky, it is not detectable in parser automaton (like conflicts), only at runtime while actually parsing, the parser should notice that it does not move forward while repeating the same state. I'll think about smth like this in the new version\r<br />\nRoman<br />\n",
    "PostedDate": "2014-11-12T12:26:10.577-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "416930",
    "ThreadId": "204640",
    "Html": "<p>Hello.</p>\r\n<p>Is it possible to imlement include statement? Like replace the statement with a text from external file while parsing.</p>\r\n<p>And if possible, than how?</p>",
    "PostedDate": "2010-03-11T05:40:12.27-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "417627",
    "ThreadId": "204640",
    "Html": "<p>The semantics of &quot;include&quot; might vary. One case (Python) it is a reference to external module that is executed at runtime - the module is parsed once and added to references of the current module. Implementation of this semantics is part of interpreter (with dedicated AST node), and will be part of interpreter implementation in some near future.&nbsp;</p>\r\n<p>The case you're probably talking about - including file as plain text at parse time. Not sure it is easy in current version, if possible at all. Are you sure you need this semantics, rather than referencing the external module? What is the language?</p>\r\n<p>Roman</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-03-12T13:19:57.82-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "417649",
    "ThreadId": "204640",
    "Html": "<p>The second case.</p>\r\n<p>Language is BSDL, it is subset of VHDL. External package must be included in BSDL file as plain text and parsed all together. I am new to parsers and trying to port original BSDL grammar, see&nbsp;<span style=\"font-family:Consolas, 'Courier New', Courier, monospace;white-space:pre-wrap\">Standard_Use production here <span style=\"font-family:'Segoe UI', 'Microsoft Sans Serif', Arial, Geneva, sans-serif;white-space:normal\"><a href=\"http://www.vhdl.org/vug_bbs/bsdl.parser\">http://www.vhdl.org/vug_bbs/bsdl.parser</a>&nbsp;.</span></span></p>",
    "PostedDate": "2010-03-12T14:25:45.403-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "418074",
    "ThreadId": "204640",
    "Html": "<p>I don't have a bullet-proof solution, but I think you can implement this with custom token filter. You just catch &quot;include&quot; statement, then create a separate scanner, scan the external file and feed the tokens into the primary stream. See if you can make it work. I will get back to &quot;include&quot; implementations in some future and have a complete story.</p>",
    "PostedDate": "2010-03-14T22:36:49.553-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "419651",
    "ThreadId": "204640",
    "Html": "<p><span style=\"background-color:#ffffff\" title=\"Спасибо за совет.\">Thanks for the advice.<br></span><span style=\"background-color:#ffffff\" title=\"И спасибо вам большое за хороший инструмент.\">And thank you very much for the great tool.</span></p>",
    "PostedDate": "2010-03-18T03:34:12.833-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "451401",
    "ThreadId": "204640",
    "Html": "<p>Has anyone picked this up yet? &nbsp;Here's what I've got so far, but I'm missing something. &nbsp;The pattern for my &quot;include&quot; statements are&nbsp;<strong>include &quot;file path&quot;</strong>.</p>\r\n<ol>\r\n<li>I use a custom token filter to watch for an &quot;include&quot; token</li>\r\n<li>Pick up the file path after it which comes in the form of a string token</li>\r\n<li>Use that to open the file and read it</li>\r\n<li>Pass the text from that file to a new instance of the parser</li>\r\n<li>Return the tokens generated and try to add it to the stack of existing tokens</li>\r\n</ol>\r\n<p>The problem is that a parse error will point to the beginning double quote in &quot;file path&quot;. &nbsp;Is there something I need to do around location? &nbsp;Or is it something else?</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">using</span> System.Collections.Generic;\r\n<span style=\"color:blue\">using</span> System.IO;\r\n\r\n<span style=\"color:blue\">using</span> Irony.Parsing;\r\n\r\n<span style=\"color:blue\">namespace</span> AJG.LanguageService.Parsing.TokenFilters\r\n{\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> IncludeTokenFilter : TokenFilter\r\n    {\r\n        TokenStack outputTokens = <span style=\"color:blue\">new</span> TokenStack();\r\n        <span style=\"color:blue\">bool</span> previousTokenWasInclude;\r\n        <span style=\"color:blue\">bool</span> previousTokenWasIncludeFile;\r\n\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> IEnumerable&lt;Token&gt; BeginFiltering(ParsingContext context, IEnumerable&lt;Token&gt; tokens)\r\n        {\r\n            Reset();\r\n\r\n            <span style=\"color:blue\">foreach</span> (Token token <span style=\"color:blue\">in</span> tokens)\r\n            {\r\n                outputTokens.Push(token);\r\n\r\n                <span style=\"color:blue\">if</span> (token.Text == <span style=\"color:#a31515\">&quot;include&quot;</span>)\r\n                {\r\n                    previousTokenWasInclude = <span style=\"color:blue\">true</span>;\r\n                }\r\n                <span style=\"color:blue\">else</span> <span style=\"color:blue\">if</span> (previousTokenWasInclude)\r\n                {\r\n                    TokenList includeTokens = ProcessIncludeFile(token.ValueString);\r\n\r\n                    <span style=\"color:blue\">foreach</span> (Token t <span style=\"color:blue\">in</span> includeTokens)\r\n                    {\r\n                        outputTokens.Push(t);\r\n                    }\r\n\r\n                    previousTokenWasInclude = <span style=\"color:blue\">false</span>;\r\n                    previousTokenWasIncludeFile = <span style=\"color:blue\">true</span>;\r\n                }\r\n                <span style=\"color:blue\">else</span> <span style=\"color:blue\">if</span> (previousTokenWasIncludeFile)\r\n                {\r\n                    previousTokenWasIncludeFile = <span style=\"color:blue\">false</span>;\r\n                }\r\n\r\n                <span style=\"color:blue\">while</span> (outputTokens.Count &gt; 0)\r\n                {\r\n                    yield <span style=\"color:blue\">return</span> outputTokens.Pop();\r\n                }\r\n            }\r\n        }\r\n\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> OnSetSourceLocation(SourceLocation location)\r\n        {\r\n            <span style=\"color:blue\">base</span>.OnSetSourceLocation(location);\r\n        }\r\n\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> Reset()\r\n        {\r\n            <span style=\"color:blue\">base</span>.Reset();\r\n\r\n            outputTokens.Clear();\r\n        }\r\n\r\n        <span style=\"color:blue\">private</span> TokenList ProcessIncludeFile(<span style=\"color:blue\">string</span> file)\r\n        {\r\n            <span style=\"color:blue\">try</span>\r\n            {\r\n                StreamReader sr = <span style=\"color:blue\">new</span> StreamReader(file);\r\n\r\n                <span style=\"color:blue\">string</span> source = sr.ReadToEnd();\r\n\r\n                sr.Close();\r\n\r\n                Parser parser = <span style=\"color:blue\">new</span> Parser(<span style=\"color:blue\">new</span> AJG.LanguageService.Grammar());\r\n\r\n                ParseTree tree = parser.Parse(source);\r\n\r\n                <span style=\"color:green\">//remove EOF token before returning</span>\r\n                tree.Tokens.RemoveAt(tree.Tokens.Count - 1);\r\n\r\n                <span style=\"color:blue\">return</span> tree.Tokens;\r\n            }\r\n            <span style=\"color:blue\">catch</span>\r\n            {\r\n                <span style=\"color:green\">//return new instance to avoid defensive coding above for now...really need to return an error token</span>\r\n                <span style=\"color:blue\">return</span> <span style=\"color:blue\">new</span> TokenList();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-06-03T14:01:11.74-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "451792",
    "ThreadId": "204640",
    "Html": "<p>Answered my own question here. &nbsp;I messed around a little more with it and the following seems to work. &nbsp;Two major differences: 1) I wasn't putting the new tokens onto the stack properly and 2) I now re-use the existing grammar instead of creating a new instance (I'm not sure how that makes a difference but it does).</p>\r\n<p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">using</span> System.Collections.Generic;\r\n<span style=\"color:blue\">using</span> System.IO;\r\n\r\n<span style=\"color:blue\">using</span> Irony.Parsing;\r\n\r\n<span style=\"color:blue\">namespace</span> AJG.LanguageService.Parsing.TokenFilters\r\n{\r\n    <span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> IncludeTokenFilter : TokenFilter\r\n    {\r\n        TokenStack outputTokens = <span style=\"color:blue\">new</span> TokenStack();\r\n        <span style=\"color:blue\">bool</span> previousTokenWasInclude;\r\n\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> IEnumerable&lt;Token&gt; BeginFiltering(ParsingContext context, IEnumerable&lt;Token&gt; tokens)\r\n        {\r\n            Reset();\r\n\r\n            <span style=\"color:blue\">foreach</span> (Token token <span style=\"color:blue\">in</span> tokens)\r\n            {\r\n                <span style=\"color:blue\">if</span> (token.Text == <span style=\"color:#a31515\">&quot;include&quot;</span>)\r\n                {\r\n                    previousTokenWasInclude = <span style=\"color:blue\">true</span>;\r\n                }\r\n                <span style=\"color:blue\">else</span> <span style=\"color:blue\">if</span> (previousTokenWasInclude)\r\n                {\r\n                    TokenList includeTokens = ProcessIncludeFile(context, token.ValueString);\r\n\r\n                    <span style=\"color:blue\">for</span> (<span style=\"color:blue\">int</span> i = includeTokens.Count - 1; i &gt;= 0; i--)\r\n                    {\r\n                        outputTokens.Push(includeTokens[i]);\r\n                    }\r\n                    \r\n                    previousTokenWasInclude = <span style=\"color:blue\">false</span>;\r\n                }\r\n\r\n                outputTokens.Push(token);\r\n\r\n                <span style=\"color:blue\">while</span> (outputTokens.Count &gt; 0)\r\n                {\r\n                    yield <span style=\"color:blue\">return</span> outputTokens.Pop();\r\n                }\r\n            }\r\n        }\r\n\r\n        <span style=\"color:blue\">protected</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> OnSetSourceLocation(SourceLocation location)\r\n        {\r\n            <span style=\"color:blue\">base</span>.OnSetSourceLocation(location);\r\n        }\r\n\r\n        <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> Reset()\r\n        {\r\n            <span style=\"color:blue\">base</span>.Reset();\r\n\r\n            outputTokens.Clear();\r\n        }\r\n\r\n        <span style=\"color:blue\">private</span> TokenList ProcessIncludeFile(ParsingContext context, <span style=\"color:blue\">string</span> file)\r\n        {\r\n            <span style=\"color:blue\">try</span>\r\n            {\r\n                StreamReader sr = <span style=\"color:blue\">new</span> StreamReader(file);\r\n\r\n                <span style=\"color:blue\">string</span> source = sr.ReadToEnd();\r\n\r\n                sr.Close();\r\n                sr.Dispose();\r\n\r\n                Parser parser = <span style=\"color:blue\">new</span> Parser(context.Language.Grammar);\r\n\r\n                ParseTree tree = parser.Parse(source);\r\n\r\n                <span style=\"color:green\">//remove EOF token before returning</span>\r\n                tree.Tokens.RemoveAt(tree.Tokens.Count - 1);\r\n\r\n                <span style=\"color:blue\">return</span> tree.Tokens;\r\n            }\r\n            <span style=\"color:blue\">catch</span>\r\n            {\r\n                <span style=\"color:green\">//return new instance to avoid defensive coding above</span>\r\n                <span style=\"color:blue\">return</span> <span style=\"color:blue\">new</span> TokenList();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n</pre>\r\n</div>\r\n</p>",
    "PostedDate": "2010-06-04T09:28:40.77-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "451804",
    "ThreadId": "204640",
    "Html": "<p>Hi</p>\r\n<p>I will look at this and see maybe it is possible to create a generic support for include in core Irony - add this special filter with matching support in parser.</p>\r\n<p>thanks</p>\r\n<p>Roman</p>",
    "PostedDate": "2010-06-04T10:03:48.98-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
[
  {
    "Id": "448061",
    "ThreadId": "214033",
    "Html": "<p>Hello.</p>\r\n<p>I need to parse the folowing example:</p>\r\n<p>attribute x = 10 // optional statement - can be removed<br>attribute y = 15 // optional statement - can be removed<br>attribute width = 20 // m<span id=\"result_box\"><span>andatory statement</span></span><br>attribute height = 30 // m<span id=\"result_box\"><span>andatory statement</span></span></p>\r\n<p><span><span>Order of attributes is important and should be (x, y, width, height), but 2 attributes (x, y) are optional. If I comment out the first&nbsp;attribute, I get syntax error &quot;expected: x&quot;. How do I have to modify my grammar to handle this case?</span></span></p>\r\n<p><span><span>Source grammar:</span></span></p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var int_number = new NumberLiteral(&quot;int_number&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var comment = new CommentTerminal(&quot;comment&quot;, &quot;//&quot;, &quot;\\n&quot;, &quot;\\r&quot;);</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.NonGrammarTerminals.Add(comment);</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var ATTRIBUTE = ToTerm(&quot;attribute&quot;);</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var attrX = new NonTerminal(&quot;attr-X&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var attrY = new NonTerminal(&quot;attr-Y&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var attrW = new NonTerminal(&quot;attr-Width&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var attrH = new NonTerminal(&quot;attr-Height&quot;);</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Root = new NonTerminal(&quot;root&quot;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.Root.Rule = attrX + attrY + attrW + attrH;</p>\r\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrX.Rule = Empty | ATTRIBUTE + &quot;x&quot; + &quot;=&quot; + int_number;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrY.Rule = Empty | ATTRIBUTE + &quot;y&quot; + &quot;=&quot; + int_number;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrW.Rule = ATTRIBUTE + &quot;width&quot; + &quot;=&quot; + int_number;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attrH.Rule = ATTRIBUTE + &quot;height&quot; + &quot;=&quot; + int_number;</p>",
    "PostedDate": "2010-05-27T02:12:33.33-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "448251",
    "ThreadId": "214033",
    "Html": "<p>You are obviously missing the statement delimiter (NewLine) from root's formula. By the way, you create root non-terminal twice.</p>\r\n<p>As more general note, I would suggest to analyze these things - which attrs are present, and the order of attributes - in after-parse analysis of the parse tree. So define &quot;root&quot; in grammar as a generic sequence of attributes without specifying particular names or sequence, and then detect irregularities later, by going thru generated tree.&nbsp;</p>",
    "PostedDate": "2010-05-27T09:13:10.65-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "448571",
    "ThreadId": "214033",
    "Html": "<p>Attributes may have different type depending on the name. So I wanted to create concrete AST node type for each one of them and generate strongly typed DOM by traversing that tree.<br>.</p>\r\n<p>A more complete example should be:</p>\r\n<p>//attribute x = 10<br>attribute y = 10<br>attribute width = 10<br>attribute height = 10<br>attribute alignment = top<br>// string value can be complicated, and I would like to use different grammars for parsing it's content, depending on the attribute's&nbsp;name<br>attribute labels = &quot;LABEL_A(bold, italic), LABEL_B(bold), LABEL_C(italic)&quot;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<hr>\r\n<p>So I changed the grammar as you advised:</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var int_number = new NumberLiteral(&quot;int_number&quot;);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var quoted_string = new StringLiteral(&quot;quoted_string&quot;, &quot;\\&quot;&quot;);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var identifier = new IdentifierTerminal(&quot;identifier&quot;);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var comment = new CommentTerminal(&quot;comment&quot;, &quot;//&quot;, &quot;\\n&quot;, &quot;\\r&quot;);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.NonGrammarTerminals.Add(comment);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var ATTRIBUTE = ToTerm(&quot;attribute&quot;);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var attr_list = new NonTerminal(&quot;attr_list&quot;, typeof(AttrListNode));<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var attr = new NonTerminal(&quot;attr&quot;, typeof(AttrNode));<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var value = new NonTerminal(&quot;value&quot;);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;value.Rule = identifier | int_number | quoted_string;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attr.Rule = ATTRIBUTE + identifier + &quot;=&quot; + value;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;attr_list.Rule = MakePlusRule(attr_list, attr);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.Root = attr_list;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.MarkTransient(value);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.LanguageFlags = LanguageFlags.CreateAst;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<hr>\r\n<p>&nbsp;&nbsp; &nbsp;public class AttrListNode : AstNode</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;&nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;public override void Init(ParsingContext context, ParseTreeNode treeNode)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;base.Init(context, treeNode);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;foreach (var item in treeNode.ChildNodes)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var node = (AttrNode)item.AstNode;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.ChildNodes.Add(node);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;}</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<hr>\r\n<p>&nbsp;&nbsp; &nbsp;public class AttrNode : AstNode</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;&nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;public override void Init(ParsingContext context, ParseTreeNode treeNode)<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;base.Init(context, treeNode);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var identNode = treeNode.ChildNodes[1];<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;var valueNode = treeNode.ChildNodes[3];<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.ChildNodes.Add(identNode.AstNode as AstNode);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.ChildNodes.Add(valueNode.AstNode as AstNode);<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.Name = (string)identNode.Token.Value;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.Value = valueNode.Token.Value;<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;public string Name { get; private set; }<br>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;public object Value { get; private set; }<br>&nbsp;&nbsp; &nbsp;}</p>\r\n<p>&nbsp;</p>\r\n<hr>\r\n<p>After-parse analysis of the parse tree should be in AST creation phase? I don't underastand how to implement syntax and semantic errors' system in that case.&nbsp;</p>\r\n<p>Is there any example of after-parse analysis?<br><br></p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-05-28T02:21:47.607-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "450106",
    "ThreadId": "214033",
    "Html": "<p>Syntax errors will be detected by the parser so you shoudn't need to do anything special for it.&nbsp; On the other hand, for semantic errors, you will need to do the post-parse analysis.</p>\r\n<p>You can always just traverse the parse&nbsp;tree (pre-order works well) and do your checking there.</p>\r\n<p>For example, for the attribute list, you could verify things like: (I don't know if your specifications require these -- they are just examples)<br>1) The identifiers of the child nodes are all different</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">foreach</span>(<span style=\"color:blue\">var</span> attributeNode <span style=\"color:blue\">in</span> curNode.ChildNodes)\r\n{\r\n  <span style=\"color:green\">// Verify attributeNode.ChildNodes[1].FindTokenAndGetText() is unique</span>\r\n}\r\n</pre>\r\n</div>\r\n<p>2) &quot;Mandatory&quot; attributes are present<br><br>3) The child node's identifier belongs to a certain list of valid identifiers<br>You could also handle this case by defining a NonTerminal in the grammar with the list of all possible valid identifiers (instead of using an IdentiferTerminal).&nbsp; Another solution could be to verify (or ignore completely!) that it is a valid identifier when you actually read the data into the object.</p>\r\n<p>As for the role of the AST, it's mainly used to evaluate the input.&nbsp; If you want to evaluate your input (e.g., you want to create some object and initialize it's &quot;attribute&quot;s to the values provided), then I would suggest doing the post-parsing checks during AST creation (the calls to AstNode::Init()).&nbsp; I suspect that this is the case.</p>\r\n<p>For example:</p>\r\n<div style=\"color:black;background-color:white\">\r\n<pre><span style=\"color:blue\">public</span> <span style=\"color:blue\">class</span> AttrListNode : AstNode\r\n{\r\n  <span style=\"color:blue\">public</span> <span style=\"color:blue\">override</span> <span style=\"color:blue\">void</span> Init(ParsingContext context, ParseTreeNode treeNode)\r\n  {\r\n    <span style=\"color:blue\">base</span>.Init(context, treeNode);\r\n\r\n    HashSet&lt;<span style=\"color:blue\">string</span>&gt; identifiers = <span style=\"color:blue\">new</span> HashSet&lt;<span style=\"color:blue\">string</span>&gt;();\r\n    <span style=\"color:blue\">foreach</span>(<span style=\"color:blue\">var</span> childNode <span style=\"color:blue\">in</span> treeNode.ChildNodes)\r\n    {\r\n      <span style=\"color:blue\">bool</span> isUnique = identifiers.Add(childNode.FindTokenAndGetText());\r\n      <span style=\"color:blue\">if</span> (!isUnique)\r\n      {\r\n        <span style=\"color:blue\">throw</span> <span style=\"color:blue\">new</span> Exception(<span style=\"color:#a31515\">&quot;Identical attributes are not allowed!&quot;</span>);\r\n      }\r\n      AddChild(<span style=\"color:#a31515\">&quot;Attr&quot;</span>, childNode);\r\n    }\r\n  }\r\n}</pre>\r\n</div>\r\n<p>Brian</p>",
    "PostedDate": "2010-06-01T08:25:14.42-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
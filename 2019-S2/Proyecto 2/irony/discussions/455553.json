[
  {
    "Id": "1088548",
    "ThreadId": "455553",
    "Html": "I am trying to write a grammar to parse a statement like<br />\n<pre><code>b.a := 7;</code></pre>\n\nMy grammar is as shown below<br />\n<pre><code>    public class STGrammar : InterpretedLanguageGrammar\n    {\n        public STGrammar() : base(caseSensitive: false)\n        {\n            LanguageFlags = LanguageFlags.CreateAst;\n\n            # region Terminals\n            Terminal n = new NumberLiteral(&quot;number&quot;);\n            Terminal v = new IdentifierTerminal(&quot;variable&quot;);\n            KeyTerm assignment = ToTerm(&quot;:=&quot;);\n            KeyTerm left_paren = ToTerm(&quot;(&quot;);\n            KeyTerm right_paren = ToTerm(&quot;)&quot;);\n            KeyTerm terminate = ToTerm(&quot;;&quot;);\n            KeyTerm left_sq = ToTerm(&quot;[&quot;);\n            KeyTerm right_sq = ToTerm(&quot;]&quot;);\n            KeyTerm dot = ToTerm(&quot;.&quot;);\n            #endregion Terminals\n\n            #region Nonterminals\n            NonTerminal actionBlock = new NonTerminal(&quot;actionBlock&quot;, typeof(ActionBlock));\n            NonTerminal assignmentExpr = new NonTerminal(&quot;assignmentExpr&quot;, typeof(AssignmentStNode));\n            NonTerminal arrayOrStruct = new NonTerminal(&quot;arrayOrStruct&quot;, typeof(ArrayNode));\n            NonTerminal arrayOrStructRHS = new NonTerminal(&quot;arrayOrStructRHS&quot;, typeof(AstNode));\n            NonTerminal arrayOrStructRHSs = new NonTerminal(&quot;arrayOrStructRHSs&quot;);\n            NonTerminal comparatorExp = new NonTerminal(&quot;comparatorExpression&quot;, typeof(ExpressionNode));\n            #endregion Nonterminals\n\n            #region BNFRules\n            actionBlock.Rule =\n                assignmentExpr + terminate\n                | arrayOrStruct + terminate\n                ;\n            assignmentExpr.Rule =\n                v + assignment + v\n                | v + assignment + n\n                | arrayOrStruct + assignment + v\n                | v + assignment + arrayOrStruct\n                | arrayOrStruct + assignment + arrayOrStruct\n                | arrayOrStruct + assignment + n\n                ;\n            arrayOrStruct.Rule =\n                v + arrayOrStructRHSs\n                ;\n            arrayOrStructRHS.Rule = \n                &quot;.&quot; + v \n                | &quot;[&quot; + v + &quot;]&quot;\n                ;\n            arrayOrStructRHSs.Rule =\n                MakePlusRule(arrayOrStructRHSs, arrayOrStructRHS)\n                ;\n\n            this.Root = actionBlock;\n            \n            #endregion BNFRules\n\n            MarkPunctuation(&quot;,&quot;, &quot;;&quot;, &quot;[&quot;, &quot;]&quot;, &quot;)&quot;, &quot;(&quot;, &quot;..&quot;, &quot;.&quot;);\n            RegisterBracePair(&quot;(&quot;, &quot;)&quot;);\n        }\n</code></pre>\n\nIt works fine when I am trying to parse <br />\n<pre><code>b := 7;</code></pre>\n\nThe error coming is &quot;Fatal Error in code colorizer. Colorizing had been disabled.&quot;<br />\nThe detailed error is <br />\n<pre><code>System.NullReferenceException was unhandled by user code\n  Message=Object reference not set to an instance of an object.\n  Source=Irony\n  StackTrace:\n       at Irony.Ast.AstBuilder.BuildAst(ParseTreeNode parseNode) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony\\Ast\\AstBuilder.cs:line 97\n       at Irony.Ast.AstBuilder.BuildAst(ParseTreeNode parseNode) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony\\Ast\\AstBuilder.cs:line 86\n       at Irony.Ast.AstBuilder.BuildAst(ParseTreeNode parseNode) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony\\Ast\\AstBuilder.cs:line 86\n       at Irony.Ast.AstBuilder.BuildAst(ParseTreeNode parseNode) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony\\Ast\\AstBuilder.cs:line 86\n       at Irony.Ast.AstBuilder.BuildAst(ParseTree parseTree) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony\\Ast\\AstBuilder.cs:line 38\n       at Irony.Interpreter.InterpretedLanguageGrammar.BuildAst(LanguageData language, ParseTree parseTree) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony.Interpreter\\InterpretedLanguageGrammar.cs:line 60\n       at Irony.Parsing.Parser.Parse(String sourceText, String fileName) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony\\Parsing\\Parser\\Parser.cs:line 88\n       at Irony.GrammarExplorer.fmGrammarExplorer.ParseSample() in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony.GrammarExplorer\\fmGrammarExplorer.cs:line 348\n       at Irony.GrammarExplorer.fmGrammarExplorer.btnParse_Click(Object sender, EventArgs e) in C:\\Sreeja\\downloads\\Irony_2013_03_10\\Irony.GrammarExplorer\\fmGrammarExplorer.cs:line 507\n       at System.Windows.Forms.Control.OnClick(EventArgs e)\n       at System.Windows.Forms.Button.OnClick(EventArgs e)\n       at System.Windows.Forms.Button.OnMouseUp(MouseEventArgs mevent)\n       at System.Windows.Forms.Control.WmMouseUp(Message&amp; m, MouseButtons button, Int32 clicks)\n       at System.Windows.Forms.Control.WndProc(Message&amp; m)\n       at System.Windows.Forms.ButtonBase.WndProc(Message&amp; m)\n       at System.Windows.Forms.Button.WndProc(Message&amp; m)\n       at System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message&amp; m)\n       at System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message&amp; m)\n       at System.Windows.Forms.NativeWindow.Callback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)\n  InnerException: </code></pre>\n\nCan you help me to resolve the error?<br />\nI am using Irony_2013_03_10 version.<br />\n<br />\nSreeja<br />\n",
    "PostedDate": "2013-09-04T19:51:18.167-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1088870",
    "ThreadId": "455553",
    "Html": "Disable colorizing using checkbox on top in GrammarExplorer. Then paste the script line, hit Parse and use debugger to see what happens. Most likely you miss AstNodeType on some non-terminal. Colorizer just tries to do parsing in background, and it gets the same error you'd get when you hit Parse.<br />\n",
    "PostedDate": "2013-09-05T10:45:02.57-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1089088",
    "ThreadId": "455553",
    "Html": "The error being thrown from <br />\n<pre><code>parseNode.AstNode = config.DefaultNodeCreator();</code></pre>\n\nIt parses actionBlock, assignmentExpr, arrayOrStruct, arrayOrStructRHSs, arrayOrStructRHS. Till that it is fine. But I don't get why it is going again with arrayOrStructRHS, which again works fine but throwing exception in arrayOrStructRHSs which comes as the next step. I have only left the non terminal arrayOrStructRHSs which is a MakePlusRule of arrayOrStructRHS. Should I implement ASTNode for this also?<br />\n<br />\nI have just made stub classes for AST nodes, like<br />\n<pre><code>public class ActionBlock : AstNode { }\npublic class AssignmentStNode : AstNode { }\npublic class ArrayNode : AstNode { }\npublic class ArrayRhsNode : AstNode { }\npublic class ExpressionNode : AstNode { }</code></pre>\n\nWill that be a problem?<br />\n<br />\nAnd while working with AST nodes, can you please tell me which all classes should I override apart from Init. What I understood is to override Init if we have to see the AST node. I saw Evaluate and SetEvaluate methods. I couldn't figure out the function of these. Should I implement any other method to make it working or the stub will do?<br />\n<br />\nThanks a lot for spending your valuable time for helping me. I am just a beginner to Irony and parsing as a whole.<br />\n<br />\nEdit :<br />\n<br />\nI implemented just the basic Init method for all the AST nodes to see whether they are working. Now I am getting an exception thrown and also an error in grammar explorer window as follows<br />\n<pre><code>AstNodeType or AstNodeCreator is not set on non-terminals: Irony.Parsing.BnfTermList. Either set Term.AstConfig.NodeType, or provide default values in AstContext.</code></pre>\n\nThe Init method which I implemented is <br />\n<pre><code>public override void Init(AstContext context, ParseTreeNode treeNode)\n{\n    base.Init(context, treeNode);\n}</code></pre>\n\nThe parse tree is now being displayed correctly.<br />\n<br />\nI tried overriding BuildAst() as per the <a href=\"https://irony.codeplex.com/discussions/444049\" rel=\"nofollow\">discussion</a> . But it is not working either.<br />\nThanks,<br />\nSreeja<br />\n",
    "PostedDate": "2013-09-05T22:36:31.93-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1090078",
    "ThreadId": "455553",
    "Html": "yes, you should add Ast node type for arrayOrStructRHSs nonterminal - all nonterminals must have Ast node type, except transient ones. \r<br />\napart from Init - override DoEvaluate, <br />\n",
    "PostedDate": "2013-09-09T01:20:01.073-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1091632",
    "ThreadId": "455553",
    "Html": "I tried the suggestions you gave me and AST is being created. But in grammar explorer, in the parser output window there is an error<br />\n<pre><code>AstNodeType or AstNodeCreator is not set on non-terminals: Irony.Parsing.BnfTermList. Either set Term.AstConfig.NodeType, or provide default values in AstContext.</code></pre>\n\nAlthough the parse tree and AST are coming up normally. I have given Ast node type for all nonterminals except transient ones. In each Ast node, I have overridden Init and Doevaluate. DoEvaluate contain only the stub and Init contains the structure of each node type. Is there anything that I am missing, or should I implement the DoEvaluate to get rid of this error?<br />\n",
    "PostedDate": "2013-09-12T02:37:12.24-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1091808",
    "ThreadId": "455553",
    "Html": "can you pls post your final grammar? might be Irony's bu.. feature... :)<br />\n",
    "PostedDate": "2013-09-12T09:38:50.017-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1092059",
    "ThreadId": "455553",
    "Html": "<pre><code>    public class STGrammar : InterpretedLanguageGrammar\n    {\n        public STGrammar()\n            : base(caseSensitive: false)\n        {\n            LanguageFlags = LanguageFlags.CreateAst;\n\n            # region Terminals\n            Terminal N = new NumberLiteral(&quot;number&quot;);\n            Terminal V = new IdentifierTerminal(&quot;variable&quot;);\n            KeyTerm ASSIGNMENT = ToTerm(&quot;:=&quot;);\n            KeyTerm LEFT_PAREN = ToTerm(&quot;(&quot;);\n            KeyTerm RIGHT_PAREN = ToTerm(&quot;)&quot;);\n            KeyTerm TERMINATE = ToTerm(&quot;;&quot;);\n            KeyTerm LEFT_SQ = ToTerm(&quot;[&quot;);\n            KeyTerm RIGHT_SQ = ToTerm(&quot;]&quot;);\n            KeyTerm DOT = ToTerm(&quot;.&quot;);\n            KeyTerm COMMA = ToTerm(&quot;,&quot;);\n            KeyTerm COLON = ToTerm(&quot;:&quot;);\n            KeyTerm RETURN = ToTerm(&quot;return&quot;);\n            KeyTerm EXIT = ToTerm(&quot;exit&quot;);\n            KeyTerm AND = ToTerm(&quot;and&quot;);\n            KeyTerm OR = ToTerm(&quot;or&quot;);\n            KeyTerm XOR = ToTerm(&quot;xor&quot;);\n            KeyTerm NOT = ToTerm(&quot;not&quot;);\n            KeyTerm FOR = ToTerm(&quot;for&quot;);\n            KeyTerm DO = ToTerm(&quot;do&quot;);\n            KeyTerm END_FOR = ToTerm(&quot;end_for&quot;);\n            KeyTerm BY = ToTerm(&quot;by&quot;);\n            KeyTerm WHILE = ToTerm(&quot;while&quot;);\n            KeyTerm END_WHILE = ToTerm(&quot;end_while&quot;);\n            KeyTerm UNTIL = ToTerm(&quot;until&quot;);\n            KeyTerm REPEAT = ToTerm(&quot;repeat&quot;);\n            KeyTerm END_REPEAT = ToTerm(&quot;end_repeat&quot;);\n            KeyTerm IF = ToTerm(&quot;if&quot;);\n            KeyTerm THEN = ToTerm(&quot;then&quot;);\n            KeyTerm ELSIF = ToTerm(&quot;elsif&quot;);\n            KeyTerm ELSE = ToTerm(&quot;else&quot;);\n            KeyTerm END_IF = ToTerm(&quot;end_if&quot;);\n            KeyTerm TYPE = ToTerm(&quot;type&quot;);\n            KeyTerm END_TYPE = ToTerm(&quot;end_type&quot;);\n            KeyTerm ARRAY = ToTerm(&quot;array&quot;);\n            KeyTerm STRUCT = ToTerm(&quot;struct&quot;);\n            KeyTerm END_STRUCT = ToTerm(&quot;end_struct&quot;);\n            KeyTerm TO = ToTerm(&quot;to&quot;);\n            KeyTerm VAR = ToTerm(&quot;var&quot;);\n            KeyTerm END_VAR = ToTerm(&quot;end_var&quot;);\n            KeyTerm OF = ToTerm(&quot;of&quot;);\n            KeyTerm CASE = ToTerm(&quot;case&quot;);\n            KeyTerm END_CASE = ToTerm(&quot;end_case&quot;);\n            KeyTerm OLD = ToTerm(&quot;old&quot;);\n            KeyTerm NEW = ToTerm(&quot;new&quot;);\n\n            var comment1 = new CommentTerminal(&quot;comment1&quot;, &quot;(*&quot;, &quot;*);&quot;, &quot;*)&quot;);\n            this.NonGrammarTerminals.Add(comment1);\n            var comment2 = new CommentTerminal(&quot;comment2&quot;, &quot;(#&quot;, &quot;#);&quot;, &quot;#)&quot;);\n            this.NonGrammarTerminals.Add(comment2);\n            #endregion Terminals\n\n            #region Nonterminals\n            NonTerminal actionBlock = new NonTerminal(&quot;actionBlock&quot;, typeof(ActionBlock));\n            NonTerminal action = new NonTerminal(&quot;action&quot;, typeof(DummyNode));\n            NonTerminal assignmentExpr = new NonTerminal(&quot;assignment&quot;, typeof(AssignmentStNode));\n            NonTerminal arrayOrStruct = new NonTerminal(&quot;array&quot;, typeof(ArrayNode));\n            NonTerminal arrayOrStructRHS = new NonTerminal(&quot;arrayOrStructRHS&quot;, typeof(ArrayRhsNode));\n            NonTerminal arrayOrStructRHSs = new NonTerminal(&quot;.&quot;, typeof(ArrayRHSsNode));\n            NonTerminal forStmt = new NonTerminal(&quot;for&quot;, typeof(ForNode));\n            NonTerminal range = new NonTerminal(&quot;range&quot;, typeof(RangeNode));\n            NonTerminal identifier = new NonTerminal(&quot;identifier&quot;, typeof(DummyNode));\n            NonTerminal byExpr = new NonTerminal(&quot;by&quot;, typeof(DummyNode));\n            NonTerminal whileStmt = new NonTerminal(&quot;while&quot;, typeof(WhileNode));\n            NonTerminal repeatStmt = new NonTerminal(&quot;repeat&quot;, typeof(WhileNode));\n            NonTerminal ifStmt = new NonTerminal(&quot;if&quot;, typeof(IfStNode));\n            NonTerminal elsIfStmt = new NonTerminal(&quot;elsif&quot;, typeof(ElsifNode));\n            NonTerminal elsIfBlock = new NonTerminal(&quot;elsif&quot;, typeof(DummyNode));\n            NonTerminal elsePart = new NonTerminal(&quot;else&quot;, typeof(ElsifNode));\n            NonTerminal argument = new NonTerminal(&quot;arg&quot;, typeof(ArgNode));\n            NonTerminal returnValue = new NonTerminal(&quot;returnValue&quot;, typeof(ArgNode));\n            NonTerminal arguments = new NonTerminal(&quot;arg&quot;, typeof(ArgNode));\n            NonTerminal functionArgs = new NonTerminal(&quot;functionArgs&quot;, typeof(ArgNode));\n            NonTerminal funCall = new NonTerminal(&quot;function&quot;, typeof(FunctionCallNode));\n            NonTerminal caseStmt = new NonTerminal(&quot;case&quot;, typeof(CaseStmtNode));\n            NonTerminal caseBlock = new NonTerminal(&quot;cases&quot;, typeof(CaseBlockNode));\n            NonTerminal controlFlow = new NonTerminal(&quot;control flow&quot;, typeof(DummyNode));\n            NonTerminal declarationBlock = new NonTerminal(&quot;declare&quot;, typeof(BlockNode));\n            NonTerminal declarationList = new NonTerminal(&quot;declarelist&quot;, typeof(VarListNode));\n            NonTerminal declarationStmt = new NonTerminal(&quot;declareStmt&quot;, typeof(VarStmtNode));\n            NonTerminal acceptList = new NonTerminal(&quot;acceptList&quot;, typeof(DummyNode));\n            NonTerminal dmList = new NonTerminal(&quot;dmList&quot;, typeof(DummyNode));\n            NonTerminal varBlock = new NonTerminal(&quot;variable block&quot;, typeof(BlockNode));\n            NonTerminal varList = new NonTerminal(&quot;varlist&quot;, typeof(VarListNode));\n            NonTerminal varStmt = new NonTerminal(&quot;varStmt&quot;, typeof(VarStmtNode));\n            NonTerminal term = new NonTerminal(&quot;term&quot;);\n            NonTerminal binExpr = new NonTerminal(&quot;binExpr&quot;, typeof(BinaryOperationNode));\n            NonTerminal parExpr = new NonTerminal(&quot;parExpr&quot;);\n            NonTerminal unExpr = new NonTerminal(&quot;unExpr&quot;, typeof(UnaryOperationNode));\n            NonTerminal unOp = new NonTerminal(&quot;unOp&quot;);\n            NonTerminal binOp = new NonTerminal(&quot;binOp&quot;, &quot;operator&quot;);\n            NonTerminal expr = new NonTerminal(&quot;expr&quot;);\n            NonTerminal old_value = new NonTerminal(&quot;old_value&quot;, typeof(DummyNode));\n            NonTerminal new_value = new NonTerminal(&quot;new_value&quot;, typeof(DummyNode));\n            NonTerminal value = new NonTerminal(&quot;value&quot;);\n            NonTerminal elseOpt = new NonTerminal(&quot;elseOpt&quot;, typeof(DummyNode));\n            NonTerminal caseLine = new NonTerminal(&quot;caseline&quot;, typeof(DummyNode));\n            #endregion Nonterminals</code></pre>\n\n",
    "PostedDate": "2013-09-12T19:32:30.35-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1092060",
    "ThreadId": "455553",
    "Html": "<pre><code>            #region BNFRules\n            actionBlock.Rule =\n                MakePlusRule(actionBlock, action);\n            action.Rule =\n                assignmentExpr + TERMINATE\n                | arrayOrStruct + TERMINATE\n                | forStmt + TERMINATE\n                | whileStmt + TERMINATE\n                | repeatStmt + TERMINATE\n                | ifStmt + TERMINATE\n                | funCall + TERMINATE\n                | caseStmt + TERMINATE\n                | controlFlow + TERMINATE\n                | declarationBlock + TERMINATE\n                | varBlock + TERMINATE\n                ;\n            assignmentExpr.Rule =\n                identifier + ASSIGNMENT + expr\n                ;\n            arrayOrStruct.Rule =\n                V + arrayOrStructRHSs\n                ;\n            arrayOrStructRHS.Rule =\n                DOT + V\n                | LEFT_SQ + V + RIGHT_SQ\n                | LEFT_SQ + N + RIGHT_SQ\n                ;\n            arrayOrStructRHSs.Rule =\n                MakePlusRule(arrayOrStructRHSs, arrayOrStructRHS)\n                ;\n            forStmt.Rule =\n                FOR + range + DO + actionBlock + END_FOR\n                ;\n            range.Rule =\n                LEFT_PAREN + identifier + ASSIGNMENT + expr + TO + expr + byExpr + RIGHT_PAREN\n                | identifier + ASSIGNMENT + expr + TO + expr + byExpr\n                ;\n            identifier.Rule =\n                V\n                | arrayOrStruct\n                | old_value\n                | new_value\n                ;\n            byExpr.Rule =\n                BY + expr\n                | Empty\n                ;\n            whileStmt.Rule =\n                WHILE + expr + DO + actionBlock + END_WHILE\n                ;\n            repeatStmt.Rule =\n                REPEAT + actionBlock + UNTIL + expr + END_REPEAT\n                ;\n            ifStmt.Rule =\n                IF + expr + THEN + actionBlock + elsePart + END_IF\n                ;\n            elsIfBlock.Rule =\n                MakePlusRule(elsIfBlock, elsIfStmt)\n                ;\n            elsIfStmt.Rule =\n                ELSIF + expr + THEN + actionBlock\n                ;\n            elsePart.Rule =\n                PreferShiftHere() + elsIfBlock + ELSE + actionBlock\n                | PreferShiftHere() + elsIfBlock\n                | PreferShiftHere() + ELSE + actionBlock\n                | Empty\n                ;\n            argument.Rule =\n                assignmentExpr\n                | expr\n                ;\n            arguments.Rule =\n                argument\n                | returnValue\n                ;\n            returnValue.Rule =\n                identifier + ToTerm(&quot;=&gt;&quot;) + expr\n                | identifier + ToTerm(&quot;=&amp;gt;&quot;) + expr\n                ;\n            functionArgs.Rule =\n                MakeStarRule(functionArgs, COMMA, arguments)\n                ;\n            funCall.Rule =\n                V + LEFT_PAREN + functionArgs + RIGHT_PAREN\n                ;\n            controlFlow.Rule =\n                EXIT\n                | RETURN\n                ;\n            declarationBlock.Rule =\n                TYPE + declarationList + END_TYPE\n                ;\n            declarationList.Rule =\n                MakePlusRule(declarationList, declarationStmt)\n                ;\n            declarationStmt.Rule =\n                V + COLON + ARRAY + LEFT_SQ + V + ToTerm(&quot;..&quot;) + V + RIGHT_SQ + OF + V + TERMINATE\n                | V + COLON + STRUCT + dmList + END_STRUCT + TERMINATE\n                | V + COLON + LEFT_PAREN + acceptList + RIGHT_PAREN + TERMINATE\n                ;\n            dmList.Rule =\n                MakePlusRule(dmList, V + COLON + V + TERMINATE)\n                ;\n            acceptList.Rule =\n                MakePlusRule(acceptList, COMMA, V)\n                ;\n            varBlock.Rule =\n                VAR + varList + END_VAR\n                ;\n            varList.Rule =\n                MakePlusRule(varList, varStmt)\n                ;\n            varStmt.Rule =\n                V + COLON + ARRAY + LEFT_SQ + V + ToTerm(&quot;..&quot;) + V + RIGHT_SQ + OF + V + TERMINATE\n                | V + COLON + V + TERMINATE\n                | V + COLON + V + ASSIGNMENT + value + TERMINATE\n                ;\n            expr.Rule = term | unExpr | binExpr;\n            term.Rule = N | parExpr | funCall | identifier;\n            parExpr.Rule = LEFT_PAREN + expr + RIGHT_PAREN;\n            unExpr.Rule = unOp + term + ReduceHere();\n            unOp.Rule = ToTerm(&quot;-&quot;) | NOT;\n            binExpr.Rule = expr + binOp + expr;\n            binOp.Rule = ToTerm(&quot;+&quot;) | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;^&quot; | &quot;=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;&lt;&gt;&quot; | AND | OR | XOR | &quot;&amp;gt;&quot; | &quot;&amp;lt;&quot; | &quot;&amp;gt;=&quot; | &quot;&amp;lt;=&quot; | &quot;&amp;lt;&amp;gt;&quot;;\n            caseStmt.Rule =\n                CASE + expr + OF + caseBlock + elseOpt + END_CASE\n                ;\n            caseBlock.Rule =\n                MakePlusRule(caseBlock, caseLine)\n                ;\n            caseLine.Rule =\n                value + COLON + action\n                ;\n            old_value.Rule =\n                V + PreferShiftHere() + COLON + OLD\n                ;\n            new_value.Rule =\n                V + PreferShiftHere() + COLON + NEW\n                ;\n            value.Rule =\n                identifier\n                | N\n                ;\n            elseOpt.Rule =\n                ELSE + actionBlock\n                | Empty\n                ;\n\n            this.Root = actionBlock;\n            #endregion BNFRules</code></pre>\n\n",
    "PostedDate": "2013-09-12T19:37:25.323-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1092062",
    "ThreadId": "455553",
    "Html": "<pre><code>            #region OperatorPrecedence\n            RegisterOperators(10, &quot;:=&quot;);\n            RegisterOperators(15, &quot;=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;&lt;&gt;&quot;, &quot;and&quot;, &quot;or&quot;, &quot;xor&quot;, &quot;&amp;gt;&quot;, &quot;&amp;lt;&quot;, &quot;&amp;gt;=&quot;, &quot;&amp;lt;=&quot;, &quot;&amp;lt;&amp;gt;&quot;);\n            RegisterOperators(20, &quot;+&quot;, &quot;-&quot;);\n            RegisterOperators(30, &quot;*&quot;, &quot;/&quot;, &quot;mod&quot;);\n            RegisterOperators(60, Associativity.Right, &quot;^&quot;);\n            RegisterOperators(70, &quot;(&quot;);\n            #endregion OperatorPrecedence\n\n            MarkPunctuation(&quot;,&quot;, &quot;;&quot;, &quot;[&quot;, &quot;]&quot;, &quot;)&quot;, &quot;(&quot;, &quot;..&quot;, &quot;.&quot;, &quot;:&quot;, &quot;by&quot;, &quot;new&quot;, &quot;old&quot;);\n            RegisterBracePair(&quot;(&quot;, &quot;)&quot;);\n            this.MarkTransient(action, arrayOrStructRHS, identifier, byExpr, term, parExpr, unOp, binOp, expr, value, arguments);\n        }</code></pre>\n\nThis is my grammar.<br />\n",
    "PostedDate": "2013-09-12T19:38:13.233-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1093391",
    "ThreadId": "455553",
    "Html": "There is a bug in Irony in the way it reports the error, it should say the names of nonterminals that have missing AstNode type. \r<br />\nAnd after fixing this (I will push the fix shortly), here's your problem. It is in the statement:\r<br />\n<br />\ndmList.Rule =<br />\n<pre><code>      MakePlusRule(dmList, V + COLON + V + TERMINATE)\n</code></pre>\n\nThe second argument of MakePlusRule is automatically converted to NonTerminal - that's the way it works - and this NT has no AstNode type. You should declare this NonTerminal explicitly and assign AstNode type to it<br />\n",
    "PostedDate": "2013-09-16T23:47:41.893-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "1093392",
    "ThreadId": "455553",
    "Html": "Here's the fix for the parser, just in case you need it asap. File AstBuilder.cs, method VerifyLanguageData, at the very end, replace the AddMessage call with the following: <br />\n<pre><code>    Context.AddMessage(ErrorLevel.Error, SourceLocation.Empty, Resources.ErrNodeTypeNotSetOn, string.Join(&quot;, &quot; , missingList));\n</code></pre>\n\nJust checked with explicitly declared nonterminal for this dmList-element expr, it no longer gives an error. <br />\n",
    "PostedDate": "2013-09-16T23:51:03.913-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": "2015-04-22T01:34:30.79-07:00"
  },
  {
    "Id": "1093393",
    "ThreadId": "455553",
    "Html": "Thank you for the reply. It is working fine now.<br />\n",
    "PostedDate": "2013-09-16T23:57:00.59-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]
<div class="wikidoc"><h1>Willing to Contribute? Here is a To-Do list for Release</h1>July 07, 2011.<br />Hi everybody!<br />These are things that, in my opinion, need to be done before we declare the Release. Any help and contributions are welcome! <br /><b>For a while, I will NOT be working on any of these items, or in this area</b> - so feel free to pick any item and start hacking. I will be finishing Interpreter.<br />If you see something you would like to work on, make sure you are in contact with other people who may be working on the same item. Once you selected the project, find an existing discussion related to it. Either follow the link to discussion thread in the project item (if it is enabled), or search Discussions page for a thread about this item. If there&#39;s no existing thread, then start a new one - set the title to match the item title. Post a message to this <a href="http://irony.codeplex.com/discussions/264535">discussion thread</a> announcing your intent to work on some item, with a link to item&#39;s discussion.<br />I will update the link to discussion thread on this page.<br /><br />
<h2>Scanning and Terminals</h2> <b><del>P1: Create LineContinuationTerminal</del></b> - DONE, <a href="http://irony.codeplex.com/discussions/265782">http://irony.codeplex.com/discussions/265782</a><br />A terminal class to handle continuation symbols like &quot;_&quot; in VB, use it in GWBasic. <br />Note: MiniPython grammar in Samples uses CodeOutlineFilter that handles continuation symbol &quot;\&quot;. But for simpler case like GwBasic it seems overcomplicated, better have a simple terminal just for this.<br /><br /><b>P2: Handling embedded documentation (Xml comments)</b>  (Discussion thread)<br />A terminal to handle Xml comments or other types of embedded documentation (&quot;=begin/=end&quot; in Ruby, DocLines in Python). The terminal (TokenFilter?) should assemble documentation block from multiple lines and put it into ParseTreeNode.Documentation field (to be added) of the subsequent parse tree node.<br /><br /><b>P3: Implement IncludeText support</b>  (Discussion thread)<br />Facility to handle &quot;include&quot; statement, when you include text directly into the source (not reference external module). See discussion http://irony.codeplex.com/Thread/View.aspx?ThreadId=204640<br /><br /><b>P4: Fancy string types</b>  (Discussion thread)<br />Either extend StringLiteral, or create a new terminal to handle the following:
<ol><li>Lua: [[ ... ]] string type; note: fist newline is ignored. Also the start end pair might be with &quot;=&quot; added:   [===[ .... ]===] ; same for comment  --[[ ... ]] </li>
<li>Ruby:  &#39;%&#39; notation (<a href="http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals">http://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals</a>)</li></ol>
<pre>
       myString = %&amp;This is my String&amp;
	%Q/This is the same as a double-quoted string./    # &#39;%Q&#39; is treated as double-quoted string  </pre><br />Interesting case is &#39;%w&#39;: %w(foo bar baz) is equivalent to  [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;]  - maybe a separate terminal for handling this?<br /><br /><b>P5: Handling implied &quot;+&quot; between string literals.</b>   (Discussion thread)<br />Ruby allows missing &quot;+&quot; operator in concatenating strings:<br /><pre>
		myString = &quot;Welcome &quot; &quot;to &quot; &quot;Ruby!&quot;
		=&gt; &quot;Welcome to Ruby!&quot; </pre><br />Add support for this to StringLiteral - new option flag; if it is set, the matching code tries to search beyond the ending quote and checks if it is followed by other literal; if yes - the string is joined in one token.<br /><br /><b>P6: Implement HereDoc terminal (Ruby)</b> (Discussion thread)<br />Implement a terminal class to handle embedded text like HereDoc in Ruby (similar things in other languages?).<br />Ruby HereDoc element is treated as double-quoted string; &#39;&lt;&lt;-&#39; allows indenting ending tag; &#39;&lt;&lt;&#39; does not; <br />Note that Ruby allows starting multiple HereDocs on a single line<br /><pre>
		puts &lt;&lt;BEGIN + &quot;&lt;--- middle ---&gt;\n&quot; + &lt;&lt;END
		This is the beginning:
		BEGIN
		And now it is over!
		END
		
		# this equals this expression:
		puts &quot;This is the beginning:\n&lt;--- middle ---&gt;\nAnd now it is over!&quot;
</pre><br /><br /><b>P7: Create reduced Ruby grammar</b>  (Discussion thread)<br />To test all these fancy terminals mentioned in previous sections (Ruby variations) - would be nice to have some reduced version of Ruby grammar - call it MiniRuby?<br /><br /><b>P8: Add RegEx validation pattern to Identifier terminal; support for specific values</b> (Discussion thread)<br />Some languages have certain rules about identifiers; for ex, &#39;Oneletter+OneDigit&#39; in GwBasic. Add a property to IdentifierTerminal, Regex expression, to validate the identifier. <br />On a similar theme: Scheme has a notion of &quot;Peculiar identifier&quot; in its syntax definition - identifier with a fixed list of values:<br /> Peculiar identifier = +|-|... <br />See how this can be supported. Maybe Regex pattern listing all variations?<br /><br /><b>P9: Support for nested comments</b> (Discussion thread)<br />Examples:  {- and -} in Haskell, similar thing in Scheme with &quot;&#39;(...)&quot; - commenting out blocks of code with nested parenthesis.<br />Add support for this to CommentTerminal.<br /><br /><b>P10: Support for &quot;special&quot; treatment of the first line in code file</b> (Discussion thread)<br /> Lua- first line in file ignored if it starts with #; similar in CSV files - the first line has field names<br />One way to implement: add a LanguageFlag, and if it is set, Scanner calls some special overridable method in Grammar: HandleFirstLine(....)<br /><br /><b>P11: Implement BackgroundTextTerminal</b>   (Discussion thread)<br />A special terminal for grabbing everything that does not fall into other terminals. Will be used in Wiki and template parsers. <br />Let&#39;s look at Wiki terminals as an example. It has a bunch of terminals with certain start symbols, like &quot;*&quot; for bold, etc.<br />Scanner select a terminal based on current input symbol, trying to match it to one of First symbols of registered terminals. If it fails to match to any, it should call Background terminal (this can be done probably by making it a &quot;fallback&quot; terminal - the one that does not declare any test symbols). Now the interesting stuff. The background terminal should &quot;eat&quot; the text until it hits any of the &quot;First&quot; symbols of other terminals.  At this point it stops, produces token and yields control to Scanner - which will try to select a terminal again. <br />To be able to do this (stop at other&#39;s firsts), the background terminal must be able to &quot;spy&quot; on other terminals and grab all their &quot;first&quot; symbols at initialization. <br /><br /><b>P12: Terminal for handling inlined Xml</b> (Discussion thread)<br />A terminal to scan inlined Xml (Scala). <br />
<h2>Miscellaneous projects (more challenging and requiring more effort)</h2><b><del>P21: Implement fast compiled delegate to create AST nodes</del></b> DONE: <a href="http://irony.codeplex.com/discussions/265806">http://irony.codeplex.com/discussions/265806</a><br />AstNodes are created by Parser using reflection, which is slow. Implement creating dynamic compiled delegates calling AST node constructors. For an example, see Vita project, EntityClassBuilder class, method InstanceCreatorMethod - creates compiled method to create entity instances. Plan: NonTerminal should have a property Creator - pointer to delegate creating the Ast instance. If it is null (default), then the method is built by ParserDataBuilder. Then this method is used by Parser for creating node instances. Place all static creator methods in one static class generated at runtime. <br />Note that there is already a method pointer for custom AST node creation. This new one is an addition, for the case when grammar provides AstNode type only.<br /><br /><b>P22: Switch to .NET big int, complex, rational in VS2010</b>  (Discussion thread)<br />BigInteger, Complex are supported in .NET 4.0. Implementation of ration numbers (BigRational) is available here: <a href="http://bcl.codeplex.com">http://bcl.codeplex.com</a>. <br />A good place to test is Scheme grammar - Scheme supports all these data types.<br /><br /><b>P23: Console window for Grammar Explorer</b>  (Discussion thread)<br />Create and integrate Console control in Grammar Explorer, to show interactive console directly inside in the form, instead of read-only Runtime Output window.<br /><br /><b>P24: Pretty print facility</b> (Discussion thread)<br />Implement &quot;pretty printer&quot; - some way to output parse tree in a nice formatted form. The formatting options should be provided through some setup class (like indentation, etc)<br /><br /><b>P25: Specifying custom infix operator precedence and associativity on per-file basis.</b>  (Discussion thread)<br />Haskell allows this: infix, infixl, infixr methods in Haskell.<br /><br /><b>P26: Finish LINQ syntax implementation in c# grammar.</b>  (Discussion thread)<br />This is mostly to explore additional twist - scoped reserved words. <br />Extract from c# language spec, section 7.16.1:<br /><br />  <i>Query expressions contain a number of “contextual keywords”, i.e., identifiers that have special meaning in a given context. Specifically these are from, where, join, on, equals, into, let, orderby, ascending, descending, select, group and by. In order to avoid ambiguities in query expressions caused by mixed use of these identifiers as keywords or simple names, these identifiers are considered keywords when occurring anywhere within a query expression.</i><br />  <i>For this purpose, a query expression is any expression that starts with “from identifier” followed by any token except “;”, “=” or “,”.</i><br /><br />This introduces a concept of &quot;scoped&quot; reserved words: some keywords are reserved words (in Irony&#39;s meaning) only inside some scope/statement. Suggestions on implementation?<br /><br /><b>P27: Refactor/rebuild unit tests projects.</b>  (Discussion thread)<br />This is a big one. The current state is a shameful mess. Existing unit tests make quick shortcuts to instantiate terminals and call TryParse directly. <br />We need to implement more complete tests, with test grammars, systematically covering all aspects of functionality.<br />
<h2>Advanced Research Projects</h2><b>P31: Survey popular languages</b><br />Survey modern languages and identify which facilities are missing in Irony to build parsers for these languages (mainly terminals). Suggested languages to look at: Scheme, Python, Ruby, GwBasic, Lua, Tcl, JavaScript, Clojure, Scala, Boo,Haskell, Erlang, Groovy, Smalltalk, PHP, Go (new Google language). <br />All these are modern and popular languages - but why not include older ones - like Cobol? Even if we never write Cobol compiler, somebody may need to write colorizer for Cobol editor.<br /><br /><b><del>P32: Token Preview -based Semi-Automatic Conflict Resolution.</del></b> (DONE)<br />This topic deserves its own page: <a href="https://irony.codeplex.com/wikipage?title=Contrib_ConflictResolution&referringTitle=ContribProjects">Automatic Conflict Resolution</a>.<br /><br /><b>P33: Macro facilities</b><br />See how to implement macro facilities, starting from plain c macros up to advanced stuff like Scheme Macro system.<br /><br /><b>P34: Template processor</b><br />Parser for template files, which include &quot;text&quot; and embedded script commands (Ruby rhtml format as an example).<br />Things to consider - embedded grammars or sub-grammars, a separate grammar attached to some terminal that will be used to parse sub-sections of the text.<br /><br /><b>P35: Basic code analysis algorithms</b><br />Implement some basic code analysis - &quot;Lattices&quot; and all that stuff. Maybe not for this release, but more long-term. The goal is to implement algorithms for detecting loops, uninitialized variables, unused code, etc. The most approachable introduction to the subject I found in &quot;Advanced Compiler Design Implementation&quot; by Steven Muchnick.<br /><br /><br /><br /><br /> </div><div class="ClearBoth"></div>